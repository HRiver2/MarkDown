# 树上带修莫队

前置当然是[莫队算法](https://www.luogu.com.cn/blog/Wild-Donkey/pian-fen-dai-shi-mu-dui), [带修莫队](https://www.luogu.com.cn/blog/Wild-Donkey/dai-xiu-pian-fen-mu-dui-post), [树上莫队](https://www.luogu.com.cn/blog/Wild-Donkey/shu-shang-pian-fen-mu-dui-post). 树上带修莫队是这三者的结合体.

因为已经掌握了带修莫队和树上莫队, 所以需要阐述的东西不多, 直接结合经典题[糖果公园](https://www.luogu.com.cn/problem/P4074)分析该算法.

## 题面简述

一棵树, $n$ 个点, 每点颜色为 $m$ 中颜色中的一种. $V_i$ 表示第 $i$ 种颜色的权值. $W_i$ 表示一种颜色出现第 $i$ 次的权值. 两种操作, 一种是将单点的颜色修改为已有的 $m$ 种颜色中的另一种. 第二种操作是对这棵树上的路径进行查询. 如果用 $Cnt_i$ 表示路径上颜色为 $i$ 的点的出现次数, 则一个路径的权值是这个路径上的所有颜色的权值乘它们的出现次数对应的权值的前缀和的总和. 可能语言表述有些绕, 接下来用公式表示. 

$$
\sum_{i = 1}^{m}(V_i\sum_{j = 1}^{Cnt_i}(W_j))
$$

## 思路

首先考虑不带修改的做法: 把树拍扁成一个 $2n$ 长度的括号序列, 然后对序列上的颜色出现的数量进行查询, 同时维护 $Ans$.

然后考虑加上修改, 保存修改序列, 然后对欧拉序跑带修莫队即可.

分析块长, 我们知道对于一个序列长为 $n$, 查询 $m$ 次, 修改 $t$ 次的问题, 最佳块长是 $\sqrt [3]{\frac{n^2t}{2m}}$, 但是我们的序列长度是 $2n$, 所以带修莫队的最优块长是 $\sqrt [3]{\frac{2n^2t}{m}}$, 考虑代码写完之后修正一下对时间增量的常数和对端点增量的常数差距, 所以将块长暂时规定为 $2\sqrt [3]{\frac{n^2t}{m}}$.

值得一提的是, 这个题不需要离散化.

接下来放出主体代码:

```cpp
```