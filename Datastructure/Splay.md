# Splay

一种平衡树, 虽然常数较大, 但是凭着特殊的功能和较小的代码难度成为了很多人初学平衡树的首选. (当然我是受李煜东的 `进阶指南` 影响从 Treap 学起的)

## Binary Search Tree (二分查找树)

想象一种二叉树, 它可以用来维护一个集合, 可以用来查找, 删除和添加元素, 还支持查找集合的最值 (权值最大/小的元素) ,一个节点的前驱/后缀 (权值严格小/大于这个元素的权值最大/小的元素). 这就是二分查找树, 简称 BST.

这种树满足父亲节点权值大于的左子树中任意节点的权值, 小于右子树所有节点的权值.

查找一个元素时, 从根节点开始, 向下一步步递归查找, 如果查找的权值比当前节点大, 就查找它的右儿子; 如果查找的权值比当前节点小, 就查找它的左儿子; 如果当前节点的权值就是要查找的权值, 就不用找了, 说明已经找到了.

如果找到最后, 最后经过的节点不是要找的节点, 却没有对应的左/右子树, 说明不存在相应元素.

添加元素也是相似的, 先查找这个权值, 如果找到了, 更新对应节点的计数器即可; 如果找不到, 就给最后一个经过的节点添加一个儿子, 左右取决于插入的权值和该节点权值的关系.

删除, 查找最值, 查找前驱/后缀等操作也是差不多的思想, 无非是根据需要的权值在 BST 找到对应位置, 在这个位置上进行操作罢了, 所以都离不开查找这个步骤.

因为基于查找, 每种操作, 除查找之外的部分复杂度都是 $O(1)$, 而查找的最劣次数取决于 BST 的深度, 所以这种 BST 的时间复杂度完全取决于它的深度. 而在插入顺序允许的情况下 (如单调递增数列), 则 BST 深度可达 $O(n)$, 在操作数为 $m$ 的前提下, 复杂度就成了 $O(nm)$. 而在理想状态下, 由二叉树的性质可得, BST 存在深度为 $O(\log n)$ 的情况, 这时对 $m$ 次操作的复杂度是 $O(m\log n)$. 可以看出裸 BST 的效率显然是很不稳定的, 所以考虑优化.

## 平衡树

由定义可以得出一个 BST 的性质, 对于同一组元素, BST 不唯一. 对于任何集合, 对应的 BST 的深度在构造合理的前提下都能达到 $O(\log n)$ 的水平, 下面介绍深度满足这种复杂度的 BST 的特征.

深度要达到 $O(\log n)$. BST 一定要趋近于满二叉树, 而这要求每个节点的左右子树的大小 (节点数) 和深度都是近似的, 即每个节点都是接近平衡的.

这样构造的 BST 称作平衡树. 而 Splay 就是一种能使 BST 趋近于平衡的构造和维护方式 (或者说操作), 这样维护的 BST 一般称为 Splay 树, 简称 Splay.

## 旋转

一种对 BST 进行局部操作但是不会破坏 BST 性质的操作, 是 Splay 等基于旋转的平衡树的基础. 

前排提醒: 由于旋转存在父亲要变成儿子的儿子等神奇操作, 可能引发伦理危机. 好在幸亏节点不讲伦理, 所以学习这部分内容时请放下你的道德. 但是一定不要用你身边的朋或家人进行类比, 否则后果自负.

对于一个节点 $i$, 定义 $LS_i$, $Ri_i$ 是它的左/右儿子, $Fa_i$ 是它的父亲, $Val_i$ 是它的权值.

由 BST 性质得 $Val_{LS_i} < Val_i < Val_{RS_i}$, 而 $Val_i$ 和 $Val_{Fa_i}$ 的大小关系需要根据 $i$ 是 $Fa_i$ 的哪个儿子进行分类讨论. 接下来的规则将在改变节点的位置的同时, 保证这些性质不变.

由于旋转的参照物不同, 会对旋转结果产生不同的影响, 所以针对参考系进行分类讨论. (当然有很多自创的名词, 但是为了更好表达这种思想, 这也是必要的)

规定下面介绍的旋转规则中所有公式表达中的节点 (如 $LS_{RS_{Fa_i}}$), 都表示旋转前的节点, 和旋转后的相对关系无关.

### 绕自旋转

绕自旋转又分为两个方向: 左旋 (Zag) 和右旋 (Zig).

- Zag (左旋)

  旋转 $i$ 的意义是使 $RS_i$ 变成 $i$ 的父亲. 这时如果要维护 BST 的性质, $i$ 只能做 $RS_i$ 的左儿子. 而旋转后 $RS_i$, $i$ 和他们的子树上的节点的权值与 $Val_{Fa_i}$ 的大小关系不变, 所以旋转前 $i$ 是 $Fa_i$ 的哪边的儿子, 旋转后 $RS_i$ 就是 $Fa_i$ 的哪边的儿子.

  $RS_i$ 的 左儿子变成了 $i$, 所以 $RS_i$ 原来的左子树便被挤掉了, 这时就需要子树的交接 (或者说, 过户). 发现 $i$ 失去了 $RS_i$ 作为儿子, 所以说 $i$ 的右儿子的位置空了出来. 因为 $Val_{RS_i} > Val_{LS_{RS_i}} > Val_i$, 所以 $LS_{RS_i}$ 做 $i$ 的新右儿子是合法的, 也是合适的.

  如果想象着这种操作的动态过程, 可以发现操作相当于 $LS_{RS_i}$ 和 $RS_i$ 绕 $i$ 逆时针旋转, 然后重新连边. 在屏幕前的视角就是向左旋转, 故名 `左旋`

  ![看到它说明图片炸了](https://i.loli.net/2021/04/26/PAScNzKYIlrWTw5.png)

- Zig (右旋)

  参考结构化学中的[手性](https://zh.wikipedia.org/wiki/%E6%89%8B%E6%80%A7)的概念, Zig 就是 Zag 的对映操作. 也就是以 $Fa_i - i$ 中轴线为对称轴, 和 Zig 对称的操作, 对细节不再赘述.

### 绕父旋转

在这种规则下, 旋转 $i$ 的意义是使 $i$ 变成 $Fa_i$ 的父亲. 但是 $Fa_i$ 旋转后是 $i$ 的哪一边的儿子, 则要根据旋转前 $i$ 是 $Fa_i$ 的哪一边的儿子决定.

- $i$ 是 $Fa_i$ 的左儿子

这时 $Val_i < Val_{Fa_i}$, 所以旋转后 $Fa_i$ 应该做 $i$ 的右儿子, 也就是对 $Fa_i$ 进行 Zig.

- $i$ 是 $Fa_i$ 的右儿子

同理, $Val_i > Val_{Fa_i}$, 旋转后 $Fa_i$ 是 $i$ 的左儿子, 则对 $Fa_i$ 进行 Zag.

由于绕父旋转的方式在一个特定位置的节点上是一定的, 所以没有绕自旋转的 Zig, Zag 规则之分. 其本质就是根据不同相对位置关系对父亲进行 Zig/Zag 的调用, 所以是绕 $Fa_i$ 的旋转, 所以称作绕父旋转.

## 伸展 (Splay)

由上面的旋转规则可以发现, 如果针对一个点一直绕父旋转, 每次这个点的深度都减少 $1$, 则这个点迟早会变成根. 这种操作的方式不唯一, 因为 "绕爷旋转" 和绕父旋转都可以使一个节点的深度减少, 而且作用效果不同. (绕爷旋转的意思是对父亲进行绕父旋转)

再引入一个定义: 性别 (虽然不是官方叫法, 但我决得很形象, 姑且先这样叫). 设一个点的左儿子是男性, 右儿子是女性.

规定一种旋转准则:

- 如果还有爷爷

  - 如果父子同性
    
    则先绕爷旋转, 然后绕父旋转. 这时原来的爷爷成了儿子, 原来的父亲成了孙子, 原来的爷爷和父亲在做儿子和孙子时同性.
    
  - 如果父子异性 (有些奇怪, 那就将父子理解成辈分好了)
    
    则绕父旋转两次. 这时, 原来的爷爷和父亲成了龙凤胎. 性别由旋转之前的性别决定, 爷爷会优先将父亲原来的性别让给父亲, 所以父亲的性别不变.
    
- 如果没有爷爷

  则绕父旋转. 这是操作的边界, 这次旋转完后, 这个节点就成为了树根, 连父亲都没有了.
  
我们把根据这种准则将点 $i$ 一直旋转到根的操作记为 `Splay(i)`.

定义一个操作经过的最后一个还在集合中的节点是目标节点. (这里强调还在集合中是因为删除一个节点后, 被删除的节点最后经过, 而显然这个点已经不在了)

通过 Splay 操作优化 BST 深度的操作比较玄学, 证明也更加麻烦, 所以直接给出具体操作: (证明困难户直接放弃)

每次进行操作后, Splay 目标节点. 就能使过程中 Splay 树的深度维持在近似 $O(\log n)$.

但是对于删除操作略有不同, 这时可以将一般操作和 Splay 的操作交换一下顺序. 具体操作是先将待删除点 Splay 到树根, 删除. 剩下两棵子树, 记为 $LS_i$, $RS_i$. 随便选一个儿子作为新树, 全看个人喜好. 举例子: 重男轻女的可以将左子树的最大值 $Max_{LS}$ Splay 到男子树顶, 这时, $Max_{LS}$ 的左儿子应该是 $LS_i$, 并且它没有右儿子. 合并两棵子树, 也就是将 $RS_i$ 接到 $Max_{LS}$ 的空缺的右儿子位置上. 重女轻男的情况也相似, 将前面的操作对称一下就好了.

## 代码

众所周知, 一般的数据结构都是由结构体和函数构成的, 所以接下来将一个一个函数去解析.

先写最底层的旋转, 因为 Splay 用到的就只有绕父旋转, 所以这里就只写绕父旋转, 不单独写 Zig, Zag 了.



