# Splay

一种平衡树, 虽然常数较大, 但是凭着特殊的功能和较小的代码难度成为了很多人初学平衡树的首选. (当然我是受李煜东的 `进阶指南` 影响从 Treap 学起的)

## Binary Search Tree (二分查找树)

想象一种二叉树, 它可以用来维护一个集合, 可以用来查找, 删除和添加元素, 还支持查找集合的最值 (权值最大/小的元素) ,一个节点的前驱/后缀 (权值严格小/大于这个元素的权值最大/小的元素). 这就是二分查找树, 简称 BST.

这种树满足父亲节点权值大于的左子树中任意节点的权值, 小于右子树所有节点的权值.

查找一个元素时, 从根节点开始, 向下一步步递归查找, 如果查找的权值比当前节点大, 就查找它的右儿子; 如果查找的权值比当前节点小, 就查找它的左儿子; 如果当前节点的权值就是要查找的权值, 就不用找了, 说明已经找到了.

如果找到最后, 最后经过的节点不是要找的节点, 却没有对应的左/右子树, 说明不存在相应元素.

添加元素也是相似的, 先查找这个权值, 如果找到了, 更新对应节点的计数器即可; 如果找不到, 就给最后一个经过的节点添加一个儿子, 左右取决于插入的权值和该节点权值的关系.

删除, 查找最值, 查找前驱/后缀等操作也是差不多的思想, 无非是根据需要的权值在 BST 找到对应位置, 在这个位置上进行操作罢了, 所以都离不开查找这个步骤.

因为基于查找, 每种操作, 除查找之外的部分复杂度都是 $O(1)$, 而查找的最劣次数取决于 BST 的深度, 所以这种 BST 的时间复杂度完全取决于它的深度. 而在插入顺序允许的情况下 (如单调递增数列), 则 BST 深度可达 $O(n)$, 在操作数为 $m$ 的前提下, 复杂度就成了 $O(nm)$. 而在理想状态下, 由二叉树的性质可得, BST 存在深度为 $O(\log n)$ 的情况, 这时对 $m$ 次操作的复杂度是 $O(m\log n)$. 可以看出裸 BST 的效率显然是很不稳定的, 所以考虑优化.

## 平衡树

由定义可以得出一个 BST 的性质, 对于同一组元素, BST 不唯一. 对于任何集合, 对应的 BST 的深度在构造合理的前提下都能达到 $O(\log n)$ 的水平, 下面介绍深度满足这种复杂度的 BST 的特征.

深度要达到 $O(\log n)$. BST 一定要趋近于满二叉树, 而这要求每个节点的左右子树的大小 (节点数) 和深度都是近似的, 即每个节点都是接近平衡的.

这样构造的 BST 称作平衡树. 而 Splay 就是一种能使 BST 趋近于平衡的构造和维护方式 (或者说操作), 这样维护的 BST 一般称为 Splay 树, 简称 Splay.

## 旋转

一种对 BST 进行局部操作但是不会破坏 BST 性质的操作, 是 Splay 等基于旋转的平衡树的基础. 

前排提醒: 由于旋转存在父亲要变成儿子的儿子等神奇操作, 可能引发伦理危机. 好在幸亏节点不讲伦理, 所以学习这部分内容时请放下你的道德. 但是一定不要用你身边的朋或家人进行类比, 否则后果自负.

对于一个节点 $i$, 定义 $LS_i$, $Ri_i$ 是它的左/右儿子, $Fa_i$ 是它的父亲, $Val_i$ 是它的权值.

由 BST 性质得 $Val_{LS_i} < Val_i < Val_{RS_i}$, 而 $Val_i$ 和 $Val_{Fa_i}$ 的大小关系需要根据 $i$ 是 $Fa_i$ 的哪个儿子进行分类讨论. 接下来的规则将在改变节点的位置的同时, 保证这些性质不变.

由于旋转的参照物不同, 会对旋转结果产生不同的影响, 所以针对参考系进行分类讨论. (当然有很多自创的名词, 但是为了更好表达这种思想, 这也是必要的)

规定下面介绍的旋转规则中所有公式表达中的节点 (如 $LS_{RS_{Fa_i}}$), 都表示旋转前的节点, 和旋转后的相对关系无关.

### 绕自旋转

绕自旋转又分为两个方向: 左旋 (Zag) 和右旋 (Zig).

- Zag (左旋)

  旋转 $i$ 的意义是使 $RS_i$ 变成 $i$ 的父亲. 这时如果要维护 BST 的性质, $i$ 只能做 $RS_i$ 的左儿子. 而旋转后 $RS_i$, $i$ 和他们的子树上的节点的权值与 $Val_{Fa_i}$ 的大小关系不变, 所以旋转前 $i$ 是 $Fa_i$ 的哪边的儿子, 旋转后 $RS_i$ 就是 $Fa_i$ 的哪边的儿子.

  $RS_i$ 的 左儿子变成了 $i$, 所以 $RS_i$ 原来的左子树便被挤掉了, 这时就需要子树的交接 (或者说, 过户). 发现 $i$ 失去了 $RS_i$ 作为儿子, 所以说 $i$ 的右儿子的位置空了出来. 因为 $Val_{RS_i} > Val_{LS_{RS_i}} > Val_i$, 所以 $LS_{RS_i}$ 做 $i$ 的新右儿子是合法的, 也是合适的.

  如果想象着这种操作的动态过程, 可以发现操作相当于 $LS_{RS_i}$ 和 $RS_i$ 绕 $i$ 逆时针旋转, 然后重新连边. 在屏幕前的视角就是向左旋转, 故名 `左旋`

  ![看到它说明图片炸了](https://i.loli.net/2021/04/26/JHFlSVK5iamuvD7.png)

- Zig (右旋)

  参考结构化学中的[手性](https://zh.wikipedia.org/wiki/%E6%89%8B%E6%80%A7)的概念, Zig 就是 Zag 的对映操作. 也就是以 $Fa_i - i$ 中轴线为对称轴, 和 Zig 对称的操作, 对细节不再赘述.

### 绕父旋转

在这种规则下, 旋转 $i$ 的意义是使 $i$ 变成 $Fa_i$ 的父亲. 但是 $Fa_i$ 旋转后是 $i$ 的哪一边的儿子, 则要根据旋转前 $i$ 是 $Fa_i$ 的哪一边的儿子决定.

- $i$ 是 $Fa_i$ 的左儿子

这时 $Val_i < Val_{Fa_i}$, 所以旋转后 $Fa_i$ 应该做 $i$ 的右儿子, 也就是对 $Fa_i$ 进行 . 

- $i$ 是 $Fa_i$ 的右儿子

同理, $Val_i > Val_{Fa_i}$

## Splay

这种优化的操作比较玄学, 证明也比较麻烦, 所以直接给出结论.

定义一个操作经过的最后一个还在集合中的节点是目标节点. (这里强调还在集合中是因为删除一个节点后, 被删除的节点最后经过, 而显然这个点已经不在了)

每次进行操作后, 针对目标节点