# 树套树

这是一种思想, 不是什么特定的数据结构, 不过实现起来一般都是从外层的树形数据结构的每个节点上, 挂一个内层树形数据结构的根的指针, 这样, 本来是要查询或修改外层节点的信息的行为, 变成了在外层某节点对应的内层数据结构上查询或修改某种信息.

容易发现, 这种思想非常占空间, 所以一般这种数据结构尤其是内层, 必须动态开点或直接实现可持久化.

## [模板](https://www.luogu.com.cn/problem/P3380)

直接来看一道题来感受这种思想:

维护一个序列, 支持:

- 区间查询第 $k$ 小的数

- 区间查排名

- 单点修改

- 区间查前驱

- 区间查后继

官方做法是用线段树做外层数据结构, 每个节点挂一棵平衡树, 存储这个线段树节点表示的区间的数, 因为平衡树本来就是动态开点的, 所以空间是可以接受的, 加起来是 $O(nlogn)$.

区间查排名, 只需要 $O(logn)$ 找出这个区间对应的 $O(logn)$ 棵平衡树, 然后对每个平衡树 $O(logn)$ 查询排名, 总共 $O(log^2n)$.

单点修改也很简单, $O(logn)$ 找出包含这个单点的 $O(logn)$ 棵平衡树, 每棵平衡树 $O(logn)$ 删除, $O(logn)$ 插入即可.

对于区间查询第 $k$ 小的数, 因为是在 $logn$ 棵树上查询, 所以不能像普通平衡树一样, 二分查找这个位置, $O(logn)$ 查询. 只能二分答案, $O(logn)$ 的二分答案, $O(logn)$ 的线段树上查询, $O(logn)$ 的平衡树上查询, 总复杂度 $O(log^3n)$.

区间查前驱后继貌似也没有好办法, 只能二分答案, 对 $O(logn)$ 棵平衡树分别进行 $O(logn)$ 次复杂度为 $O(logn)$ 次查询, 总时间 $O(log^3n)$.

所以对于 $m$ 次操作的总复杂度应该是 $O(mlog^3n)$.

