[TOC]

# ZROI

## Day21: 状压 DP

### 状态压缩

状态是一个 $k$ 进制数, 将每个元素的状态用每个 $k$ 进制位的值表示.

### 轮廓线 DP

上一道题如果不是一行一起转移, 而是每个位置讨论放或者不放, 将讨论的状态变成这个位置及以上的一个轮廓线的状态, 这样可以优化时间复杂度, 从 $O(2^nn)$ 状态, $O(2^n)$ 转移优化到 $O(2^nn^2)$ 状态, $O(1)$ 转移.

### [SCOI2005](https://www.luogu.com.cn/problem/P1879) 

一个矩形, 分成 $n * m$ 个格子, 有的格子能选, 有的不能选, 要求选择的格子两两不相邻, 求合法的选取方式数对 $10^8$ 取模的余数.

设计状态 $f_{i, j}$, 表示从上到第 $i$ 行, 第 $i$ 行的状态是 $j$ 的二进制表示的.

我们可以先预处理出合法的行状态, $List_i$ 表示第 $i$ 个没有两个格子相邻的行状态.

$$
f_{i, j} = \sum_k^{k \in List, k \And j = k \And a_i = 0}(f_{i - 1, k})
$$

注: $a_i$ 是棋盘第 $i$ 行状态.

但是因为一直以来想写 $O(n^2(2^n))$ 的做法, 所以趁机练习一下传说中的轮廓线  DP, 所以重新设计状态, 设 $f_{i, j, k}$ 表示决策了 $i - 1$ 行, 第 $i$ 行决策到了第 $j$ 列的合法方案数, 其中第 $i$ 行的 $[0, j]$ 列和第 $i + 1$ 行的 $[j + 1, m)$ 列拼起来的状态为 $i$.

状态数 $O(n^2(2^n))$ 转移可以做到 $O(1)$, 复杂度 $O$, 本题 $n = 12$, 代入是 $589824$.

但是因为原来的做法复杂度和合法状态数 $Cnt$ 有关, 所以原来 $n(4^n)$ 的做法其实是 $O(nCnt^2)$ 貌似也没有很劣, $n = 12$ 时状态数是 $377$, 所以代入是 $1705548$, 因为原做法可以大量位运算优化, 并且没有那么多边界条件, 实际效率甚至比轮廓线优.

接下来放轮廓线代码:

```cpp
const unsigned long long Mod(100000000);
unsigned long long f[15][15][4500], Ans;
unsigned a[15], m, n, n2, Cnt(0), A, B, C, D, t, Tmp(0);
int main() {
  n = RD(), m = RD(), n2 = (1 << m); 
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned j(1); j <= m; ++j) {
      a[i] <<= 1, a[i] += RD();
    }
  }
  f[0][m - 1][0] = 1;
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned k(0); k < n2; ++k) {
      if(!(k & 1)) {f[i][0][k] = f[i - 1][m - 1][k ^ 1] + f[i - 1][m - 1][k]; if(f[i][0][k] >= Mod) f[i][0][k] -= Mod;}
      if(a[i] & k & 1) f[i][0][k] = f[i - 1][m - 1][k ^ 1];
    }
    for (register unsigned j(1); j < m; ++j) {
      for (register unsigned k(0); k < n2; ++k) {
        if((k & (1 << j)) && (k & (1 << (j - 1)))) continue;
        if(a[i] & k & (1 << j)) f[i][j][k] = f[i][j - 1][k ^ (1 << j)];
        if(!(k & (1 << j))) {f[i][j][k] = f[i][j - 1][k ^ (1 << j)] + f[i][j - 1][k]; if(f[i][j][k] >= Mod) f[i][j][k] -= Mod;}
      }
    }
  }
  for (unsigned i(0); i < n2; ++i) Ans += f[n][m - 1][i];
  printf("%llu\n", Ans % Mod);
  return Wild_Donkey;
}
```

### [NOI2001](https://www.luogu.com.cn/problem/P2704)

仍然先预处理出合法状态集合 $List$, 然后设计状态 $f_{i, j, k}$ 表示算到第 $i$ 行, 第 $i$ 行状态为 $j$, 第 $i - 1$ 行状态为 $k$ 的情况.

$$
f_{i, j, k} = \sum_{l}^{l \in List, l \And j = l \And k = l \And a_{i - 2} = 0} f_{i - 1, k, l}
$$

早年诡异码风改了改, 细节不多不少, 枚举两排状态确实很神奇, 看起来非常慢, 实际上可行状态不多跑得飞快.

```cpp
unsigned int a[105], f[105][65][65], List[65], m, n, N, Cnt(0), A, B, C, D, Ans(0);
bool b[10005];
char s;
inline unsigned int Gtnm(unsigned int x) {
  unsigned int tmp(0); 
  while (x) {
    if(x & 1) ++tmp;
    x = x >> 1;
  }
  return tmp;
}
inline bool Judge (unsigned int x) {
  unsigned int tmp(0x3f);
  while (x) {
    if(x & 1) {
      if(tmp < 2) return 0;
      tmp = 0;
    }
    else ++tmp;
    x = x >> 1;
  }
  return 1;
}
int main() {
  n = RD(), m = RD(), N = (1 << m) - 1;
  for (register int i(0); i <= N; ++i) if (Judge(i)) List[++List[0]] = i;
  for (register int i(1); i <= n; ++i) {
    for (register int j(1); j <= m; ++j) {//init
      while (s != 'H' && s != 'P') s = getchar();
      a[i] = a[i] << 1;
      if (s == 'H') ++a[i];
      s = '0';
    }
  }
  for (register unsigned int i(1); i <= List[0]; ++i) {//1st line
    if (List[i] & a[1]) continue;//land
    Cnt = Gtnm(List[i]);
    f[1][i][1] = Cnt;
  }
  for (register unsigned int i(2); i <= n; ++i) {
    for (register unsigned int j(1); j <= List[0]; ++j) {//this line
      if (List[j] & a[i]) continue;//land
      Cnt = Gtnm(List[j]);
      for (register unsigned int k(1); k <= List[0]; ++k) {//last line
        if(List[j] & List[k] || List[k] & a[i - 1]) continue;//Gun
        for (register unsigned int l(1); l <= List[0]; ++l) {//last of last 
          if(List[j] & List[l] || List[k] & List[l] || List[l] & a[i - 2]) continue;
          f[i][j][k] = max(f[i - 1][k][l] + Cnt, f[i][j][k]); 
        }
      }
    }
  }
  for (register unsigned int i(1); i <= List[0]; ++i)
    for (register unsigned int j(1); j <= List[0]; ++j)
      Ans = max(f[n][i][j], Ans);
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### [SDOI2009](https://www.luogu.com.cn/problem/P2157)

设计状态 $f_{i, j, 0/1, k}$ 表示 $i$ 前面都拿到饭, $i$ 没拿到饭, $j$ 集合的人已经拿到饭, 最后拿到饭的人是 $i ± k$ 的最少时间. 

$$
f_{i, j, 0, k} = min(f_{i - k, (j << k) | (1 << (k - 1) - 1), 0, l} + (T_{i - k - l} \oplus T_{i - k}),\\
f_{i - k, (j << k) | (1 << (k - 1) - 1), 1, l} + (T_{i - k + l} \oplus T_{i - k}))\\
f_{i, j, 1, k} = min(f_{i, j - (1 << (k - 1)), 0, l} + (T_{i + k - l} \oplus T_{i + k}),\\
f_{i, j - (1 << (k - 1)), 1, l} + (T_{i + k + l} \oplus T_{i + k}))
$$

注意这个题 $i$ 拿的时候可能上一个拿的是 $i - 8$, 所以需要考虑 $8$ 个位置.

```cpp
unsigned m, n;
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
unsigned Like[1015], Anger[1015], f[1015][150][2][10];
unsigned Cant[10];
inline void Clr() {
  memset(f, 0x3f, sizeof(f));
  memset(Like, 0x3f, sizeof(Like));
  n = RD(), Ans = 0x3f3f3f3f;
}
signed main() {
  t = RD();
  Anger[0] = 0x3f3f3f3f;
  Cant[0] = -1;
  for (unsigned i(1); i <= 8; ++i) Cant[i] = Cant[i - 1] << 1;
  for (unsigned T(1); T <= t; ++T) {
    Clr();
    for (unsigned i(1); i <= n; ++i) Like[i] = RD(), Anger[i] = RD();
    f[2][0][0][1] = 0, Anger[n + 1] = 0;
    for (unsigned i(2), Now(0x3f3f3f3f); i <= 8; ++i) {
      Now = min(Now, Anger[i - 1] + i - 1);
      if (i > Now) break;
      f[1][1 << (i - 2)][1][i - 1] = 0;
    }
    for (unsigned i(1); i <= n + 1; ++i) {
      unsigned Mxj(1 << Anger[i]);
      for (unsigned j(0); j < Mxj; ++j) {
        unsigned Now(Cant[Anger[i]]);
        for (unsigned No(1); No <= 8; ++No)
          if (!((1 << (No - 1)) & j)) Now |= Cant[Anger[i + No]] << No;
        if (j & Now) continue;
        Now = i - 1;
        for (unsigned k(0); k < 8; ++k) if (j & (1 << k)) Now = i + k + 1;
        for (unsigned k(1); k <= 8; ++k) {
          if (i < k) break;
          if (Anger[i - k] < Now - i + k) continue;
          unsigned Des(j << k);
          Des |= (1 << (k - 1)) - 1;
          for (unsigned l(1); l <= 8; ++l) {
            if (i - k < l) break;
            f[i][j][0][k] = min(f[i][j][0][k], f[i - k][Des][0][l] + (Like[i - k - l] ^ Like[i - k]));
          }
          for (unsigned l(1); l <= 8; ++l) {
            //            if(k == l) continue;
            f[i][j][0][k] = min(f[i][j][0][k], f[i - k][Des][1][l] + (Like[i - k + l] ^ Like[i - k]));
          }
        }
        for (unsigned k(1); k <= 8; ++k) {
          if (!((1 << (k - 1)) & j)) continue;
          if (Anger[i + k] < Now - i - k) continue;
          unsigned Des(j ^ (1 << (k - 1)));
          for (unsigned l(1); l <= 8; ++l) {
            if (i < l) break;
            f[i][j][1][k] = min(f[i][j][1][k], f[i][Des][0][l] + (Like[i - l] ^ Like[i + k]));
          }
          for (unsigned l(1); l <= 8; ++l) {
            if (!((1 << (l - 1)) & Des)) continue;
            f[i][j][1][k] = min(f[i][j][1][k], f[i][Des][1][l] + (Like[i + l] ^ Like[i + k]));
          }
        }
      }
    }
    for (unsigned i(1); i <= 7; ++i) Ans = min(Ans, f[n + 1][0][0][i]);
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

### [AHOI2009](https://www.luogu.com.cn/problem/P2051)

在棋盘上放置中国象棋中的炮, 使得没有炮能互相攻击, 求方案数.

问题转化为往棋盘上放点, 使得不存在三个点在一行或一列中.

状态 $f_{i, j, k}$ 表示到第 $i$ 行, 有 $j$ 列有 $1$ 个炮, $k$ 列有 $2$ 个炮.

$$
\begin{aligned}
f_{i, j, k} = &f_{i - 1, j, k} +\\
&(n - k - j + 1)f_{i - 1, j - 1, k} +\\
&(j + 1)f_{i - 1, j + 1, k - 1} +\\
&\binom{n - k - j + 2}{2}f_{i - 1, j - 2, k} +\\
&\binom{j + 2}{2}f_{i - 1, j + 2, k - 2} +\\
&j(n - k - j + 1)f_{i - 1, j, k - 1}
\end{aligned}
$$

代码使用滚动数组, 所以枚举顺序比较神奇, 轻松冲到最优解前几名.

```cpp
const unsigned long long Mod(9999973);
unsigned long long Ans(0), f[105][105], C2[105];
unsigned m, n;
signed main() {
  n = RD(), m = RD();
  C2[0] = 0, f[0][0] = 1;
  for (unsigned i(1); i <= n; ++i) C2[i] = (i * (i - 1)) >> 1;
  for (unsigned i(1); i <= m; ++i) for (unsigned k(n); ~k; --k) for (unsigned j(n - k); ~j; --j) {
    unsigned long long Tmp(0);
    if(j) {
      Tmp += f[j - 1][k] * (n - k - j + 1);
      if(j > 1) Tmp += f[j - 2][k] * C2[n - k - j + 2];
    }
    if(k) {
      Tmp += f[j][k - 1] * j * (n - k - j + 1) + f[j + 1][k - 1] * (j + 1);
      if(k > 1) Tmp += f[j + 2][k - 2] * C2[j + 2];
    }
    f[j][k] = (f[j][k] + Tmp) % Mod;
  }
  for (unsigned i(0); i <= n; ++i) for (unsigned j(0); j + i <= n; ++j) Ans += f[i][j];
  printf("%llu\n", Ans % Mod);
  return Wild_Donkey;
}
```

### [P5005](https://www.luogu.com.cn/problem/P5005)

在棋盘上放置中国象棋中的马, 使得没有马能互相攻击或单向攻击, 求方案数.

仍然状压两位, $f_{i, j, k}$ 表示到第 $i$ 行, 第 $i$ 行状态为 $k$, 第 $i - 1$ 行状态为 $j$ 的状态.

$$
f_{i, k, l} = \sum f_{i - 1, j, k}\\
!(((j << 2) \And (((1 << m) - 1) \oplus ((j \And k) << 1))) | ((j >> 2) \And (((1 << m) - 1) \oplus ((j \And k) >> 1))) \And k),\\
!(((j << 1) \And (((1 << m) - 1) \oplus (k \And (k << 1)))) | ((j >> 1) \And (((1 << m) - 1) \oplus (k \And (k >> 1)))) \And l),\\
!(((k << 2) \And (((1 << m) - 1) \oplus ((k \And l) << 1))) | ((k >> 2) \And (((1 << m) - 1) \oplus ((k \And l) >> 1))) \And l),\\
$$

这个题太毒了, 必须滚数组, 因为它的内存只开了 $1MB$.

```cpp
const unsigned long long Mod(1000000007);
unsigned long long Ans(0);
unsigned f[65][65], g[65][65];
unsigned m, n, M;
unsigned A, B, C, D, t;
unsigned Cnt(0), Tmp(0);
signed main() {
  n = RD(), M = 1 << (m = RD());
  g[0][0] = 1;
  for (unsigned i(1); i <= n; ++i) {
    for (unsigned j(0); j < M; ++j) {
      for (unsigned k(0); k < M; ++k) {
        unsigned Verjk(j & k);
        if(!((((j << 2) & ((M - 1) ^ (Verjk << 1))) | ((j >> 2) & ((M - 1) ^ (Verjk >> 1)))) & k & (M - 1))) {
          for (unsigned l(0); l < M; ++l) {
            unsigned Ver(k & l), No(0), Hor(k & (k << 1));
            No |= (((j >> 1) & ((M - 1) ^ (Hor >> 1))) | ((j << 1) & ((M - 1) ^ Hor)));
            No |= (((k >> 2) & ((M - 1) ^ (Ver >> 1))) | ((k << 2) & ((M - 1) ^ (Ver << 1))));
            if(!(No & l & (M - 1))) {
              f[k][l] += g[j][k];
              if(f[k][l] >= Mod) f[k][l] -= Mod;
            }
          }
        }
      }
    }
    memcpy(g, f, sizeof(f));
    memset(f, 0, sizeof(f));
  }
  for (unsigned i(0); i < M; ++i) {
    for (unsigned j(0); j < M; ++j) {
      Ans += g[i][j];
    }
  }
  printf("%llu\n", Ans % Mod);
  return Wild_Donkey;
}
```

### [TJOI2015](https://www.luogu.com.cn/problem/P3977)

每个点的范围是 $3 * p$, 仍然求放点使其不能攻击的方案数.

因为转移规则是一个矩阵, 所以不方便使用位运算判断, 用转移矩阵对状态进行转移.

预处理每个行状态能转移到下一行的哪个状态, 建一个 $2^m * 2^m$ 的矩阵, 用矩阵快速幂加速转移, 复杂度 $O(8^m \log n)$.

```cpp
vector <char> To[65];
unsigned List[65], Do[65], f[65], g[65];
unsigned M, m, n, p, P, Q;
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
char Flg(0);
struct Matrix {
  unsigned Val[65][65];
  inline Matrix operator * (Matrix& x) {
    Matrix TmpT;
    for (unsigned i(1); i <= Cnt; ++i) {
      memset(TmpT.Val[i], 0, (Cnt + 1) << 2);
      for (unsigned j(1); j <= Cnt; ++j) {
        for (unsigned k(1); k <= Cnt; ++k) {
          TmpT.Val[i][j] += Val[i][k] * x.Val[k][j];
        }
      }
    }
    return TmpT;
  }
}Mu, Eps;
signed main() {
  n = RD(), M = 1 << (m = RD()), p = RD(), Q = p - (P = RD()) - 1;
  for (unsigned j(0); j < p; ++j) B |= (RD() << j);
  for (unsigned j(0); j < p; ++j) A |= (RD() << j);
  for (unsigned j(p - 1); ~j; --j) C |= (RD() << j);
  for (unsigned i(0); i < M; ++i, Flg = 0) {
    for (unsigned j(0); (j < m) && (!Flg); ++j) if((1 << j) & i) {
      i ^= (1 << j);
      if(j < P) Flg = (i & (A >> (P - j))) ? 1 : 0;
      else Flg = (i & (A << (j - P))) ? 1 : 0;
      i ^= (1 << j);
    }
    if(!Flg) List[++Cnt] = i;
  }
  for (unsigned i(1); i <= Cnt; ++i) {
    for (unsigned j(0); j < M; ++j) if((1 << j) & List[i]) {
      if(j < P) Do[i] |= (B >> (P - j));
      else Do[i] |= (B << (j - P));
      if(j < Q) Do[i] |= (C >> (Q - j));
      else Do[i] |= (C << (j - Q));
    }
  }
  for (unsigned j(1); j <= Cnt; ++j) for (unsigned k(1); k <= Cnt; ++k)
    Eps.Val[j][k] = !(Do[j] & List[k]);
  for (unsigned i(1); i <= Cnt; ++i) Mu.Val[i][i] = 1;
  while (n) {
    if(n & 1) Mu = Mu * Eps;
    n >>= 1, Eps = Eps * Eps;
  }
  for (unsigned i(1); i <= Cnt; ++i) Ans += Mu.Val[1][i];
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### [NOIP2017](https://www.luogu.com.cn/problem/P3959)

给一个无向图, 求一个生成树使得代价最小, 一个生成树的代价是边的代价之和, 每条边的代价是边的权值和边下端点深度的积. $n \leq 12$.

这个题 Prim 被 Hack 了, 详情见 RQY 的[数据](https://paste.ubuntu.com/25953020/).

然后我当时感觉自己很牛逼, 发明的 $O(2^nn^2)$ 做法.

> 设计状态 $f_{i}$ 表示选择了 $i$ 状态的点, $O(2^n)$. 定义数组 $g_{i, j}$ 表示状态 $i$ 中, $j$ 点的深度. 转移是枚举加入哪个点, 然后对于每个加入的点, 枚举它的父亲, 转移 $O(n^2)$. 总复杂度 $O(2^nn^2)$, 所以这个题 $n$ 开到 $15$ 也不是不能做.

emm, 这个做法必然是假了, 因为一个状态, 不一定是最优的, 什么意思, 就是说一个集合表示的状态, 它所记录的权值只是一个最优局部解, 有后效性, 所以是可以假的, 小的 Hack 数据不好构造, 所以就不构造了.

这个题真正的解法, 是一层一层地转移. 设计状态 $f_{i, j}$ 表示已经构造了 $i$ 层, 这 $i$ 层包含了集合 $j$ 的点. 转移时枚举 $j$ 的子集 $k$, 从状态 $f_{i - 1, k}$ 转移而来, 它关于 $j$ 的补集中的点作为第 $i$ 层, 因为不知道 $k$ 中哪个点在第 $i$ 层, 所以就默认都在第 $i - 1$ 层, 这样的答案不会更大, 而这种方式会枚举所有的情况, 所以不会得到错误的答案.

$$
f_{i, j} = \min_{k \subseteq i} (f_{k, j - 1} + i\sum_{a \in (k \oplus i)}\min_{b \in k}E_{a, b})
$$

枚举所有集合的子集是 $O(3^n)$, 每次枚举哪个点连哪个点是 $O(n^2)$, 阶段是 $O(n)$, 总复杂度 $O(n^33^n)$.

可以预处理出每个点 $j$ 到一个集合 $i$ 的最短距离 $Mn_{i, j}$, 把转移优化到 $O(n)$, 总复杂度 $O(On^23^n)$

$$
f_{i, j} = \min_{k \subseteq i} (f_{k, j - 1} + i\sum_{a \in (k \oplus i)} Mn_{k, a}
$$

```cpp
#define Lbt(x) ((x)&((~(x))+1))
unsigned N, m, n, A, B, C, t, Ans(0);
unsigned f[5005][15], E[15][15], Min[5005][15], Log[5005];
int main() {
  N = 1 << (n = RD()), m = RD();
  memset(E, 0x3f, sizeof(E));
  memset(f, 0x3f, sizeof(f));
  memset(Min, 0x3f, sizeof(Min));
  for (unsigned i(1); i <= m; ++i) {
    A = RD() - 1, B = RD() - 1;
    E[A][B] = E[B][A] = min(E[B][A], RD());
  }
  for (unsigned i(0); i < n; ++i) Log[1 << i] = i;
  for (unsigned i(1); i <= N; ++i) Log[i] = max(Log[i - 1], Log[i]);
  for (unsigned i(0); i < N; ++i) {
    unsigned TL(i ^ (N - 1));
    for (unsigned j(i); j; j -= Lbt(j)) {
      unsigned Frm(Log[Lbt(j)]);
      for (unsigned k(TL); k; k -= Lbt(k)) {
        unsigned To(Log[Lbt(k)]);
        Min[i][To] = min(Min[i][To], E[Frm][To]);
      }
    }
  }
  f[0][0] = 0;
  for (unsigned i(0); i < n; ++i) f[1 << i][0] = 0;
  for (unsigned i(1); i < n; ++i) {
    for (unsigned j(0); j < N; ++j) {
      for (unsigned k(j); ; k = (j & (k - 1))) {
        unsigned TL(j ^ k), Sum(0);
        for (unsigned l(TL); l; l -= Lbt(l)) {
          unsigned To(Log[Lbt(l)]);
          Sum += Min[k][To];
        }
        f[j][i] = min(f[j][i], f[k][i - 1] + i * Sum);
        if (!k) break;
      }
    }
  }
  printf("%u\n", f[N - 1][n - 1]);
  return Wild_Donkey;
}
```

### [P3943](https://www.luogu.com.cn/problem/P3943)

一个长为 $n$ 的 `0/1` 串, 有 $k$ 个 $0$, 每次允许取反特定长度的区间, $m$ 种区间长度. 求最少取反几次得到 $n$ 个 $1$.

对于区间取反问题, 首先想到的就是差分, 把原数组做异或差分得到新数组. 数据保证有解则差分数组 $1$ 的总数一定是偶数, 每次考虑消除一对 $1$.

因为区间长度有限, 所以不能预处理每个长度的取反最少步数, 考虑其它方式.

我们用类似最短路的思想, 如果每个可行操作长度记为 $a_i$, 那么这个问题就相当于给 $n + 1$ 个点跑单源最短路, 坐标相差为 $a_i$ 的点之间都有长度为 $1$ 的边.

因为有 $k$ 个 $0$, 所以差分数组中的 $1$ 一定不超过 $2k$ 个, 我们把这 $2k$ 个 $1$ 的存在性作为状态, $f_i$ 表示还剩 $i$ 集合中的 $1$, 最少要操作多少次, 有方程:

$$
f_i = \min_{j \in i, k \in i, j \neq k} f_{i \oplus \{j, k\}} + Dist_{j, k}
$$

因为单源最短路的起点最多 $2k$ 个, 所以一共跑 $2k$ 次 $O(mn\log (mn))$ 的最短路就可以处理 $Dist$ 数组了.

所以总复杂度 $O(2^{2k} + nm \log (nm))$.

```cpp
#define INFi 0x3f3f3f3f
#define Lbt(x) ((x)&((~(x))+1))
bitset<40005> a, Vis;
unsigned Log[70005], Pop[70005], f[70005];
unsigned Ava[105], Di[40005], List[25], Dist[25][40005];
unsigned m, n, t, A, B, C, D;
unsigned Cnt(0), Ans(0), Tmp(0);
inline void Dij(unsigned S, unsigned* Dis) {
  memset(Dis, 0x3f, (n + 2) << 2), Dis[S] = 0;
  priority_queue<pair<unsigned, unsigned> > Q;
  Vis = 0;
  Q.push(make_pair(INFi, S)), Dis[S] = 0;
  while (!Q.empty()) {
    unsigned Cur(Q.top().second);
    Q.pop();
    if (Vis[Cur])return;
    Vis[Cur] = 1;
    for (unsigned i(1); i <= m; ++i) {
      if ((Cur > Ava[i]) && (Dis[Cur - Ava[i]] > Dis[Cur] + 1))
        Dis[Cur - Ava[i]] = Dis[Cur] + 1, Q.push(make_pair(INFi - Dis[Cur - Ava[i]], Cur - Ava[i]));
      if ((Cur + Ava[i] <= n) && (Dis[Cur + Ava[i]] > Dis[Cur] + 1))
        Dis[Cur + Ava[i]] = Dis[Cur] + 1, Q.push(make_pair(INFi - Dis[Cur + Ava[i]], Cur + Ava[i]));
    }
  }
}
signed main() {
  n = RD() + 1, t = RD(), m = RD();
  memset(Di, 0x3f, sizeof(Di)), Di[0] = 0;
  memset(f, 0x3f, sizeof(f));
  for (unsigned i(1); i <= t; ++i) A = RD(), a[A] = (a[A] ^ 1), a[A + 1] = (a[A + 1] ^ 1);
  for (unsigned i(1); i <= m; ++i) Ava[i] = RD();
  for (unsigned i(1); i <= n; ++i) if (a[i]) List[++Cnt] = i, Dij(i, Dist[Cnt]);
  n = (1 << Cnt), f[n - 1] = 0;
  for (unsigned i(0); i <= n; ++i) Pop[i] = Pop[i >> 1] + (i & 1);
  for (unsigned i(0); (1 << i) <= n; ++i) Log[1 << i] = i;
  for (unsigned i(1); i <= n; ++i) Log[i] = max(Log[i - 1], Log[i]);
  for (unsigned i(n - 1); i; --i) {
    if (Pop[i] & 1) continue;
    for (unsigned j(i); j; j -= Lbt(j)) {
      unsigned Frm(Log[Lbt(j)]);
      for (unsigned k(j - Lbt(j)); k; k -= Lbt(k)) {
        unsigned To(Log[Lbt(k)]), Tur(i ^ (1 << Frm) ^ (1 << To));
        f[Tur] = min(f[Tur], f[i] + Dist[Frm + 1][List[To + 1]]);
      }
    }
  }
  printf("%u\n", f[0]);
  return Wild_Donkey;
}
```

### 例题

给一个有障碍物的棋盘, 放 $n$ 对人, 每对人不能和自己对应的人相邻, 求方案数.

设计状态 $f_{i, j, k, l}$ 表示讨论到 $(i, j)$, 轮廓线状态为 $k$, 已经填完了 $l$ 对点的方案数.

每次转移一填填一对, 一个点填在 $(i, j)$, 另一个点填在 $(i, j)$ 前面的某个空位里, 需要讨论有多少个可行的空位, 然后把方案数乘这个数量.

需要统计 $Em_{i, j}$ 表示扫描到 $(i, j)$ 的时候的空位个数, 用它减去已经填了的和不能填的就是一共能填的数量.

最后乘一个排列数即可, 因为每对人本质不同.

### [NOI2015](https://www.luogu.com.cn/problem/P2150)

为什么没有人用容斥呢? 本做法复杂度 $O(3^8n)$.

给正整数 $[2, n]$, 选两个不交子集, 使得两个子集中任意两个数互质. 求方案数.

分析性质, 发现对于每个质数 $p$, 两个数集中只有一个数集存在整除 $p$ 的元素. 所以状态就是两个集合分别包含的质因数集合即可, 必须要求两个集合 $\And$ 后是 $0$.

设 $n$ 以内有 $m$ 个质数, 则复杂度是 $O(2^{2m}n)$.

发现 $500$ 以内的数, 大于 $19$ 的质因数最多有一个.

小于等于 $19$ 的质数只有 $2, 3, 5, 7, 11, 13, 17, 19$, 共 $8$ 个. 如果我们把包含大于 $19$ 质因数的数字先剔除不计, 仅分配剩下这些质因数, 那么每个人的集合有 $2^8$ 种情况, 两个人的状态数是 $4^8$ 种, 因为两个人的集合不交, 每个元素的状态只有三种, 在第一个集合中, 在第二个集合中, 不存在, 所以一共是 $3^8$ 种有效状态.

假设我们现在确定了决策完未剔除的数字后, 两个人的质因数集合. 那么对于剔除的数字, 我们可以枚举 $19$ 后面的质数, 将所有以这个质数为最大质因数的数同时考虑, 枚举三种情况, 分别是把这些数按 $19$ 以内的质因数约束分配到第一个人的集合里, 分配到第二个人的集合里, 不分配. 因为是按照确定的集合分配的, 所以 $19$ 以内质因数是确定的, $19$ 以后的质因数也不会在待处理的数中出现, 所以是正确的. 

我们把状态压成三进制, 称为集合 $S$. 每个 $S$ 唯一对应一个有序二进制集合二元组 $(A, B)$. 其中 $A \And B = 0$ 表示两个人 $19$ 以内的因数情况. $S$ 的第 $i$ 位是 $0$, 则 $A$, $B$ 的第 $i$ 位都为 $0$, 如果 $S$ 的第 $i$ 位是 $1$ 或 $2$, 则分别对应 $A$ 的第 $i$ 位为 $1$ 和 $B$ 的第 $i$ 位为 $1$.

对于每个 $S$, 我们把 $[2, n]$ 每个数按照除以 $19$ 以内所有质因数的结果分类, 可以算出 $f_S$ 表示选出的两个不交子集各自的质因数, 分别是由 $S$ 确定的 $A$, $B$ 的子集的方案数.

定义三进制集合的 PopCnt 为这个集合不为 $0$ 的元素个数. 我们发现对于一个方案 $x$, 这个方案两个人的 $19$ 以内的质因数集合分别是 $A_x$ 和 $B_x$, 这两个集合可以表示为三进制集合 $S_x$. 那么它不仅会被 $f_{S_x}$ 统计, 还会被 $S_x$ 的真超集的 $f$ 值所统计.

那么对于一个满足自己对应的 $S_x$ 的 PopCnt 为 $i$ 的方案, 被 PopCnt 为 $j$ 的 $S$ ($j \geq i$) 所统计的次数, 也就是 $S_x$ 的 PopCnt 为 $j$ 超集数量, 即为:

$$
g_{j, i} = \binom{8 - i}{8 - j} * 2^{j - i}
$$

式子很容易理解, 组合数就是枚举哪些在 $S_x$ 中为 $0$ 的位置在 $S$ 中也为 $0$, 后面的 $2^{j - i}$ 则是讨论在 $S_x$ 中为 $0$ 但是在 $S$ 中不为 $0$ 的位置, 到底取 $1$ 还是取 $2$, 互相独立, 满足乘法原理条件.

由上面的式子我们发现如果简单给 $f_S$ 求和, 一个方案会被统计多次. 所以考虑用容斥把答案凑出来.

因为方案 $x$ 的统计次数只和 $S_x$ 的 PopCnt 有关, 所以 PopCnt 相同的 $S$ 的 $f_i$ 应当是同时考虑的, 所以我们定义

$$
Sum_i = \sum_{PopCnt(S) = i} f_S
$$

也就是说我们希望能有一个数列 $a$, 使得

$$
Ans = \sum_{i = 0}^8 a_iSum_i
$$

结合前面 $g$ 的表达式, 那么对 $a$ 的要求就是: 可以使得对于所有 $i$, 有

$$
\sum_{j = i}^8 a_ig_{j, i} = 1
$$

$g$ 的形式一眼会让人联想到二项式反演, 但是在无聊的合格考过程中, 我惊奇地发现:

$$
\sum_{j = i}^n \binom{n - i}{n - j} * 2^{j - i} * (-1)^{n - j} = 1
$$

也就是说

$$
\sum_{j = i}^8 (-1)^{j}g_{j, i} = 1\\
a_i = (-1)^i
$$

至于原因, 我百思不得其解, 但是只需要对每个 $S$ 求方案数, 然后根据 $S$ 的元素数乘上相应的 $a$ 对答案进行统计即可.

```cpp
const unsigned M(6561);
const unsigned Tri[10] = { 1,3,9,27,81,243,729,2187,6561 };
const unsigned Prime[10] = { 2,3,5,7,11,13,17,19 };
vector <unsigned> Bel[505];
unsigned long long Tmp(0), Mod(998244353), Ans(0);
unsigned PopCnt[7005], Need[7005][2];
unsigned Stack[505], STop(0), Have[505];
unsigned m, n;
unsigned A, B, D, t;
unsigned Cnt(0);
signed main() {
  n = RD(), Mod = RD();
  for (unsigned i(2); i <= n; ++i) {
    unsigned Ti(i);
    for (unsigned j(0); j < 8; ++j) {
      if (!(Ti % Prime[j])) Have[i] |= (1 << j);
      while (!(Ti % Prime[j])) Ti /= Prime[j];
    }
    if (Ti > 1) Stack[++STop] = Ti;
    Bel[Ti].push_back(i);
  }
  for (unsigned i(0); i < M; ++i) {
    for (unsigned j(0); j < 8; ++j) {
      unsigned Jth((i / Tri[j]) % 3);
      if (Jth) Need[i][(Jth & 1) ? 0 : 1] |= (1 << j);
    }
  }
  sort(Stack + 1, Stack + STop + 1);
  STop = unique(Stack + 1, Stack + STop + 1) - Stack - 1;
  for (unsigned i(0); i < M; ++i) PopCnt[i] = PopCnt[i / 3] + (bool)(i % 3);
  for (unsigned i(0); i < M; ++i) {
    Tmp = 1;
    for (auto j : Bel[1]) {
      if ((Have[j] & Need[i][0]) == Have[j]) { Tmp <<= 1; if (Tmp >= Mod) Tmp -= Mod; }
      if ((Have[j] & Need[i][1]) == Have[j]) { Tmp <<= 1; if (Tmp >= Mod) Tmp -= Mod; }
    }
    for (unsigned j(1); j <= STop; ++j) {
      A = 1, B = 1;
      for (auto k : Bel[Stack[j]]) {
        if ((Have[k] & Need[i][0]) == Have[k]) { A <<= 1; if (A >= Mod) A -= Mod; }
        if ((Have[k] & Need[i][1]) == Have[k]) { B <<= 1; if (B >= Mod) B -= Mod; }
      }
      Tmp = Tmp * (A + B - 1) % Mod;
    }
    Ans += (PopCnt[i] & 1) ? (Mod - Tmp) : Tmp;
    if (Ans >= Mod) Ans -= Mod;
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

### [THU2012](https://www.luogu.com.cn/problem/P5933)

有 $n$ 个本质不同的点, 用若干条颜色不同的边将他们连成连通图, 求方案数. 每两个点 $i$, $j$ 之间有 $c_{i, j}$ 条边备选. 不允许出现重边, 自环.

我们用 $f_{i, S}$ 表示集合 $S$ 的点被连成 $i$ 个连通块的方案数. 用 $a_S$ 表示点集 $S$ 的连边方案数的总和, 也就是

$$
a_S = \prod_{i \in S, j \in S, i < j} c_{i, j}
$$

写出 $f$ 的转移方程

$$
f_{1, S} = a_S - \sum_{i = 2}^{|S|} f_{i, S}\\
f_{i, S} = \frac{\displaystyle{\sum_{S' \subset S}f_{i - 1, S'}f_{1, S - S'}}}{i}
$$

这个状态很好理解, 只要枚举 $S$ 的子集 $S'$ 从中分割出 $i - 1$ 个连通块, 然后让它的补集作为最后一个即可, 但是由于一个方案中, $S - S'$ 作为 $i$ 个连通块里任意一个都可以统计一次答案, 所以说每种情况会重复统计 $i$ 次, 最后需要除以 $i$.

$f_{1, 2^n - 1}$ 即为所求, 状态 $O(n2^n)$, 转移枚举子集, 复杂度 $O(n3^n)$, 对于 $n = 15$ 的数据跑了 $800ms$, 得了 $90'$.

```cpp
unsigned long long Mod(1000000007);
unsigned long long f[20][66000], Inv[20];
unsigned N, a[20][20], m, n, PopCnt[66000];
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
signed main() {
  N = 1 << (n = RD()), Inv[0] = Inv[1] = 1;
  for (unsigned i(0); i < n; ++i) for (unsigned j(0); j < n; ++j) a[i][j] = RD() + 1;
  for (unsigned i(0); i < N; ++i) {
    f[0][i] = 1;
    for (unsigned j(0); j < n; ++j) if (i & (1 << j))
      for (unsigned k(0); k < j; ++k) if (i & (1 << k))
        f[0][i] = f[0][i] * a[j][k] % Mod;
  }
  for (unsigned i(0); i < N; ++i) PopCnt[i] = PopCnt[i >> 1] + (i & 1);
  for (unsigned i(2); i <= n; ++i) {
    Inv[i] = Mod - (Inv[Mod % i] * (Mod / i) % Mod); if (Inv[i] >= Mod) Inv[i] -= Mod;
  }
  f[0][1] = f[1][0] = 1;
  for (unsigned i(1); i < N; ++i) {
    f[1][i] = f[0][i];
    for (unsigned k(PopCnt[i]); k > 1; --k) {
      for (unsigned j((i - 1)& i); j; j = i & (j - 1)) if (PopCnt[j] >= k - 1)
        f[k][i] = (f[k][i] + f[k - 1][j] * f[1][i ^ j]) % Mod;
      f[k][i] = f[k][i] * Inv[k] % Mod;
      f[1][i] += Mod - f[k][i];
      if (f[1][i] >= Mod) f[1][i] -= Mod;
    }
  }
  printf("%llu\n", f[1][N - 1]);
  return Wild_Donkey;
}
```

根据数据范围 $n \leq 16$, 优化掉一个 $n$ 就能过了.

我一开始记录连通块数量 $i$ 作为连通块数量, 就是为了方便直接除以 $i$ 处理重复统计. 那么只要想办法让每个方案都被统计一次, 像背包问题一样给转移找一个顺序就可以少设以为状态了. 设 $f_S$ 为集合 $S$ 被连成一个连通块的方案数, 那么 $a_S - f_S$ 就是 $S$ 被连成不止一个连通块的方案数.

我们希望求出 $S$ 被连成不止一个连通块的方案数, 用来计算 $f_S$. 我们定义 $S$ 中编号最小的点为起点, 那么起点一定被一个连通块所包含, 这个连通块的点集记为 $S'$, 对于任何一个方案, $S'$ 是唯一的, 因为编号最小的点是唯一的. 所以我们只需要枚举所有编号最小的点存在的子集 $S'$, 直接统计就能防止重复. 这就要求 $S$ 的最高位在 $S'$ 中一定也是 $1$, 这个位代表起点. 我们可以通过判断 $S'$ 的二进制数值是否大于 $S - S'$ 快速判断 $S'$ 是否合法.  

最后写出方程:

$$
f_S = a_S - \sum_{S' \subset S, S' > S - S'} f_{S'}a_{S - S'}
$$

状态数 $O(2^n)$, 枚举子集转移, 复杂度 $O(3^n)$, $n = 16$ 的数据跑了 $300ms$.

```cpp
unsigned long long Mod(1000000007);
unsigned long long f[66000], g[66000];
unsigned long long Tmp(0);
unsigned N, a[20][20], n;
signed main() {
  N = 1 << (n = RD()), f[0] = 1;
  for (unsigned i(0); i < n; ++i) for (unsigned j(0); j < n; ++j) a[i][j] = RD() + 1;
  for (unsigned i(0); i < N; ++i) {
    g[i] = 1;
    for (unsigned j(0); j < n; ++j) if (i & (1 << j))
      for (unsigned k(0); k < j; ++k) if (i & (1 << k))
        g[i] = g[i] * a[j][k] % Mod;
  }
  for (unsigned i(1); i < N; ++i, Tmp = 0) {
    for (unsigned j((i - 1)& i); j; j = i & (j - 1)) if (j > (i ^ j))
      Tmp = (Tmp + f[j] * g[i ^ j]) % Mod;
    f[i] = Mod + g[i] - Tmp;
    if (f[i] >= Mod) f[i] -= Mod;
  }
  printf("%llu\n", f[N - 1]);
  return Wild_Donkey;
}
```

### [AT2390](https://www.luogu.com.cn/problem/AT2390)

博弈论 + DP?

貌似博弈论和 DAG 往往同时出现...

先不管 DP, 考虑枚举所有边的存在状态, 如何判断一个状态是否先手必胜.

我们认为一个状态由两个棋子的坐标组成, 于是设布尔变量 $f_{i, j}$ 为第一个棋子在 $i$, 第二个棋子在 $j$ 是否为必胜态. 根据博弈论的基本原理 (能转移到必败态的状态必胜), 可以得到转移方程:

$$
f_{i, j} = [(\exist_{i \rightarrow k} (f_{k, j} = 0)) \lor (\exist_{j \rightarrow k} (f_{i, k} = 0))]
$$

所以就可以写出复杂度 $O(m ^ 2)$ 的判断可行性的代码:

```cpp
inline void Check() {
  for (unsigned i(n); i; --i) {
    for (unsigned j(n); j; --j) {
      Con[i][j] = 0;
      for (auto iT : N[i].E) if (iT.second)
        Con[i][j] |= (1 ^ Con[iT.first - N][j]);
      for (auto jT : N[j].E) if (jT.second)
        Con[i][j] |= (1 ^ Con[i][jT.first - N]);
    }
  }
  Ans += Con[1][2];
}
```

忽然发现我不懂什么是 SG 函数, 怒学. 设 $SG_i$ 为 $i$ 点的属性, 则当只有一个棋子时, 这个局面先手必胜的充要条件是对于这个棋子的所在点 $i$, 有 $SG_i > 0$.

我们把 $SG_i > 0$ 的点称为必胜点, 则 SG 值表示着一个必胜点的等级. 对于必败点, 其 SG 值为 $0$, 反之则必胜. $SG_i$ 等于 $i$ 能到达的所有点的 SG 值集合中最小的不被包含的数字.

对于两个棋子所在点的 SG 值为 $0$ 的时候, 它们不能走到 SG 为 $0$ 的任何点. 如果这个时候两个棋子都无路可走, 先手立刻失败. 如果这时有棋子可以走, 则走到的点 SG 为 $x$, 且 $x > 0$, 后手可以立刻把这个棋子移动到另一个 SG 为 $0$ 的点上. 因为是 DAG, 所以每个状态至多经过一次, 所以迟早会走到先手无路可走的状态. 所以 SG 都为 $0$ 的状态先手必败.

由 SG 值的定义我们知道, 一个必胜点 $i$ 一定能走到 SG 值为 $(SG_i, 0]$ 的点. 如果两个棋子的 SG 值相等, 那么先手把棋子移动到 SG 为 $x$ 的点, 后手一定也有方式可以将另一个棋子移动到 SG 值为 $x$ 的点, 先手首先将一个棋子所在点的 SG 值变成 $0$, 后手紧接着把另一个棋子所在点的 SG 值变为 $0$, 这时先手必败. 因此两个棋子所在位置 SG 值相同先手必败.

如果两个棋子 SG 值不同, 设一个是 $x$, 一个是 $y$, $x > y$. 先手可以直接把所在位置 SG 为 $x$ 的棋子移动到 SG 值为 $y$ 的位置上, 直接得到两个棋子位置同为 $y$ 的必败态, 后手必败.

因此对于一个方案, 可以求每个位置的 SG 值, 然后判断 $1$ 号点和 $2$ 号点的 SG 值是否相等即可. 得到了 $O(n^22^m)$ 的判断函数.

```cpp
inline void Check() {
  for (unsigned i(n); i; --i) {
    memset(Tmp, 1, sizeof(Tmp));
    for (auto j : N[i].E) if (j.second) Tmp[Sig[j.first - N]] = 0;
    for (unsigned j(0); j <= n; ++j) if (Tmp[j]) { Sig[i] = j; break; }
  }
  Ans += (Sig[1] ^ Sig[2]) ? 1 : 0;
}
```

接下来是避免枚举连边情况, 考虑状压. 设计状态 $f_{i, S}$ 表示集合 $S$ 中 SG 值都 $\leq i$, 并且集合 $2^n - 1 - S$ 中所有点的 SG 值都至少是 $i + 1$ 的方案数. $f_{i, S}$ 的每个方案中, $S$ 集合中的点到所有点和所有点到 $S$ 集合中的点的边的存在情况已经确定, $2^n - 1 - S$ 中的点之间的边的存在情况尚未确定.

转移是枚举子集, 将 $S$ 的一个非空子集 $S'$ 作为所有 SG 值为 $i + 1$ 的点的集合, 只需要计算 $S'$ 中的点随意向 $2^n - 1 - S$ 中的点连边的方案数乘 $2^n - 1 - S$ 中的每个点至少连一条向 $S'$ 的方案数即可转移.

我们用 $b_{i, A}$ 表示点 $i$ 到 $A$ 集合的边数, 就可以写出方程:

$$
f_{i, S} += f_{i - 1, S - S'} (\prod_{j \in S'} 2^{b_{j, 2^n - 1 - S}}) (\prod_{j \in 2^n - 1 - S} 2^{b_{j, S'} - 1})
$$

这个式子很好理解, 只要从 $f_{i - 1, S - S'}$ 的情况中, 把 $S'$ 中的点作为 SG 为 $i + 1$ 的点, 它们不能内部连边, 这样就没有通往 SG 为 $i + 1$ 的边, 但是可以向 SG 大于 $i + 1$ 的点连边, 所以随意连接 $2^n - 1 - S$ 中的点, 对于 $2^n - 1 - S$ 的点, 它们已经可以通往 $[0, i]$ 所有 SG 值了, 现在要求它们能够连向 SG 为 $i + 1$ 的点, 随意连的方案里面只有一种是一条都没连的, 所以只要减 $1$ 然后连乘起来就好了.

我们这样算出来的方案对答案没有用处, 但是通过约束 $S'$ 必须不只包含 $1, 2$ 其中之一 (也就是要么两个都包含, 否则都别包含), 就可以使得每种情况里, $1, 2$ 两点的 SG 值相等. 因为所有的方案最大 SG 值为 $n - 1$ (理论上强制 $1, 2$ SG 相等, 最大 SG 值只有 $n - 2$), 所以答案就可以表示为:

$$
2^m - \sum_{i = 0}^{n - 1} f_{i, 2^n - 1} 
$$

也就是所有的情况减去 $1, 2$ SG 值相等的所有情况数. 状态 $O(n2^n)$, 枚举子集并且枚举集合元素转移, 复杂度 $O(n^23^n)$.

```cpp
const unsigned long long Mod(1000000007);
unsigned long long Ans(0), f[16][33005], Bin[200];
vector <unsigned> Have[33005];
unsigned a[20][33005], m, n, N;
unsigned A, B, C, D, t;
char Li[20][20];
signed main() {
  N = (1 << (n = RD())) - 1, m = RD(), Bin[0] = 1;
  for (unsigned i(1); i <= m; ++i) { Bin[i] = Bin[i - 1] << 1; if (Bin[i] >= Mod) Bin[i] -= Mod; }
  for (unsigned i(1); i <= m; ++i) A = RD() - 1, Li[A][RD() - 1] = 1;//A to Li[A]
  for (unsigned i(0); i <= N; ++i)//Set Contain
    for (unsigned j(0); j < n; ++j)
      if (i & (1 << j)) Have[i].push_back(j);
  for (unsigned i(0); i < n; ++i) {//Point to Set
    for (unsigned j(i + 1); j < n; ++j) if (Li[i][j]) a[i][1 << j] = 1;
    for (unsigned j(0); j <= N; ++j) a[i][j] = a[i][j - Lbt(j)] + a[i][Lbt(j)];
  }
  for (unsigned i(0); i <= N; ++i) {//Side Case
    f[0][i] = 1;
    for (auto j : Have[i]) f[0][i] = f[0][i] * Bin[a[j][N ^ i]] % Mod;
    for (auto j : Have[N ^ i]) f[0][i] = f[0][i] * (Bin[a[j][i]] - 1) % Mod;
  }
  for (unsigned i(1); i < n; ++i) {
    for (unsigned j(0); j <= N; ++j) {
      for (unsigned k(j); k; k = ((k - 1) & j)) {
        if ((!(k & 3)) || ((k & 3) == 3)) {
          unsigned long long Tmp(1);
          for (auto Poi : Have[N ^ j]) Tmp = Tmp * (Bin[a[Poi][k]] - 1) % Mod;
          for (auto Poi : Have[k]) Tmp = Tmp * Bin[a[Poi][N ^ j]] % Mod;
          f[i][j] = (f[i][j] + f[i - 1][j ^ k] * Tmp) % Mod;
        }
      }
    }
  }
  Ans = Bin[m];
  for (unsigned i(0); i < n; ++i) {
    Ans = Mod + Ans - f[i][N];
    if (Ans >= Mod) Ans -= Mod;
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

### [P4363](https://www.luogu.com.cn/problem/P4363)

一个棋盘, 每个格子有两个值 $a_{i, j}$ 和 $b_{i, j}$, 先手选 $(i, j)$ 获得收益 $a_{i, j}$, 后手选 $(i, j)$ 获得 $b_{i, j}$. 每个格子 $(i, j)$ 选当且仅当除了它以外, $x \in [1, i]$, $y \in [1, j]$ 的所有 $(x, y)$ 都已经选了. 若每个人采用最优策略, 求最后双方的差值.

因为每个格子选择的条件, 每个状态可以表示为一个从左下角到右上角, 只能向右和向上走的长度为 $n + m$ 的折线, 折线左上方都选了, 左下都没选. 折线可以用长度 $n + m$ 的二进制数来表示, `0` 表示向上, `1` 表示向右, 因为有 $n$ 个 `0`, 所以状态数为 $\binom {n + m}n$ 种.

将 $[1, \binom {n + m}n]$ 的数作为状态值和对应的二进制数映射, 然后对它进行转移. 我本来是想设 $f_{S}$ 为状态 $S$ 的答案, 也就是都按最优策略选的结果.

一开始尝试把所有能转移来的状态里找一个最优的作为 $f_{S}$ 的值, 但是样例过不了, 因为这样转移的前提是最优的前一个状态必须存在, 但是实际上一个人选择一个格子的时候是不能选择从什么状态的基础上选的, 所以会错误.

后来把所有可以转移来的状态里找一个最劣的作为 $f_{S}$ 的值, 可以过样例, 但是只有 $30'$, 原因也很简单, 如果每次都按最劣的转移, 确实可以保证决策后答案一定不会更劣, 但是这样最优策略却无从体现. 比如一个状态 $S$, 可以从 $S_1$, $S_2$ 转移而来, 而 $S_1$, $S_2$ 都可以从 $S_3$. 我需要决策选择 $S_1$ 还是 $S_2$ 转移到 $S$, 这时 $S_2$ 更劣, 但是我可以在 $S_3$ 的决策中直接选择转移到 $S_1$, 避开 $S_2$ 的状态. 这样就证明了这种转移的错误性.

百思不得其解的我去看题解, 发现题解的状态设计和我唯一的不同的是, 我看到是过去, 他们看的是未来. $f_S$ 表示从 $S$ 状态开始, 都按最优策略选择可以让差值变化多少. 一开始我认为, 这个问题是对称的, 正如从左上角开始选择和从右下角开始舍弃是一样的, 但是这只是过程上的对称性, 但不是策略上的对称, 左上的格子和右下的格子是因果关系. 打个比方, 光学中说光路可逆, 但是光的传播是有方向的.

我选择一个格子, 它会影响之后我和对手的选择可能性或者说自由度, 所以在这一点上, 最优策略应当不是对称的. 为了证明我的结论, 我把样例旋转 $180^{\circ}$ 并且互换 $a$, $b$ 后, 喂给标程, 果然跑出了和我一开始的程序相同的结果 $\sum a - \sum b = 6$ (旋转互换后, 标称跑出来的是 $\sum b - \sum a = -6$, 本质相同).

因此便说明了这个题只有倒着跑才能过的合理性: 倒着转移不存在前驱状态不可能到达的情况, 因为前驱状态是否能到达是我这一步的决策决定的, 掌握在我自己手中, 而不是历史手中.

但是我懒得改代码了, 就利用了一波问题的对称性, 直接把输入的两个矩阵都旋转 $180^{\circ}$, 然后考虑最后一个格子是谁选的, 也就是格子数量奇偶性, 如果是偶数, 就交换 $a$, $b$. 然后直接跑一边一开始写的 DP, 最后输出答案时别忘了如果交换了 $a$, $b$, 得到的答案是 $\sum b - \sum a$, 需要取反.

状态数 $\binom{n + m}n$, 转移 $O(n + m)$, 复杂度是 $(n + m)\binom{n + m}n$.

```cpp
unordered_map <unsigned, unsigned> Find;
int a[15][15], b[15][15], f[200005];
unsigned List[200005], Step[200005];
unsigned m, n, nm, Bnm;
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
inline unsigned PpC(unsigned x) {
  unsigned PRt(0);
  for (;x;x -= Lbt(x)) ++PRt;
  return PRt;
}
inline void DFS(unsigned Now, unsigned Dep, unsigned Used) {
  if (Dep == nm) {
    if (Used == m) List[++Cnt] = Now, Find[Now] = Cnt;
    return;
  }
  if (Used > m) return;
  DFS(Now, Dep + 1, Used);
  DFS(Now | (1 << Dep), Dep + 1, Used + 1);
}
signed main() {
  n = RD(), m = RD(), Bnm = (1 << ((nm = n + m) - 1)) - 1;
  if ((n * m) & 1) {
    for (unsigned i(n); i; --i) for (unsigned j(m); j; --j) a[i][j] = RD();
    for (unsigned i(n); i; --i) for (unsigned j(m); j; --j) b[i][j] = RD();
  }
  else {
    for (unsigned i(n); i; --i) for (unsigned j(m); j; --j) b[i][j] = RD();
    for (unsigned i(n); i; --i) for (unsigned j(m); j; --j) a[i][j] = RD();
  }
  DFS(0, 0, 0);
  for (unsigned i(1); i <= Cnt; ++i) for (unsigned j(0), Thi(n); j < nm; ++j)
    if (List[i] & (1 << j)) Step[i] += Thi; else --Thi;
  for (unsigned i(2); i <= Cnt; ++i) {
    unsigned Now(List[i]), Need(((~Now) >> 1) & Now & Bnm);
    if (Step[i] & 1) {
      f[i] = 0xafafafaf;
      for (unsigned j(Need); j; j -= Lbt(j)) {
        unsigned Dest(Find[Now ^ (3 * Lbt(j))]);
        f[i] = max(f[i], f[Dest] + a[n - PpC((Lbt(j) - 1) & (~Now))][1 + PpC((Lbt(j) - 1) & Now)]);
      }
    }
    else {
      f[i] = 0x3f3f3f3f;
      for (unsigned j(Need); j; j -= Lbt(j)) {
        unsigned Dest(Find[Now ^ (3 * Lbt(j))]);
        f[i] = min(f[i], f[Dest] - b[n - PpC((Lbt(j) - 1) & (~Now))][1 + PpC((Lbt(j) - 1) & Now)]);
      }
    }
  }
  printf("%d\n", ((n * m) & 1) ? f[Cnt] : (-f[Cnt]));
  return Wild_Donkey;
}
```

## Day22: 模拟赛

### A

给一个数 $S$, 和一个序列 $a$, 每次可以选择一个数, 使得 $S$ 变成 $S + a_i$ 或 $Sa_i$, 每个数用一次, 求操作后 $S$ 最大值.

升序排序, 贪心, 一定有一个界, 使得在此之前都选 $S + a_i$, 之后都选 $Sa_i$. 而这个界限可以贪心地判断考虑到每个数字时 $S + a_i$ 和 $Sa_i$ 的大小.

由于 $S$ 和给出序列的长度两个范围看反了, 所以数组开小了, 而且没开 `long double`, 所以直接爆炸.

```cpp
unsigned m, n, Cnt(0), A, B, C, D, t;
long double Ans, a[100005];
inline void Clr() {}
int main() {
  scanf("%LF", &Ans), n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    scanf("%LF", &a[i]);
  }
  sort(a + 1, a + n + 1);
  for (register unsigned i(1); i <= n; ++i) {
    if(a[i] <= 1) {
      Ans += a[i]; 
      continue; 
    }
    if(a[i] * Ans > a[i] + Ans) {
      Ans *= a[i];
    } else {
      Ans += a[i]; 
    }
  }
  printf("%.9LF\n", Ans);
  return Wild_Donkey;
}
```

### B

题假了, 爆零人站起来了.

### C

先考虑只有两个值的情况, 容易想到贪心, 按 $a_i - b_i$ 升序排序, 前 $B$ 个都选 $b$, 后 $A$ 个都选 $a$.

首先想到了 DP, 状态 $f_{i, j, k}$ 表示前 $i$ 个物品, 已经选了 $j$ 个 $a$, $k$ 个 $b$, $i - j - k$ 个 $c$ 的最大收益.

$$
f_{i, j, k} = max(f_{i - 1, j - 1, k} + a_{i}, f_{i - 1, j, k - 1} + b_{i}, f_{i - 1, j, k} + c_{i})
$$

状态 $O(n^3)$, 转移 $O(1)$, 时间复杂度 $O(n^3)$, 滚动数组后空间复杂度 $O(n^2)$. 可以得到 $60'$.

```cpp
unsigned long long a[3][300005], f[5005][5005];
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
inline void Clr() {}
int main() {
  n = RD(), A = RD(), B = RD();// C = RD();
  for (register unsigned i(1); i <= n; ++i) {
    a[0][i] = RD(), a[1][i] = RD(), a[2][i] = RD();
  }
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned j(i - 1); j; --j) {
      f[j][i - j] = max(f[j - 1][i - j] + a[0][i], f[j][i - j - 1] + a[1][i]);
    }
    f[i][0] = f[i - 1][0] + a[0][i];
    f[0][i] = f[0][i - 1] + a[1][i];
    for (register unsigned j(i - 1); j; --j) {
      for (register unsigned k(i - j - 1); k; --k) {
        f[j][k] = max(max(f[j - 1][k] + a[0][i], f[j][k - 1] + a[1][i]), f[j][k] + a[2][i]);
      }
    }
    for (register unsigned j(i - 1); j; --j) {
      f[j][0] = max(f[j - 1][0] + a[0][i], f[j][0] + a[2][i]);
      f[0][j] = max(f[0][j - 1] + a[1][i], f[0][j] + a[2][i]);
    }
    f[0][0] = f[0][0] + a[2][i];
  }
  printf("%llu\n", f[A][B]);
  return Wild_Donkey;
}
```

能得 $60'$ 的算法还有费用流, 开三个点分别连向汇点免费的, 容量为 $A$, $B$, $C$ 的边. 然后从源点向每个物品连免费的容量为 $1$ 的边, 然后每个物品分别向 $A$, $B$, $C$ 点连接容量为 $1$, 费用分别是 $a_i$, $b_i$, $c_i$ 的边, 跑最大费用最大流即可.

接下来是正解:

如果有三个值, 仍先按 $a_i - b_i$ 升序排序, 假设已经把选 $c$ 的 $C$ 个物品删掉了, 这时剩下的 $A + B$ 个物品仍应该是前 $B$ 个选 $b$, 后 $A$ 个选 $a$. 因此在排好序的 $n$ 个物品的序列中, 一定存在一个分界线, 它左边除了 $b$ 就是 $c$, 它右边除了 $a$ 就是 $c$.

假设我们已经知道, 分界线是 $x$, 也就是说 $[1, x]$ 中, 有 $B$ 个选 $b$, $x - B$ 个选 $C$.

我们已经知道了只有两种选择的时候如何贪心, 直接选择 $x$ 个数中的前 $B$ 大的 $b_i - c_i$ 的物品选 $b$ 即可.

但是如果对于每个分界点都这样判断, 无疑是非常慢的, 定义两个数组, $f_i$ 和 $g_i$, 分别代表 $[1, i]$ 中前 $B$ 大的 $b_i - c_i$ 值之和, 和 $[i, n]$ 中前 $A$ 大的 $a_i - c_i$ 值之和. 到时候只要取 $f_{i} + g_{i + 1} + SumC$ 的最大值即可.

如何求 $f$ 和 $g$, $f$ 的下标范围是 $[B, n]$, 而 $f_{B}$ 显然是 $\displaystyle{\sum_{i = 1}^{i \leq B} b_i - c_i}$, 接下来的每个 $f_i$, 都是在上一个版本的基础上加入当前位置的 $b_i - c_i$. 然后删去最小值得到的总和, 每次弹出最小值可以用堆维护, $g$ 同理. 这样就可以 $O(n \log n)$ 求出 $f$ 和 $g$. 最后 $O(n)$ 扫描统计答案即可.

```cpp
struct Gift {
  unsigned V1, V2;
  inline const char operator<(const Gift &x) const{
    return (this->V1 + x.V2) > (x.V1 + this->V2);
  }
}G[300005];
unsigned V3[300005], m, n, Cnt(0), A, B, C, D, t;
unsigned long long Ans(0), f[300005], g[300005], Tmp;
priority_queue<unsigned, vector<unsigned>, greater<unsigned> > Q;
int main() {
  n = RD(), A = RD(), B = RD(); C = n - B;
  for (register unsigned i(1), Min; i <= n; ++i) {
    G[i].V1 = 1000000000 + RD(), G[i].V2 = 1000000000 + RD(), Ans += (V3[i] = RD());
    G[i].V1 -= V3[i], G[i].V2 -= V3[i];
  }
  sort(G + 1, G + n + 1), Ans -= (unsigned long long)1000000000 * (A + B);
  for (register unsigned i(1); i <= A; ++i) {
    Tmp = G[i].V1;
    Q.push(Tmp);
    f[i] = f[i - 1] + Tmp;
  }
  for (register unsigned i(A + 1); i <= n; ++i) {
    Tmp = G[i].V1;
    Q.push(Tmp);
    f[i] = f[i - 1] + Tmp - Q.top();
    Q.pop();
  }
  while (Q.size()) Q.pop();
  for (register unsigned i(n); i > C; --i) {
    Tmp = G[i].V2;
    Q.push(Tmp);
    g[i] = g[i + 1] + Tmp;
  }
  for (register unsigned i(C); i; --i) {
    Tmp = G[i].V2;
    Q.push(Tmp);
    g[i] = g[i + 1] + Tmp - Q.top();
    Q.pop();
  }
  Tmp = 0;
  for (register unsigned i(A); i <= C; ++i) {
    Tmp = max(Tmp, f[i] + g[i + 1]);
  }
  printf("%llu\n", Ans + Tmp);
  return Wild_Donkey;
}
```

### D

据说正解是矩阵乘法或可持久化平衡树, 但是我们不管这么多, 直接踩一下标算.

![1949.png](https://i.loli.net/2021/08/08/SbW3AhXH1gYJfdr.png)

开 $20$ 棵动态开点线段树, 通过交换和共用儿子来操作, 通过节点分裂保证每一行互不干扰, 复杂度 $O(m \log n)$.

```cpp
unsigned m, n, q, Cnt(0), A, P, B, C, D, t, Ans(0), Tmp(0);
const unsigned MOD(998244353);
inline void Clr() {}
struct Node {
  Node *LS, *RS;
  unsigned Val, Tag, Deg;
}*Root[25], N[50000005], *CntN(N);
inline void New(Node *x, Node *y) {
  x->Deg = 1;
  x->Val = y->Val;
  x->Tag = y->Tag;
  x->LS = y->LS;
  x->RS = y->RS;
  if(x->LS) ++(x->LS->Deg);
  if(x->RS) ++(x->RS->Deg);
  --(y->Deg);
}
inline void PsDw(Node *x, const unsigned Len) {
  if(!(x->LS)) x->LS = ++CntN, x->LS->Deg = 1;
  if(!(x->RS)) x->RS = ++CntN, x->RS->Deg = 1;
  if(x->LS->Deg > 1) {
    New(++CntN, x->LS);
    x->LS = CntN;
  }
  if(x->RS->Deg > 1) {
    New(++CntN, x->RS);
    x->RS = CntN;
  }
  if(x->Tag) {
    x->LS->Tag += x->Tag;
    if(x->LS->Tag >= MOD) x->LS->Tag -= MOD;
    x->LS->Val = ((unsigned long long)(x->Tag) * ((Len + 1) >> 1) + x->LS->Val) % MOD;
    x->RS->Tag += x->Tag;
    if(x->RS->Tag >= MOD) x->RS->Tag -= MOD;
    x->RS->Val = ((unsigned long long)(x->Tag) * (Len >> 1) + x->RS->Val) % MOD;
    x->Tag = 0;
  }
  return;
}
void Qry(Node *x, unsigned L, unsigned R) {
  if((B <= L) && (R <= C)) {
    Ans += x->Val;
    if(Ans >= MOD) Ans -= MOD;
    return;
  }
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  if(B <= Mid) {
    Qry(x->LS, L, Mid);
  }
  if(C > Mid) {
    Qry(x->RS, Mid + 1, R);
  }
  return;
}
void Chg(Node *x, unsigned L, unsigned R) {
  if((B <= L) && (R <= C)) {
    x->Tag += D;
    if(x->Tag >= MOD) x->Tag -= MOD;
    x->Val = (((unsigned long long)D * (R - L + 1)) + x->Val) % MOD;
    return;
  }
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  if(B <= Mid) {
    Chg(x->LS, L, Mid);
  }
  if(C > Mid) {
    Chg(x->RS, Mid + 1, R);
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  return;
}
void Swap(Node *x, Node *y, unsigned L, unsigned R) {
  if(L == R) return;
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  PsDw(y, R - L + 1);
  if(C <= Mid) {
    if((C <= L) && (Mid <= D)) {
      swap(x->LS, y->LS);
    } else {
      Swap(x->LS, y->LS, L, Mid);
    }
  }
  if(D > Mid) {
    if((C <= Mid + 1) && (R <= D)) {
      swap(x->RS, y->RS);
    } else {
      Swap(x->RS, y->RS, Mid + 1, R);
    }
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  y->Val = y->LS->Val + y->RS->Val;
  if(y->Val >= MOD) y->Val -= MOD;
  return;
}
void Copy(Node *x, Node *y, unsigned L, unsigned R) {
  if(L == R) return;
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  PsDw(y, R - L + 1);
  if(C <= Mid) {
    if((C <= L) && (Mid <= D)) {
      y->LS = x->LS;
      ++(y->LS->Deg);
    } else {
      Copy(x->LS, y->LS, L, Mid);
    }
  }
  if(D > Mid) {
    if((C <= Mid + 1) && (R <= D)) {
      y->RS = x->RS;
      ++(y->RS->Deg);
    } else {
      Copy(x->RS, y->RS, Mid + 1, R);
    }
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  y->Val = y->LS->Val + y->RS->Val;
  if(y->Val >= MOD) y->Val -= MOD;
  return;
}
int main() {
  n = RD(), m = RD(), q = RD();
  for (register unsigned i(1); i <= n; ++i) {
    Root[i] = ++CntN;
  }
  for (register unsigned i(1); i <= q; ++i) {
    A = RD(), P = RD(), B = RD(), C = RD();
    switch (A) {
      case (0) :{
        Ans = 0, Qry(Root[P], 1, m);
        printf("%u\n", Ans);
        break;
      }
      case (1) :{
        D = RD(), Chg(Root[P], 1, m);
        break;
      }
      case (2) :{
        D = RD();
        if(B == P) break;
        Swap(Root[P], Root[B], 1, m);
        break;
      }
      case (3) :{
        D = RD();
        if(B == P) break;
        Copy(Root[P], Root[B], 1, m);
        break;
      }
    }
  }
  return Wild_Donkey;
}
```

## Day23: 数位 DP

### [SCOI2009](https://www.luogu.com.cn/problem/P2657)

求区间 $[L, R]$ 的数中, 有多少是相邻数位的数字相差不超过 $2$ 的.

一般这种区间查询都用差分, 求出前 $L - 1$ 个数字和前 $R$ 个数字的答案, 求差即为答案. 设计状态 $f_{i, j, 0/1}$, 其中 $i$ 表示位置, $j$ 表示当前位的数, 第一个 $0/1$ 表示前 $i$ 位是否顶界.

$$
f_{i, j, 0} = f_{i - 1, a_{i - 1}, 1} * [|a_{i - 1} - j| \geq 2, j < a_{i}] + \sum_k^{|k - j| \geq 2} f_{i - 1, k, 0}\\
f_{i, j, 1} = f_{i - 1, a_{i - 1}, 1} * [|a_{i - 1} - j| \geq 2, j = a_{i}]
$$

```cpp
unsigned int a[10005], f[11][11][11], m, n, Cnt(0), A, B, C, D, t, La, Lb, Ansa(0), Ansb(0), Ans(0);
bool b[10005];
char s[10005];
inline void Clr() {
  n = RD();
  memset(a, 0, sizeof(a));
}
inline unsigned Getlen (unsigned x) {
  unsigned tmp(0);
  while(x) {
    x /= 10;
    ++tmp;
  }
  return tmp;
}
inline bool Jdg (const unsigned &x, const unsigned &y) {
  if (x < y) {
    return y - x > 1;
  }
  return x - y > 1;
}
void Qry (unsigned &ans, unsigned x, const unsigned &Len) {
  if(!x) {
    ans = 0;
    return;
  }
  unsigned now(x / Ten[Len - 1]), tmp(11);
  for (register unsigned i(1); i < Len; ++i) {//len
    for (register unsigned j(1); j < 10; ++j) {//begin
      for (register unsigned k(0); k < 10; ++k) {//end
        ans += f[i][j][k];//shorter
      }
    }
  }
  for (register unsigned i(Len); i >= 1; --i) {//len
    now = x / Ten[i - 1];//this number
    for (register unsigned j(i == Len ? 1 : 0); (i == 1 ? j <= now : j < now); ++j) {//begin
      if(Jdg(j, tmp)) {//last
        for (register unsigned k(0); k < 10; ++k) {//end
          ans += f[i][j][k];
        }
      }
    }
    if(!Jdg(now, tmp)) {
      break;
    }
    x -= Ten[i - 1] * now;
    tmp = now;//this num
  }
}
int main() {
  A = RD() - 1;
  La = Getlen(A);
  B = RD();
  Lb = Getlen(B);
  memset(f, 0, sizeof(f));
  for (register unsigned i(0); i < 10; ++i) {//begin & end
    f[1][i][i] = 1;
  }
  for (register unsigned i(2); i <= Lb; ++i) {//len
    for (register unsigned j(0); j < 10; ++j) {//begin
      for (register unsigned k(0); k < 10; ++k) {//end
        for (register unsigned i_(0); i_ < 10; ++i_) {//lastend
          if (Jdg(i_, k)) {
            f[i][j][k] += f[i - 1][j][i_];
          }
        }
      }
    }
  }
  Qry (Ansa, A, La);
  Qry (Ansb, B, Lb);
  printf("%u\n", Ansb - Ansa);
  return Wild_Donkey;
}
```

### [P4317](https://www.luogu.com.cn/problem/P4317)

设 $Count_i$ 表示 $i$ 二进制表示有多少 $1$, $Num_i$ 表示 $[1, n]$ 中 $Count = i$ 的数的数量, 问题转化为求 $\displaystyle{\prod_i i^{Num_i}}$.

设计状态 $f_{i, j, 0/1}$ 表示到第 $i$ 位, 二进制有 $j$ 个 $1$, 前 $i$ 位是否顶界的数的数量.

$$
f_{i, j, 0} = f_{i - 1, j, 0} + f_{i - 1, j - 1, 0} + f_{i - 1, j, 1} * [a_{i} = 1]\\
f_{i, j, 1} = f_{i - 1, j, 1} * [a_{i} = 0] + f_{i - 1, j - 1, 1} * [a_{i} = 1]\\
Num_i = f_{Len, i, 0} + f_{Len, i, 1}
$$

### [HNOI2002](https://www.luogu.com.cn/problem/P2235)

问题转化为求 $[1, m]$ 中的二进制回文数个数.

先判断 $m$ 是否为二进制回文数.

### [SCOI2013](https://www.luogu.com.cn/problem/P3281)

状态 $f_{i, j, 0/1}$ 表示到第 $i$ 位, 第 $i$ 位为 $j$, 是否顶界.

$$
f_{i, j, 0} = (f_{i - 1, a_{i - 1}, 1} * [j < a_{i}] + \sum_{k = 0}^{k < B}{f_{i - 1, k, 0}}) * B + j * (i)\\
f_{i, j, 1} = f_{i - 1, a_{i - 1}, 1} * [j = a_{i}] * B + j * (i)
$$

### 例题

求

$$
\sum_{i = l}^{r} \binom{a+i}{b}c^i \% p
$$

设 $a + i = A_0 + pA_1 + p^2A_2...$, $b = B_0 + pB_1 + p^2B_2...$

$$
\binom{a + i}{b} \equiv \prod_{j = 0} \binom{A_j}{B_j} \pmod p
$$

设 $i = C_0 + pC_1 + p^2C_2...$

$$
c^i \equiv \prod_{j = 0} c^{C_jp^j} \pmod p
$$

问题转化为:

$$
\sum_{i = l}^{r} (\prod_{j = 0} \binom{A_j}{B_j})(\prod_{j = 0} c^{C_j}) \% p
$$

预处理 $g_i = c^i \% p$.

状态 $f_{i, 0/1, 0/1}$, 表示到 $p$ 进制第 $i$ 位, 是否顶界, 是否. (转移的条件细节已省略)

$$
f_{i, 0/1, 0/1} = \sum_k f_{i - 1}{0/1'}{0/1'} * \binom{k}{B_i} * g_k
$$

### 集合幂级数

用一个幂级数表示一个集合的状态, 每一位存一个元素的状态.

### FMT

假设有一个各维度坐标为 $0/1$ 的高维超立方体, 求它顶点的前缀和.

一位一位地考虑, 每次将第 $j$ 位为 $1$ 的下标的元素加上它这一位异或 $1$ 得到的下标代表的元素.

一共是 $n$ 位, 下标范围 $2^n$, 复杂度 $O(n2^n)$.

这个求高维前缀和的过程称为 `FMT`.

### FWT

对一个多项式 $A$ 需要求 $A'$, 规则为:

$$
A'_i = \sum_{j = 0}^{j < 2^n} (-1)^{|i \cap j|} A_j
$$

类似地, 一位一位地考虑, 假设考虑到第 $i$ 位, $j$ 的第 $i$ 位为 $0$. 这时使得 $A_j$ 变成 $A_j + A_{j \oplus {1 << i}}$, $A_{j \oplus {1 << i}}$ 变成 $A_j - A_{j \oplus {1 << i}}$.

这样就能在同样的 $O(n2^n)$ 计算 FWT 了.

### 异或卷积

计算多项式 $C$ 使得

$$
C_i = \sum_{j, k = 0}^{j, k < 2^n} A_jB_k[j\oplus k = i]
$$



## Day24: 期望和概率 DP

### [NOIP2003](https://www.luogu.com.cn/problem/P1040)

中序遍历的一个区间就是一棵子树, 所以将树上问题转化为区间 DP.

$f_{i, j}$ 表示区间 $[i, j]$ 作为一棵子树的最大加分.

$$
f_{i, j} = \max(f_{i, k - 1} * f_{k + 1, j} + a_k)
$$

### [NOIP2008](https://www.luogu.com.cn/problem/P1006)

两条路径同时走, 状态 $f_{i, j, k}$ 表示走了 $i$ 步, 第一条路经走到 $(j, i + 2 - j)$, 第二条路经走到 $(k, i + 2 - k)$ 的最大总和.

$$
f_{i, j, k} = max(f_{i - 1, j, k}, f_{i - 1, j - 1, k}, f_{i - 1, j, k - 1}, f_{i - 1, j - 1, k - 1})
$$

$O(n^3)$ 状态, $O(1)$ 转移.

(这个题貌似费用流也可)

### [NOIP2010](https://www.luogu.com.cn/problem/P1514)

首先可以证明一个输水站覆盖的城市一定是一个连续的区间, 每个点 $(i, j)$ 维护一个左端点 $f_{i, j}$, 一个右端点 $g_{i, j}$, 表示它能覆盖的城市区间. 求出每个蓄水站的区间后, 贪心求解.

### [ZJOI2006](https://www.luogu.com.cn/problem/P2585)

节点 $i$ 存 $f_{i, 0/1/2}$ 表示当前节点选红/绿/蓝的最多绿色数量, $g_{i, 0/1/2}$ 存最少绿色数量.

对于叶子 $i$.

$$
g_{i, 0} = f_{i, 0} = 0\\
g_{i, 1} = f_{i, 1} = 1\\
g_{i, 2} = f_{i, 2} = 0
$$

对于只有一个儿子的节点 $i$.

$$
f_{i, 0} = max(f_{Son_i, 1}, f_{Son_i, 2})\\
f_{i, 1} = max(f_{Son_i, 0}, f_{Son_i, 2}) + 1\\
f_{i, 2} = max(f_{Son_i, 0}, f_{Son_i, 1})\\
g_{i, 0} = min(f_{Son_i, 1}, f_{Son_i, 2})\\
g_{i, 1} = min(f_{Son_i, 0}, f_{Son_i, 2}) + 1\\
g_{i, 2} = min(f_{Son_i, 0}, f_{Son_i, 1})
$$

对于有两个儿子的 $i$.

$$
f_{i, 0} = max(f_{LS_i, 1} + f_{RS_i, 2}, f_{RS_i, 1} + f_{LS_i, 2})\\
f_{i, 1} = max(f_{LS_i, 0} + f_{RS_i, 2}, f_{RS_i, 0} + f_{LS_i, 2}) + 1\\
f_{i, 2} = max(f_{LS_i, 0} + f_{RS_i, 1}, f_{RS_i, 0} + f_{LS_i, 1})\\
g_{i, 0} = min(f_{LS_i, 1} + f_{RS_i, 2}, f_{RS_i, 1} + f_{LS_i, 2})\\
g_{i, 1} = min(f_{LS_i, 0} + f_{RS_i, 2}, f_{RS_i, 0} + f_{LS_i, 2}) + 1\\
g_{i, 2} = min(f_{LS_i, 0} + f_{RS_i, 1}, f_{RS_i, 0} + f_{LS_i, 1})\\
$$

### [NOIP2016](https://www.luogu.com.cn/problem/P1850)

预处理全源最短路, 设计状态 $f_{i, j, 0/1}$, 表示考虑了 $i$ 节课, 申请了 $j$ 节课, $0/1$ 表示第 $i$ 节是否申请.

$$
f_{i, j, 0} = min(f_{i - 1, j, 0} + Dis_{c_{i - 1}, c_i}, f_{i - 1, j, 1} + (1 - k_{i - 1}) * Dis_{c_{i - 1}, c_i} + k_{i - 1} * Dis_{d_{i - 1}, c_i})\\
f_{i, j, 1} = min(f_{i - 1, j - 1, 0} + (1 - k_i) * Dis_{c_{i - 1}, c_i} + k_i * Dis_{c_{i - 1}, d_i},\\
f_{i - 1, j - 1, 1} + (1 - k_{i - 1})(1 - k_i) * Dis_{c_{i - 1}, c_i} + k_{i - 1}(1 - k_i) * Dis_{d_{i - 1}, c_i} +\\
(1 - k_{i - 1})k_i * Dis_{d_{i - 1}, c_i} + k_{i - 1}k_i * Dis_{d_{i - 1}, d_i})
$$

答案即为 $min(f_{n, m, 0}, f_{n, m, 1})$

### [NOIP2014](https://www.luogu.com.cn/problem/P1941)

设计状态 $f_{i, j}$ 为走到第 $i$ 列, 高度为 $j$ 的最少操作数.

$$
\begin{aligned}
f_{i, j} = min(f_{i - 1, j - kx} + k(k \geq 1, j - kx \in [L_{i - 1}, R_{i - 1}]),\\
f_{i - 1, j + y}(j + y \in [L_{i - 1}, R_{i - 1}]])~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&(j \in [L_i, R_i])\\
f_{i, j} = \infty~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&(j < L_i | j > R_i)
\end{aligned}
$$

$O(nm)$ 状态, $O(m)$ 转移. 时间复杂度 $O(nm^2)$, 空间复杂度 $O(nm)$.

用前缀和优化转移到 $O(1)$, 时间优化到 $O(nm)$ 滚动数组优化空间到 $O(m)$.

### [CSP2019](https://www.luogu.com.cn/problem/P5664)

合法方案数 = 总方案数 - 不合法方案数

如果不考虑 $\lfloor \frac n2 \rfloor$ 的限制, 总方案数很好求:

$$
(\prod_{i, j = 1}^{i \leq n, j \leq m} a_{i, j}) - 1
$$

接下来枚举出现次数 $> \lfloor \frac n2 \rfloor$ 的食材, 求出它的出现次数比 $\lfloor \frac n2 \rfloor$ 大的方案数.

假设现在需要求 $x$ 出现次数比 $\lfloor \frac n2 \rfloor$ 大的方案数, 设 $f_{i, j}$ 表示考虑 $i$ 个方法, 第 $x$ 种食材出现次数比其它的食材出现次数总和多 $j$ 的方案数.

$O(nm)$ 预处理 $g_{i} = \sum a_{i, j}$

f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} * a_{i, x} + f_{i - 1, j + 1} * (g_i - a_{i, x})
$$

注意第二维下标整体增加 $\frac n2$, 否则会出现负数下标.

状态 $O(n^2)$, 转移 $O(1)$, 做 $O(m)$ 次, 时间复杂度 $O(n^2m)$

### [COCI2019](https://www.luogu.com.cn/problem/P5307)

第一眼想到的是搜索, 每个点 $(i, j)$ 存 $f_{i, j, k}$, 表示这个点取 $k$ 为乘积的路径数, 这样需要开 $300*300*10^6$ 的数组, 这显然是开不下的.

发现不光可以正着搜索, 也可以倒着搜索, 从正向累乘变成反向除法, 为了证明这么做的正确性, 需要证明 $\lfloor \frac{ \lfloor \frac{n}{a} \rfloor}{b} \rfloor = \lfloor \frac{n}{ab} \rfloor$.

假设 $n = ak_1 + q_1$, $k_1 = bk_2 + q_2$.

所以 $n = a(bk_2 + q_2) + q_1 = abk_2 + aq_2 + q_1$. 因为 $q_2 < b$, 所以 $aq_2 \leq ab - a$, 又因为 $q_1 < a$, 所以 $aq_2 + q_1 < ab$. 

所以 $\lfloor \frac n{ab} \rfloor = k_2 = \lfloor \frac{ \lfloor \frac{n}{a} \rfloor}{b} \rfloor$

所以我只要连续做除法下取整, 得到 $O(\sqrt n)$ 种商, 就可以进行转移.

$$

### [HNOI2007](https://www.luogu.com.cn/problem/P3188)

将物品按 $b$ 排序, 从小到大考虑, 每次容量最多是 $O(a_in) \approx 1000$, 做 $0/1$ 背包.

每次 $b$ 增加, 将背包容量倍增, 数组下标除以 $2$, 丢弃零头.

因为每次做背包容量为 $1000$, 物品共 $100$ 种, 做 $30$ 次, 所以总复杂度约为 $10^7$.

### [NOI2020](https://www.luogu.com.cn/problem/P6775)

### [THUPC2021](https://loj.ac/p/6767)

### [THUPC2018](https://loj.ac/p/6395) 

## Day25: DP 优化

### [HNOI2008](https://www.luogu.com.cn/problem/P3195)

状态 $f_i$ 表示放前 $i$ 个的最小费用.

$$
f_i = min(f_j + (i - j - 1 + (\sum_{k = j + 1}^{i} C_k) - L)^2)
$$

计算前缀和 $Sum_i = \sum_{j = 1}^{i} C_j$

$$
f_i = min(f_j + (i - j - 1 + Sum_i - Sum_{j} - L)^2)
$$

设 $g_i = i + Sum_i$

$$
f_i = min(f_j + (g_i - g_j - 1 - L)^2)
$$

将方程变成函数:

$$
f_i = f_j + (g_i - g_j - 1 - L)^2\\
= f_j + ({g_i}^2 + {g_j}^2 + 1 + L^2 - 2g_jg_i  - 2g_i - 2g_iL + 2g_j + 2g_jL + 2L)\\
= f_j - 2g_jg_i + {g_i}^2 - 2g_i - 2g_iL + {g_j}^2 + 2g_j + 2g_jL + 1 + L^2 + 2L
$$

以 $g_j$ 为自变量, $f_j + {g_j}^2$ 为因变量, $- 1 - L^2 - 2L + f_i - {g_i}^2 + 2g_i + 2g_i$ 为截距, $2g_i - 2 - 2L$ 为斜率:

$$
f_i = f_j - 2g_jg_i + {g_i}^2 - 2g_i - 2g_iL + {g_j}^2 + 2g_j + 2g_jL + 1 + L^2 + 2L\\
f_j + {g_j}^2 = f_i + 2g_jg_i - {g_i}^2 + 2g_i + 2g_iL - 2g_j - 2g_jL - 1 - L^2 - 2L\\
f_j + {g_j}^2 = g_j(2g_i - 2 - 2L) - 1 - L^2 - 2L + f_i - {g_i}^2 + 2g_i + 2g_iL\\
$$

最小化截距以满足转移要求.

维护每个决策点 $(g_j, f_j + {g_j}^2)$ 的下凸包. 因为对于同一个 $i$, 斜率不变, 所以要想使得截距最小, 必须是凸包的下切线可以满足. 每次决策后尝试将自己 $(g_i, f_i + {g_i}^2)$ 加入凸包中.

### [NOI2007](https://www.luogu.com.cn/problem/P4027)

发现每次只要买入或卖出, 一定是梭哈.

每天只有三种情况: All in, All out 或什么都不做.

$f_i$ 表示第 $i$ 天得到的最大收益, 决策是枚举上一次手中是实体货币的日期.

$$
f_i = max(\frac {f_j}{\frac{1}{1 + Rate_j} * A_j + \frac{Rate_j}{1 + Rate_j} * B_j} * (\frac{1}{1 + Rate_j} * A_i + \frac{Rate_j}{1 + Rate_j} * B_i))\\
f_i = max(\frac {f_j}{\frac{A_j + Rate_j * B_j}{1 + Rate_j}} * \frac{A_i + Rate_j * B_i}{1 + Rate_j})\\
f_i = max(\frac {f_j}{A_j + Rate_j * B_j} * (A_i + Rate_j * B_i))\\
f_i = max(\frac {f_j * (A_i + Rate_j * B_i)}{A_j + Rate_j * B_j})\\
$$

转化为函数

$$
f_i = \frac {f_j * (A_i + Rate_j * B_i)}{A_j + Rate_j * B_j}\\
f_i = \frac {f_jA_i + f_jRate_jB_i}{A_j + Rate_j * B_j}\\
\frac{f_i}{B_i} = \frac {\frac{f_jA_i}{B_i} + f_jRate_j}{A_j + Rate_j * B_j}\\
$$

所以将  $\frac {f_j}{A_j + Rate_j * B_j}$ 作为自变量, $\frac {f_jRate_j}{A_j + Rate_j * B_j}$ 作为因变量, $-\frac{A_i}{B_i}$ 为斜率, $\frac{f_i}{B_i}$ 为截距的函数.

$$
\frac {f_jRate_j}{A_j + Rate_j * B_j} = - \frac {\frac{f_jA_i}{B_i}}{A_j + Rate_j * B_j} + \frac{f_i}{B_i}\\
\frac {f_jRate_j}{A_j + Rate_j * B_j} = - \frac {f_jA_i}{B_i(A_j + Rate_j * B_j)} + \frac{f_i}{B_i}\\
$$

这样只要维护凸包, 可以 $O(1)$ 查询 $j < i$ 的 $f_j$ 最大的 $j$, 每次用和以 $-\frac{A_i}{B_i}$ 为斜率的直线相切的切点做本次决策, 截距乘上 $B_i$ 即为所求 $f_i$, 然后再将 $(\frac {f_j}{A_j + Rate_j * B_j}, \frac {f_jRate_j}{A_j + Rate_j * B_j})$ 插入凸包.

由于需要支持随机插入和动态查询, 我们选择平衡树维护凸包.

### [HDU6800](https://acm.hdu.edu.cn/showproblem.php?pid=6800)

$f_{i, j}$ 表示计算了 $i$ 个点, 和第 $i$ 个点不是一个子序列的最后一个点是 $j$ 的最小距离和.

### 某题

部分确定的一个排列中填入剩余部分, 使得最长上升子序列最长.

仍然定义 $f_i$ 表示第 $i$ 个确定的位置为结尾的最长上升子序列的长度, $Cnt_i$ 表示第 $i$ 个确定的数前面未被确定的位置数量, $UnA_i$ 表示比 $i$ 小的未确定的数.

$$
f_{i} = \max_{j = 0}^{j < i}(f_{j} + min(Cnt_i - Cnt_j), UnA_{a_i} - UnA_{a_j})
$$


### [HAOI2018](https://www.luogu.com.cn/problem/P4491)


### [EPOI2018](https://www.luogu.com.cn/problem/P4383) 

转化为树上选 $k + 1$ 条不相交的链使得总收益最大.

发现可以树形 DP, 

### [IOI2000](https://www.luogu.com.cn/problem/P6246)

[原版](https://www.luogu.com.cn/blog/Wild-Donkey/luogu4767-ioi2000-you-ju)

加强版: 

### []()

求树上每个子树深度相同点对数.

长链剖分 + 启发式合并

### [NOIP2018](https://www.luogu.com.cn/problem/P5021)

### [CF1416E](https://www.luogu.com.cn/problem/CF1416E)

一开始设计 $f_{i, j}$ 表示枚举到 $a_i$, $b_{2i} = j$ 的时候, 合并后 $b$ 的最小长度.

$$
f_{i, j} = f_{i - 1, a_i - j} + 1, f_{i - 1, k})\\
f_{i, j}
$$

## Day26: ACM

### A

费用流, 竟然没看出来.



### B

由于每条路可以从任意位置调头, 所以只要在一条边上反复横跳就可以凑出任何长度, 所以下界形同虚设, 如果一条路径不合法, 任意地方迂回两步就凑够了.

所以只要保证在上界范围内, 走出去能回得来就行了, 所以一条边可以经过当且仅当它的一个端点到 $0$ 点的最短路比上界的一半要小即可.

对于使答案最大, 我们一定每次只探索一条边, 为了达到下界, 我们在起点附近迂回. 所以最后答案就是所有能到达的边数.

跑最短路即可, ACM 可以直接复制板子.

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[10005];
struct Edge;
struct Node {
  unsigned Dis;
  Edge *Fst;
  char InQue; 
}N[100005];
struct Edge {
  unsigned Val;
  Node *To;
  Edge *Nxt;
}E[400005], *CntE(E);
void Link(Node *x, Node *y) {
  (++CntE)->Nxt = x->Fst;
  x->Fst = CntE;
  CntE->To = y;
  CntE->Val = C;
}
struct Pnt{
  Node *P;
  unsigned Dist;
  const inline char operator <(const Pnt &x) const{
    return this->Dist > x.Dist;
  }
}TmpP;
priority_queue<Pnt> Q;
int main() {
  n = RD(), m = RD(), RD(), D = RD();
  for (register unsigned i(1); i <= m; ++i) {
    A = RD(), B = RD(), C = RD();
    Link(N + A, N + B);
    Link(N + B, N + A);
  }
  for (register unsigned i(1); i <= n; ++i) {
    N[i].Dis = 0x3f3f3f3f;
  }
  N[0].Dis = 0, TmpP.P = N, Q.push(TmpP);
  while (Q.size()) {
    register Node *Now((Q.top()).P); Q.pop();
    if(Now->InQue) continue;
    Now->InQue = 1;
    Edge *Sid(Now->Fst);
    while (Sid) {
      if(Sid->To->Dis > Now->Dis + Sid->Val) {
        Sid->To->Dis = Now->Dis + Sid->Val;
        TmpP.Dist = Sid->To->Dis, TmpP.P = Sid->To, Q.push(TmpP);
      }
      Sid = Sid->Nxt;
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if((min((E[i << 1].To)->Dis, (E[(i << 1) - 1].To)->Dis) << 1) < D) {
      ++Ans;
    }
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### C

最签到题, 给 $n$ 种需要的原料分别的需求量和持有量, 求一共能生产多少产品.

我们可以给每个原料持有量除以需求量下取整取最小值. 轻松写意又从容.

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0x3f3f3ff3), Tmp(0);
char b[10005];
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    A = RD(), B = RD();
    Ans = min(Ans, B/A);
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### D

构造二叉树, 编号满足大根堆性质, 求 $Q$ 为叶子的方案数.

根据容斥, $Q$ 为叶子方案数是总方案数减 $Q$ 不为叶子的方案数.

### E

赛时设计的 $O(n^3)$ 状态 $O(1)$ 转移的奇妙 DP, $f_{i, j, k}$ 表示前 $i$ 个音符, 击打 $j$ 个, 到 $i$ 为止连击 $k$ 次的最大收益.

但是非常遗憾, 它的状态复杂度就注定了没有前途.

而正解则是两维 $f_{i, j}$ 表示了考虑前 $i$ 个音符, 漏掉了 $j$ 个的最大收益. 转移 $O(n)$. 为了方便表示, 我们用 $g_{k, i}$ 预处理 $[k, i]$ 连击的收益.

$$
f_{i, j} = max(f_{k - 2, j - 1} + g_{k, i})
$$

但是很遗憾这还是 $O(n^3)$ 的复杂度.

达标得到这个 DP 满足四边形不等式, 可以决策单调性优化, 所以可以二分转移, 总复杂度 $O(n^2 \log n)$.

### F

给 $n$ 行字符串, 按每行出现的次数和出现顺序排序, 按顺序输出出现次数最大的 $m$ 个本质不同的行, 如果有相同出现次数的, 优先输出出现晚的. 如果本质不同的行不足 $m$ 个, 则按顺序输出全部.

复杂度 $O(wn \log n)$, 大概 $8 * 10^7$, 能过. (不过大水题写那么长确实非常丢脸)

```cpp
struct Str {
  char b[55];
  unsigned Rak;
  inline const char operator < (const Str &x) const {
    register char i(1);
    while ((this->b[i] == x.b[i]) && (this->b[i] > 20)) {
      ++i;
    }
    if(this->b[i] == x.b[i]) {
      return this->Rak < x.Rak;
    }
    return this->b[i] < x.b[i];
  }
  inline const char operator == (const Str &x) const {
    register char i(1);
    while (this->b[i] == x.b[i] && (this->b[i] > 20)) {
      ++i;
    }
    return this->b[i] == x.b[i];
  }
}S[100005];
struct Pos {
  unsigned P;
  inline const operator < (const Pos &x) const{
    return S[this->P].Rak > S[x.P].Rak;
  }
};
vector<Pos> V[100005];
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char Ch(0);
int main() {
  n = RD() * 3, m = RD();
  for (register unsigned i(1), j(0); i <= n; ++i) {
    j = 0;
    do {
      S[i].b[++j] = getchar();
    }while(S[i].b[j] > 20);
    S[i].Rak = i;
  }
  sort(S + 1, S + n + 1);
  Cnt = 1;
  for (register unsigned i(2); i <= n + 1; ++i) {
    register Pos O;
    if(S[i - 1] == S[i]) {
      ++Cnt;
    } else {
      O.P = i - 1;
      V[Cnt].push_back(O);
      Cnt = 1;
    }
  }
  for (register unsigned i(n); i; --i) {
    if(V[i].size()) {
      sort(V[i].begin(), V[i].end());
      if(V[i].size() <= m) {
        for (register unsigned j(0); j < V[i].size(); ++j) {
          printf("%s", (S[V[i][j].P].b) + 1);
        }
        m -= V[i].size();
      } else {
        for (register unsigned j(0); j < m; ++j) {
          printf("%s", (S[V[i][j].P].b) + 1);
        }
        m = 0;
      }
    }
    if(!m) break;
  }
  return Wild_Donkey;
}
```

### G

首先前置欧拉公式

$$
V - E + F = 1 + 连通块个数
$$

因为已经输入了 $V$, $E$, $F$ 所以可以求出连通块个数 $L$.

选择构造 $L - 1$ 个单点, 剩下 $V - L + 1$ 个点, $E$ 条边组成一个平面图.

$n$ 个点的平面图最多有 $3n - 6$ 条边, 需要构造 $V$ 个点, $E$ 条边的平面图.

构造方式是先取 $3$ 个点的平面图, 每次在外面加一个点, 往凸包上三个点连边.

由于 $V \geq 3$ 的边最多的平面图一定是三角形, 所以选一个棋盘内最大的三角形作为轮廓.

### H

这个题很容易想到二分, 但是判定一个二分的半径是否可行成了需要考虑的最大问题.

将两点之间不能走抽象为两点之间连边, 而连边的条件就是两点距离的一半小于等于二分的半径. 其意义不是通路, 而是防止经过的墙壁.

左边界和上边界可以抽象成一个点, 右边界和下边界也可以抽象成一个点. 那么从左上往右下走, 如果存在一条通路, 则这条通路已经将棋盘分割成左下和右上两个部分, 不能互相到达, 所以只要判断按照二分的距离连边, 左上右下两个点是否连通即可.

但是如果是二分 $10^6$ 并且得到 $10^{-5}$ 的精度, 最坏需要二分 $\log_2 10^{11}$ 次, 需要 $36$ 次, 而本题有 $1000$ 个点, 每次判定是 $O(n^2)$, 而 $3.6 * 10^7$ 的浮点数比较会比较悬.

我们发现答案一定是某一对点的距离, 因为如果不是两个点的距离, 那么对答案进行细微的扰动是不会影响任何边的连接情况的, 也就不会改变连通性. 所以我们只要将所有边权离散后二分所有存在的边权即可, 最劣次数是 $\log_2 10^6 = 20$ 次.

而判连通性也没必要提前连边, 我们只要在 DFS 过程中现判断一个点能否到达即可. 这就不至于每次判定会将 $O(n^2)$ 跑满了.

所以优化到带剪枝的 $O(n^2 \log n^2)$ 就可以稍微放心地提交了.

```cpp
float W, H, Pos[1005][2], Dist[1005][1005], Tmp[520005], Frtr;
unsigned a[1005][1005], m, n, Cnt(0), A, B, C, D, t, Ans(0);
char Vis[1005], Flg;
inline float Dis (unsigned x, unsigned y) {
  register float X(Pos[x][0] - Pos[y][0]), Y(Pos[x][1] - Pos[y][1]);
  return sqrt((X * X) + (Y * Y));
}
void DFS(unsigned x) {
  Vis[x] = 1;
  if(x == n + 1) {
    Flg = 1;
    return;
  }
  for (register unsigned i(0); i <= n + 1; ++i) {
    if((!(Vis[i])) && (Dist[x][i] <= Frtr)) {
      DFS(i);
    }
  }
  return;
}
int main() {
  scanf("%f%f", &W, &H);
  n = RD();
  Dist[0][0] = 10000000;
  for (register unsigned i(1); i <= n; ++i) {
    scanf("%f%f", &Pos[i][0], &Pos[i][1]);
    Dist[i][i] = 10000000;
    Dist[0][i] = Dist[i][0] = Tmp[++Cnt] = min(Pos[i][0], H - Pos[i][1]);
    Dist[n + 1][i] = Dist[i][n + 1] = Tmp[++Cnt] = min(Pos[i][1], W - Pos[i][0]);
  }
  Dist[n + 1][0] = Dist[0][n + 1] = 10000000;
  for (register unsigned i(2); i <= n; ++i) {
    for (register unsigned j(1); j < i; ++j) {
      Tmp[++Cnt] = Dist[i][j] = Dist[j][i] = Dis(j, i) / 2;
    }
  }
  sort(Tmp + 1, Tmp + Cnt + 1);
  Cnt = unique(Tmp + 1, Tmp + Cnt + 1) - Tmp - 1;
  register unsigned L(1), R(Cnt), Mid;
  while (L ^ R) {
    Mid = ((L + R) >> 1);
    Flg = 0;
    memset(Vis, 0, sizeof(Vis));
    Frtr = Tmp[Mid];
    DFS(0);
    if(Flg) {
      R = Mid;
    } else {
      L = Mid + 1;
    }
  }
  printf("%.6f\n", Tmp[L]);
  return Wild_Donkey;
}
```

但是我们仍然可以继续优化, 将所有边按连接权值从小到大排序, 利用类似 Kruskal 的方法每次连接最小的边, 然后判 $0$ 到 $n + 1$ 的连通性, 然后使用并查集维护连通性即可. 答案就是连通的时候最后加入的边权. 这样虽然时间仍然是 $O(n^2 \log n^2)$, 但是对于随机数据, `sort` 的期望复杂度往往更接近线性.

### I

是 Nim 游戏的板子, 每个横着的格子中间的空地可以看成是石子, 每个横着的格子看作一堆石子. (貌似可以证明, 但是我不会, 之后应该会有专门的博客来证吧)

这样就可以将所有长度 $-2$ 之后的值异或起来. 结果为 $0$ 则先手必败, 否则必胜, 因为先手总能将局面变成异或起来为 $0$ 的局面, 使得对手变成必败态.

令人难受的是, 场上推了 $2H$ 的式子和结论, 甚至打了好几把这个游戏, 如果最后不知道是 Nim 博弈, 我们都准备将这个游戏作为茶余饭后的消遣小游戏了...

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[10005];
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    Ans ^= RD() - 2;
  }
  scanf("%s", b + 1);
  if(Ans) Ans = 1;
  if(b[1] == 'W') {
    ++Ans;
  }
  printf((Ans & 1) ? "Blackking\n" : "Whiteking\n");
  return Wild_Donkey;
}
```

### J



### K

给两个矩阵, 按要求取反点, 使得第二个矩阵和第一个相同.

每个矩阵保证:

- 边界的一圈同色

- 联通的定义是四连通, 不存在 $\frac {*|.}{.|*}$ 或 $\frac {.|*}{*|.}$ 的情况

- 保证每个连通块最多只相邻两个连通块, 对于边界连通块, 仅相邻一个连通块

要求翻转过程中, 不出现连通块数量和相邻关系改变的情况, 任何时刻的矩阵都要满足输入的三个条件.

发现符合要求的局面一定是一个连通块套另一个连通块...以此类推.

所以可以使用 BFS 找出连通块和相邻关系, 这样就能很方便地判解的有无, 然后将其抽象为一个一圈一圈的图. 每圈代表一个连通块.

因为一个点可以反转多次, 所以不妨先将两个矩阵变换到理想的中间态, 然后将第一个矩阵的变换序列反转, 拼到第二个矩阵的序列后面就是答案.

而变换到中间态也很简单, 只要从外到内, 一格一格扩张到自己该到达的边界即可. (注意只扩展那些不会产生新连通块的格子)

### L

据说是稳定婚姻问题的裸题, 但是很遗憾没有翻译到.

### M

又是构造, 同样没翻译.

## Day27: 模拟赛

### A

给一个 DAG, 要求有序对 $(a, b)$ 使得存在一个 $c$, 既能到达 $a$, 又能到达 $b$. 数据保证点的编号就是拓扑序.

首先想到的是将所有入度为 $0$ 的点作为 $c$, 因为如果对于点对 $(a, b)$ 的 $c$, 能连向它的点一定也能做这个 $c$. 所以合法答案中所有点对的 $c$ 都可以是一个入度为 $0$ 的点.

将从某个 $c$ 出发能到达的所有点存到一个数组中, 然后 $O(n^2)$ 得到所有点对, 将对应的二维数组的位置置为 $1$.

$O(n)$ 个源点, 每个源点 $O(n^2)$ 扫描, 复杂度 $O(n^3)$.

`70'.cpp`

```cpp
unsigned List[3005], Hd(0), Tl(0), m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[3005][3005];
struct Edge;
struct Node {
  Edge *Fst;
  unsigned Deg, Topo, Vis, Size, Tms;
}N[3005];
struct Edge {
  Node *To;
  Edge *Nxt;
}E[3005];
unsigned DFS1 (Node *x) {
  List[++Cnt] = x - N;
  register Edge *Sid(x->Fst);
  if(!Sid) {
    return 1;
  }
  register unsigned TmSz(1);
  while (Sid) {
    if(!(Sid->To->Vis)) {
      Sid->To->Vis = 1;
      TmSz += DFS1(Sid->To);
    }
    Sid = Sid->Nxt;
  }
}
inline void Clr() {
  memset(b, 0, sizeof(b));
  memset(N, 0, sizeof(N));
  memset(E, 0, sizeof(E));
  Ans = 0;
}
int main() {
  t = RD();
  for (register unsigned T(1); T <= t; ++T){
    Clr();
    n = RD(), m = RD();
    for (register unsigned i(1); i <= m; ++i) {
      A = RD(), B = RD();
      E[i].Nxt = N[A].Fst;
      N[A].Fst = E + i;
      ++(N[B].Deg);
      E[i].To = N + B;
    }
    for (register unsigned i(1); i <= n; ++i) {
      if(!(N[i].Deg)) {
        Cnt = 0;
        DFS1(N + i);
        for (register unsigned j(1); j <= n; ++j) {
          N[j].Vis = 0;
        }
        for (register unsigned j(1); j <= Cnt; ++j) {
          b[List[j]][List[j]] = 1;
          for (register unsigned k(j + 1); k <= Cnt; ++k) {
            b[List[j]][List[k]] = b[List[k]][List[j]] = 1;
          }
        }
      }
    }
    for (register unsigned i(1); i <= n; ++i) {
      for (register unsigned j(1); j <= n; ++j) {
        Ans += b[i][j];
      }
    }
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

正解考虑 DP, 发现有一个条件还没使用, 就是点的拓扑序是编号. 设布尔变量 $f_{i, j}$ 表示 $(i, j)$ 点对合法.

接下来枚举 $i$, $j$ 转移即可, 因为只要 $(i, j)$ 合法, 那么对于任何 $i$ 能到达的 $i'$, $j$ 能到达的 $j'$, 都有 $(i', j')$ 合法.

所以按拓扑序转移即可. 复杂度 $O(n(n + m))$.

```cpp
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0);
char f[3005][3005];
struct Edge {
  unsigned To;
  Edge *Nxt;
}E[3005], *Fst[3005];
inline void Clr() {
  memset(f, 0, sizeof(f));
  memset(Fst, 0, sizeof(Fst));
  Ans = 0;
}
int main() {
  t = RD();
  for (register unsigned T(1); T <= t; ++T){
    Clr();
    n = RD(), m = RD();
    for (register unsigned i(1); i <= m; ++i) {
      A = RD(), B = RD();
      E[i].Nxt = Fst[A];
      Fst[A] = E + i;
      E[i].To = B;
    }
    for (register unsigned i(1); i <= n; ++i) {
      f[i][i] = 1;
      for (register unsigned j(1); j <= n; ++j) {
        if(f[i][j]) {
          ++Ans;
          register Edge *Sid(Fst[j]);
          register unsigned Son;
          while (Sid) {
            Son = Sid->To;
            f[i][Son] = f[Son][i] = f[j][Son] = f[Son][j] = 1; 
            Sid = Sid->Nxt;
          }
        }
      }
    }
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

### B

每个物品可以放到 $a_i$ 筐中, 也能放到 $b_i$ 筐中. 求如何使得筐中有奇数物品的筐最小.

每个筐看作一个点, 每个物品当作一条边, 连接 $a_i$, $b_i$. 对于一个连通块, 我们尝试将有端点相同的节点配对然后同时删除, 意义是将两个物品同时放入一个筐中, 发现存在策略使得连通块最后只剩 $0$ 或 $1$ 条边.

删边策略是: 以任意点为根生成一棵 DFS 树, 这棵树存在三种边, 树边, 自环边, 回边 (树边如果有重边, 则除了第一次经过的树边, 其余算作回边), 从叶子开始考虑. 对于一个叶子, 如果它的自环边和回边数量是偶数, 就直接将自环边和回边删除, 否则删除的同时还要带上连接父亲的边. 考虑完叶子回溯到它的父亲 $x$, 这时 $x$ 可能连着 $4$ 种边, 连接 $x$ 的父亲的树边, 连接 $x$ 的儿子的树边, 回边, 自环边. 因为这时如果还有儿子边, 儿子就只剩一个单点了, 讨论后三种边的数量, 如果是偶数就直接删除, 如果是奇数就带上连接父亲的树边. 这样每次讨论一个点就必定删除偶数条边, 到了根, 如果出现了需要带上连接父亲边的情况, 这时删除偶数条边后, 会剩下一条. 

这种只剩一条边的情况出现, 唯一的条件是连通块的总边数是奇数. 所以我们只要统计每个连通块的边数 $\And 1$ 的总和即可.

```cpp
unsigned m, n, Cnt(0), A, B, Ans(0);
struct Edge;
struct Node {
  Edge *Fst;
  char Vis; 
}N[200005];
struct Edge {
  Node *To;
  Edge *Nxt;
}E[400005], *CntE(E);
void Link(Node *x, Node *y) {
  (++CntE)->Nxt = x->Fst;
  x->Fst = CntE;
  CntE->To = y;
}
void DFS(Node *x) {
  x->Vis = 1;
  register Edge *Sid(x->Fst);
  while (Sid) {
    ++Cnt;
    if(!(Sid->To->Vis)) {
      DFS(Sid->To);
    }
    Sid = Sid->Nxt;
  }
}
int main() {
  n = RD(), m = RD();
  for (register unsigned i(1); i <= n; ++i) {
    A = RD(), B = RD();
    Link(N + A, N + B);
    Link(N + B, N + A);
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!N[i].Vis) {
      Cnt = 0;
      DFS(N + i);
      Ans += ((Cnt >> 1) & 1);
    }
  }
  printf("%u\n", Ans);
}
```

与此同时, 不建图, 仅用并查集维护连通块, 貌似可以得到更优的常数.

### C

$f_{a_1, a_2, a_3, a_4}$ 代表已经选了 $a_1$ 个 $2$, $a_2$ 个 $3$, $a_3$ 个 $4$, $a_4$ 个 $5$ 的最少纸币.

我们知道对于 $f_{a_1, a_2, a_3, a_4}$ 的答案中, 前 $a_1 + a_2 + a_3 + a_4$ 种纸币凑出了 $n \% (2^{a_1}3^{a_2}4^{a_3}5^{a_4})$ 的钱, 剩下的钱用 $\frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4}}$ 张第 $a_1 + a_2 + a_3 + a_4 + 1$ 种纸币凑出.

转移要枚举本次选哪个数, 然后转移即可.

$$
\begin{aligned}
&f_{a_1, a_2, a_3, a_4} = min(\\
&f_{a_1 - 1, a_2, a_3, a_4} - \frac{n}{2^{a_1 - 1}3^{a_2}4^{a_3}5^{a_4}} + \frac{n}{2^{a_1 - 1}3^{a_2}4^{a_3}5^{a_4}} \% 2,\\
&f_{a_1, a_2 - 1, a_3, a_4} - \frac{n}{2^{a_1}3^{a_2 - 1}4^{a_3}5^{a_4}} + \frac{n}{2^{a_1}3^{a_2 - 1}4^{a_3}5^{a_4}} \% 3,\\
&f_{a_1, a_2, a_3 - 1, a_4} - \frac{n}{2^{a_1}3^{a_2}4^{a_3 - 1}5^{a_4}} + \frac{n}{2^{a_1}3^{a_2}4^{a_3 - 1}5^{a_4}} \% 4,\\
&f_{a_1, a_2, a_3, a_4 - 1} - \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4 - 1}} + \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4 - 1}} \% 5\\
&) + \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4}}
\end{aligned}
$$

但是细节有亿点点多, 所以有了这般地狱绘图:

```cpp
unsigned long long g[70][70][70][70], f[70][70][70][70];
unsigned long long m, Ans(0x3f3f3f3f3f3f3f3f), Tmp;
int main() {
  g[0][0][0][0] = RD(), m = RD() - 1;
  for (register unsigned i(1); i <= m; ++i) {
    g[i][0][0][0] = g[i - 1][0][0][0] / 2;
    g[0][i][0][0] = g[0][i - 1][0][0] / 3;
    g[0][0][i][0] = g[0][0][i - 1][0] / 4;
    g[0][0][0][i] = g[0][0][0][i - 1] / 5;
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      g[i][j][0][0] = g[i][j - 1][0][0] / 3;
      g[i][0][j][0] = g[i][0][j - 1][0] / 4;
      g[i][0][0][j] = g[i][0][0][j - 1] / 5;
      g[0][i][j][0] = g[0][i][j - 1][0] / 4;
      g[0][i][0][j] = g[0][i][0][j - 1] / 5;
      g[0][0][i][j] = g[0][0][i][j - 1] / 5;
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        g[i][j][k][0] = g[i][j][k - 1][0] / 4;
        g[i][j][0][k] = g[i][j][0][k - 1] / 5;
        g[i][0][j][k] = g[i][0][j][k - 1] / 5;
        g[0][i][j][k] = g[0][i][j][k - 1] / 5;
        if(!g[i][j][k][0]) break;
        for (register unsigned l(1); l + k + j + i <= m; ++l) {
          g[i][j][k][l] = g[i][j][k][l - 1] / 5;
          if(!g[i][j][k][l]) break;
        }
      }
    }
  }
  memset(f, 0x3f, sizeof(f));
  f[0][0][0][0] = g[0][0][0][0];
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    f[i][0][0][0] = min(f[i][0][0][0], f[i - 1][0][0][0] - g[i - 1][0][0][0] + g[i - 1][0][0][0] % 2 + g[i][0][0][0]);
    f[0][i][0][0] = min(f[0][i][0][0], f[0][i - 1][0][0] - g[0][i - 1][0][0] + g[0][i - 1][0][0] % 3 + g[0][i][0][0]);
    f[0][0][i][0] = min(f[0][0][i][0], f[0][0][i - 1][0] - g[0][0][i - 1][0] + g[0][0][i - 1][0] % 4 + g[0][0][i][0]);
    f[0][0][0][i] = min(f[0][0][0][i], f[0][0][0][i - 1] - g[0][0][0][i - 1] + g[0][0][0][i - 1] % 5 + g[0][0][0][i]);
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      f[i][j][0][0] = min(f[i][j][0][0], f[i][j - 1][0][0] - g[i][j - 1][0][0] + g[i][j - 1][0][0] % 3 + g[i][j][0][0]);
      f[i][j][0][0] = min(f[i][j][0][0], f[i - 1][j][0][0] - g[i - 1][j][0][0] + g[i - 1][j][0][0] % 2 + g[i][j][0][0]);
      f[i][0][j][0] = min(f[i][0][j][0], f[i][0][j - 1][0] - g[i][0][j - 1][0] + g[i][0][j - 1][0] % 4 + g[i][0][j][0]);
      f[i][0][j][0] = min(f[i][0][j][0], f[i - 1][0][j][0] - g[i - 1][0][j][0] + g[i - 1][0][j][0] % 2 + g[i][0][j][0]);
      f[i][0][0][j] = min(f[i][0][0][j], f[i][0][0][j - 1] - g[i][0][0][j - 1] + g[i][0][0][j - 1] % 5 + g[i][0][0][j]);
      f[i][0][0][j] = min(f[i][0][0][j], f[i - 1][0][0][j] - g[i - 1][0][0][j] + g[i - 1][0][0][j] % 2 + g[i][0][0][j]);
      f[0][i][j][0] = min(f[0][i][j][0], f[0][i][j - 1][0] - g[0][i][j - 1][0] + g[0][i][j - 1][0] % 4 + g[0][i][j][0]);
      f[0][i][j][0] = min(f[0][i][j][0], f[0][i - 1][j][0] - g[0][i - 1][j][0] + g[0][i - 1][j][0] % 3 + g[0][i][j][0]);
      f[0][i][0][j] = min(f[0][i][0][j], f[0][i][0][j - 1] - g[0][i][0][j - 1] + g[0][i][0][j - 1] % 5 + g[0][i][0][j]);
      f[0][i][0][j] = min(f[0][i][0][j], f[0][i - 1][0][j] - g[0][i - 1][0][j] + g[0][i - 1][0][j] % 3 + g[0][i][0][j]);
      f[0][0][i][j] = min(f[0][0][i][j], f[0][0][i][j - 1] - g[0][0][i][j - 1] + g[0][0][i][j - 1] % 5 + g[0][0][i][j]);
      f[0][0][i][j] = min(f[0][0][i][j], f[0][0][i - 1][j] - g[0][0][i - 1][j] + g[0][0][i - 1][j] % 4 + g[0][0][i][j]);
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        f[i][j][k][0] = min(f[i][j][k][0], f[i][j][k - 1][0] - g[i][j][k - 1][0] + g[i][j][k - 1][0] % 4 + g[i][j][k][0]);
        f[i][j][k][0] = min(f[i][j][k][0], f[i][j - 1][k][0] - g[i][j - 1][k][0] + g[i][j - 1][k][0] % 3 + g[i][j][k][0]);
        f[i][j][k][0] = min(f[i][j][k][0], f[i - 1][j][k][0] - g[i - 1][j][k][0] + g[i - 1][j][k][0] % 2 + g[i][j][k][0]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i][j][0][k - 1] - g[i][j][0][k - 1] + g[i][j][0][k - 1] % 5 + g[i][j][0][k]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i][j - 1][0][k] - g[i][j - 1][0][k] + g[i][j - 1][0][k] % 3 + g[i][j][0][k]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i - 1][j][0][k] - g[i - 1][j][0][k] + g[i - 1][j][0][k] % 2 + g[i][j][0][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i][0][j][k - 1] - g[i][0][j][k - 1] + g[i][0][j][k - 1] % 5 + g[i][0][j][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i][0][j - 1][k] - g[i][0][j - 1][k] + g[i][0][j - 1][k] % 4 + g[i][0][j][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i - 1][0][j][k] - g[i - 1][0][j][k] + g[i - 1][0][j][k] % 2 + g[i][0][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i][j][k - 1] - g[0][i][j][k - 1] + g[0][i][j][k - 1] % 5 + g[0][i][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i][j - 1][k] - g[0][i][j - 1][k] + g[0][i][j - 1][k] % 4 + g[0][i][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i - 1][j][k] - g[0][i - 1][j][k] + g[0][i - 1][j][k] % 3 + g[0][i][j][k]);
      }
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        for (register unsigned l(1); l + k + j + i <= m; ++l) {
          if(!g[i][j][k][l]) break;
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j][k][l - 1] - g[i][j][k][l - 1] + g[i][j][k][l - 1] % 5 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j][k - 1][l] - g[i][j][k - 1][l] + g[i][j][k - 1][l] % 4 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j - 1][k][l] - g[i][j - 1][k][l] + g[i][j - 1][k][l] % 3 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i - 1][j][k][l] - g[i - 1][j][k][l] + g[i - 1][j][k][l] % 2 + g[i][j][k][l]);
        }
      }
    }
  }
  for (register unsigned i(0); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(0); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(0); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        for (register unsigned l(0); l + k + j + i <= m; ++l) {
          if(!g[i][j][k][l]) break;
          Ans = min(Ans, f[i][j][k][l]);
        }
      }
    }
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

但是因为不满冗长的预处理和奇妙的转移, 改变转移的顺序, 让代码变成这副模样, 成功将常数压缩 $6$ 倍.

```cpp
unsigned long long f[70][40][35][30], m, n, Ans(0x3f3f3f3f3f3f3f3f);
int main() {
  n = RD(), m = RD() - 1;
  memset(f, 0x3f, sizeof(f));
  f[0][0][0][0] = n;
  for (register unsigned long long i(0), Gi(n); (i <= m) && (Gi); ++i) {
    for (register unsigned long long j(0), Gj(Gi); (j + i <= m) && (Gj); ++j) {
      for (register unsigned long long k(0), Gk(Gj); (k + j + i <= m) && (Gk); ++k) {
        for (register unsigned long long l(0), Gl(Gk); (l + k + j + i <= m) && (Gl); ++l) {
          Ans = min(Ans, f[i][j][k][l]);
          f[i + 1][j][k][l] = min(f[i + 1][j][k][l], f[i][j][k][l] - (Gl >> 1));
          f[i][j + 1][k][l] = min(f[i][j + 1][k][l], f[i][j][k][l] - ((Gl / 3) << 1));
          f[i][j][k + 1][l] = min(f[i][j][k + 1][l], f[i][j][k][l] - (Gl >> 2) * 3);
          f[i][j][k][l + 1] = min(f[i][j][k][l + 1], f[i][j][k][l] - ((Gl / 5) << 2));
          Gl /= 5;
        }
        Gk >>= 2;
      }
      Gj /= 3;
    }
    Gi >>= 1;
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

### D

场上写的是 $O({n^2}^{n^2})$ 的巨大爆搜, 

## Day28: 基础数论

### 欧拉函数

设 $p_i$ 为一个质数, $\displaystyle{x = \prod_{i}^{a_i > 0} {p_i}^{a_i}}$, 则欧拉函数可以表示为:

$$
\phi(x) = \frac{x}{\displaystyle{\prod_{i}^{a_i > 0}(p_i - 1)}}
$$

$\phi$ 是积性函数, 因为对于互质的 $x$ 和 $y$, 它们没有公共质因数, 所以有:

$$
\begin{aligned}
&~~~~~~\phi(x)\phi(y)\\
& = \frac{x}{\displaystyle{\prod_{i}^{a_i > 0}(p_i - 1)}} \times \frac{y}{\displaystyle{\prod_{i}^{b_i > 0}(p_i - 1)}}\\
& = \frac{xy}{\displaystyle{\prod_{i}^{a_i > 0 \lor b_i > 0}(p_i - 1)}}\\
& = \phi(xy)
\end{aligned}
$$

### 欧拉定理

对于互质的 $a$, $p$, 有:

$$
a^{\phi(p)} \% p = 1
$$

所以就有:

$$
a^{b} \% p = a^{b \% \phi(p)} % p
$$

### 扩展欧拉定理

对于 $a$, $p$ 不互质的情况:

$$
\begin{aligned}
a^b \% p = a^{b \% \phi(p)} \% p~~~~~&(gcd_{a, p} = 1)\\
a^b \% p = a^b \% p~~~~~&(gcd_{a, p} \neq 1, b < \phi(p))\\
a^b \% p = a^{b \% \phi(p) + \phi(p)}\% p~~~~~&(gcd_{a, p} \neq 1, b \geq \phi(p))
\end{aligned}
$$

### 埃氏筛

扫描正整数, 一个数没有被筛过, 则它是质数, 对于每一个质数, 筛出它的所有倍数. 时间复杂度 $O(n\log(\log n))$.

### 欧拉筛

仍然扫描, 但是一个质数 $p$ 筛别的数的时候, 如果 $p$ 不是待筛的数的最大质因子, 则停止. 这样可以保证一个数仅被筛掉一次, 也就是被它的最大质因数筛掉.

为了在 $p$ 不是最大质因数的时候跳出, 当和 $p$ 相乘的因数能被 $p$ 整除的时候跳出即可.

### 求 $\binom {n}{m}$ 中 $p$ 的幂次

分别求 $n!$, $m!$ 和 $(n - m)!$ 中 $p$ 的幂次, 然后做减法即可.

如何求阶乘的幂次, 用 $n$ 不断除以 $p$, 则 $n!$ 中 $p$ 的幂次可以表示为:

$$
\sum_{i \geq 1} \lfloor \frac {n}{p^i} \rfloor
$$

所以答案就是

$$
\sum_{i \geq 1} (\lfloor \frac {n}{p^i} \rfloor - \lfloor \frac {m}{p^i} \rfloor - \lfloor \frac {n - m}{p^i} \rfloor)
$$

尝试发现 $p$ 的幂次的新意义.


$$
\begin{aligned}
m &= a_1p^i + r_1~(r_1 < p^i)\\
n - m &= a_2p^i + r_2~(r_2 < p^i)\\
n &= (a_1 + a_2)p^i + r_1 + r_2\\
n &= a_3p^i + r_3\\
r_3 &= (r_1 + r_2) \% p^i\\
a_3 &= a_1 + a_2 + \lfloor \frac {r_1 + r_2}{p^i} \rfloor
\end{aligned}
$$

发现这就是 $m$ 和 $n - m$ 在 $p$ 进制加法中的进位次数.

### BSGS

求满足 $a^x \equiv b \pmod p$ 的最小自然数 $x$.

首先将 $b$ 变成 $b \% p$.

先假设 $a$ 和 $p$ 互质.

设 $Sq = \lceil \sqrt p \rceil$, 将 $a$ 分解成 $kSq + r$.

因为 $a^x \equiv a^{x \% \phi(p)}$,  所以 $x < p$, 所以 $k, r \leq Sq$.

原来的式子变成:

$$
\begin{aligned}
a^x &\equiv b \pmod p\\
a^{kSq + r} &\equiv b \pmod p\\
a^{kSq} &\equiv bInv_{a^{r}} \pmod p\
\end{aligned}
$$

处理出对于所有 $r \leq Sq$ 的 $BInv_{a^{r}}$, 存入 `map`, 然后枚举 $k$, 在 `map` 中查询 $a^{kSq}$, 如果存在, 那么就找到一个特解 $x$.

接下来将解最小化.

这时只要将 $x$ 变成 $x \% \phi(p)$ 即可.

然后考虑 $a$, $p$ 不互质的情况, 因为这时可能不存在 $Inv_{a^r}$. 记 $\gcd(a, p) = g$.

首先判有解, 有解当且仅当 $g|b$. 将方程转化为 $\frac {a}{g} a^{x - 1} \equiv \frac {b}{g} \pmod {\frac {p}{g}}$

如果这时 $a$ 和 $\frac{p}{g}$ 仍不互质, 仍然同时除以 gcd. 直到 $a$ 和 $p$ 互质位置这时方程会变成:

$$
\frac {a^{x}}{\displaystyle{\prod_{i}g_i}} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
\frac {a^{k}}{\displaystyle{\prod_{i}g_i}} a^{x - k} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
a^{x - k} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} Inv_{\frac {a^{k}}{\displaystyle{\prod_{i}g_i}}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
$$

这时 $a$ 和 $\frac {p}{\displaystyle{\prod_{i}g_i}}$ 互质, 则将 $\frac {b}{\displaystyle{\prod_{i}g_i}} Inv_{\frac {a^{k}}{\displaystyle{\prod_{i}g_i}}}$ 作为新的 $b$, $\frac {p}{\displaystyle{\prod_{i}g_i}}$ 作为新的 $p$, 做一次正常 BSGS 即可. 答案就是正常 BSGS 答案 $+ k$ 即可.

### 原根

一个数 $p$ 的原根 $x$ 需要满足 $x^0 \% p$, $x^1 \% p$, $x^2 \% p$, ..., $x^{p - 1} \% p$ 遍历了 $[0, p)$ 的所有整数.

一个数可以有多个原根.

### 莫比乌斯函数

仍设 $x = \prod_i p_i^{a_i}$

$$
\mu(x) =
\begin{cases} 
-1^{\sum a_i},  & (\forall a_i \leq 1)\\
0, & (\exists a_i \geq 2)
\end{cases}
$$

### 迪利克雷卷积

$$
f(i) = \sum_{j|i} a_jb_{\frac ij}
$$

假设将每一项都是 $1$ 的函数记为 $1$, 有结论 $1 * \mu = \epsilon$. $\epsilon$ 是迪利克雷卷积的单位元, 也就是说什么东西卷 $\epsilon$ 都是它本身. $\epsilon(1) = 1, \epsilon (i > 1) = 0$

迪利克雷卷积满足乘法交换律, 结合律, 分配律.

尝试构造 $f(x)$ 的迪利克雷卷积逆元 $g(x)$.

$$
g(x) = \frac{\epsilon(x) - \displaystyle{\sum_{d|x, d \neq 1} f(d)g(\frac xd)}}{f(1)}
$$

这时对于 $h = f * g$, 有:

$$
\begin{aligned}
h(1) &= g(1)f(1)\\
&= \epsilon(1) - \displaystyle{\sum_{d|1, d \neq 1} f(d)g(\frac 1d)}\\
&= \epsilon(1)\\
&= 1\\
\end{aligned}
$$

$$
\begin{aligned}
h(x) &= \sum_{i|x} g(i)f(\frac{x}{i})\\
&= \sum_{i|x} \frac{\epsilon(i) - \displaystyle{\sum_{d|i, d \neq 1} f(d)g(\frac id)}}{f(1)} \times f(\frac{x}{i})\\
\end{aligned}
$$

### 莫比乌斯反演

常用来判断 $[x = 1]$, 因为对于 $\sum_{d|x} \mu (d)$

$$
\begin{aligned}
f_n &= \sum_{d|n} \mu (d)\\
\end{aligned}
$$

### [P1516](https://www.luogu.com.cn/problem/P1516)

对 $n$, $m$, 求满足 $a + xn \equiv b + xm \pmod {p}$ 的最小的 $x$.

$$
\begin{aligned}
a + xn &\equiv b + xm \pmod {p}\\
x(n - m) &\equiv b - a \pmod {p}\\
x(n - m) &= b - a + kp\\
x(n - m) - k  p &= b - a
\end{aligned}
$$

用 Exgcd 求出 $x$ 即可.

### [NOI2010](https://www.luogu.com.cn/problem/P1447)

将问题转化为求下式的值:

$$
\sum_{i = 1}^{i \leq n}\sum_{j = 1}^{j \leq m} (2\gcd(i, j) - 1) 
$$

然后转化为枚举 $gcd$:

$$
\begin{aligned}
&\sum_{d = 1}\sum_{i = 1}^{i \leq n}\sum_{j = 1}^{j \leq m} (2d - 1)[\gcd(i, j) = d]\\
=&\sum_{d = 1}\sum_{i = 1}^{i \leq \frac{n}{d}}\sum_{j = 1}^{j \leq \frac{m}{d}} (2d - 1)[gcd(i, j) = 1]\\
=&2(\sum_{d = 1}\sum_{i = 1}^{i \leq \frac{n}{d}}\sum_{j = 1}^{j \leq \frac{m}{d}} d[gcd(i, j) = 1]) - 1\\
\end{aligned}
$$

### [POI2007](https://www.luogu.com.cn/problem/P3455)

将 $a$, $b$ 同时除以 $d$, 转化为求 $a$, $b$ 以内所有互质的数的个数, 对于每个数求 $\phi$

### [P1829](https://www.luogu.com.cn/problem/P1829)

### [SDOI2015](https://www.luogu.com.cn/problem/P3327)

定义 $d(x)$ 表示 $x$ 的约数个数, 给定 $n$, $m$, 求:

$$
\sum_{i = 1}^{n} \sum_{j = 1}^{m} d(ij)
$$

### 生成函数

???

## Day29: 线性代数

### 向量

对于 $(x_0, y_0)$ 和 $(x_1, y_1)$, 其点乘结果为 $x_0x_1 + y_0y_1$, 叉乘结果为 $x_0y_1 - x_1y_0$, 其绝对值是两个向量决定的平行四边形面积.

任意 $n$ 维向量 $(a_0, a_1, a_2,...,a_{n - 1})$, $(b_0, b_1, b_2,...,b_{n - 1})$, 其点乘定义为 $\prod_{i = 0}^{n - 1} a_i + \prod_{i = 0}^{n - 1} b_i$.

对于三维向量 $(x_0, y_0, z_0)$, $(x_1, y_1, z_1)$, 其叉乘定义为两个向量所在平面的法向量. 即为 $(y_0z_1 - z_0y_1, z_0x_1 - x_0z_1, x_0y_1 - x_1y_0)$

### 矩阵乘法

矩阵乘法的单位矩阵 $I_n$ 是一个 $n * n$ 的矩阵, 其左上右下对角线为 $1$, 其余部分为 $0$.

### 秩

两个向量 $(a_1, a_2, a_3,..., a_3)$ 线性相关, 定义为存在不全为 $0$ 的实数 $(c_1, c_2, c_3,..., c_n)$.

一个矩阵的秩代表最多取出多少行向量线性不相关.

一个矩阵的秩等于它转置矩阵的秩.

### 矩阵树定理

求无向图的生成树个数:

构造一个矩阵, 对角线上 $(i, i)$ 是第 $i$ 个点的度, 两个点 $i$, $j$ 之间连边就将 $(i, j)$ 和 $(j, i)$ 设为 $-1$, 钦定一个点为根, 则删掉这个点对应的行和列, 矩阵的行列式就是需要求的答案.

对于有向图, $(i, i)$ 记录出度, 每条有向边 $(i, j)$ 将 $(i, j)$ 置为 $-1$. 需要枚举每个点作为根, 然后求和.

### 特征多项式

$$
\begin{bmatrix}
1 1 1\\
1 1 a\\
1 1 1
\end{bmatrix}
$$

### 杜教筛

求积性函数前缀和.



## Day30: 欢乐模拟赛

### A

没读题亏死, "非空" 子段, 所以需要在最大子段和的程序上略加修改, 使得枚举的元素必选, 避免空选.

幸亏只挂了 $10'$.

```cpp
unsigned n;
long long a[1000005], K, B, Cnt(0), A, Ans(-0x3f3f3f3f3f3f3f3f), Tmp(0);
inline void Clr() {}
int main() {
  n = RD(), K = RDsg(), B = RDsg();
  for (register unsigned i(1); i <= n; ++i) {
    a[i] = RDsg() * K;
  }
  Ans = Tmp = a[1];
  for (register unsigned i(2); i <= n; ++i) {
    Tmp += a[i];
    if(Tmp < a[i]) Tmp = a[i];
    Ans = max(Ans, Tmp);
  }
  printf("%lld\n", Ans + B);
//  }
  return Wild_Donkey;
}
```

### B

貌似可以 $O(n)$, 但是场上想的 $O(n \log n)$, 所以就写了, 而且飞快.

因为有两个值, 生命和收益, 给两个值做前缀和, 记为 $H$, $W$. 因为收益单调不减, 所以固定左端点, 不死亡的前提下尽可能多走一定不会更劣. 

而左端点 $i$ 选在 $H$ 连续下降的末尾一定是极优的, 因为 $H_i < H_{i - 1}$, 所以选 $i - 1$ 相当于上来就直接去世. 而 $H_i \leq H_{i + 1}$, 所以选 $i$ 相当于比 $i + 1$ 多回了一次血或者多收益了一个单位.

接下来需要求固定左端点 $i$ 的不死亡最远点 $j$, 也就是右端点, 而这个左端点对应的答案就是 $W_j - W_{i - 1}$.

枚举左端点, 如果左端点为 $i$, 则右端点 $j$ 是 $j > i$ 的第一个 $H_j < H_i$ 的位置 $-1$.

使用 ST 查询 $H_i$ 的区间最小值, 然后二分右端点 $j$, 判断 $[i, j]$ 的最小值是否是 $H_i$, 如果是, 说明 $j$ 合法, 否则 $j$ 取大了.

ST 预处理 $O(n \log n)$, 枚举左端点 $O(n)$, 二分右端点 $O(\log n)$, 单次判断 $O(1)$, 总复杂度 $O(n \log n)$.

```cpp
int Pre[1000005][21];
unsigned m, n(1), Sum[1000005], Log[1000005], Bin[25], Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char a[1000005];
int Find(unsigned L, unsigned R) {
  register unsigned TmpF(Log[R - L + 1]);
  return min(Pre[L][TmpF], Pre[R - Bin[TmpF] + 1][TmpF]);
}
int main() {
  fread(a + 2, 1, 1000001, stdin);
  for (; a[n + 1] >= 'A'; ++n) a[n] -= 'A';
  a[n] -= 'A';
  if(n == 1) {
    if(a[1] == 0) Ans = 1;
    printf("%u\n", Ans);
    return 0;
  }
  for (register unsigned i(1), j(0); i <= n; ++j, i <<= 1) {
    Log[i] = j, Bin[j] = i;
  }
  for (register unsigned i(1); i <= n; ++i) {
    Log[i] = max(Log[i], Log[i - 1]);
  }
  Pre[0][0] = 0x3f3f3f3f, Pre[1][0] = 1, Sum[0] = 0;
  for (register unsigned i(2); i <= n; ++i) {
    Sum[i] = Sum[i - 1];
    Pre[i][0] = Pre[i - 1][0];
    if(!a[i]) ++Sum[i];
    else {
      if(a[i] ^ 1) ++Pre[i][0];
      else --Pre[i][0];
    }
  }
  for (register unsigned i(1), j(0); i < n; i <<= 1, ++j) {
    for (register unsigned k(1); k + i <= n; ++k) {
      Pre[k][j + 1] = min(Pre[k][j], Pre[k + i][j]);
    }
  }
  for (register unsigned i(1); i + 2 <= n; ++i) {
    if((Pre[i][0] < Pre[i - 1][0]) && (Pre[i][0] <= Pre[i + 1][0])) {
      register unsigned L(i + 2), R(n), Mid;
      while (L < R) {
        Mid = ((L + R + 1) >> 1);
        if(Pre[i][0] > Find(i, Mid)) {
          R = Mid - 1;
        } else {
          L = Mid;
        }
      }
      Ans = max(Ans, Sum[L] - Sum[i - 1]);
    }
  }
  if(Sum[n - 1] - Sum[n - 2]) Ans = max(Ans, (unsigned)1);
  if(Sum[n] - Sum[n - 1]) {
    Ans = max(Ans, (unsigned)1);
    if(Sum[n - 1] - Sum[n - 2]) Ans = max(Ans, (unsigned)2);
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

接下来是线性算法, 我们将之前枚举的极优左端点称为 "谷点", 考虑谷点的优劣关系, 如果一个谷点 $i_1 < i_2$, 且 $H_{i_1} < H_{i_2}$, 这时 $[i_2, j_2] \subset [i_1, j_1]$, 所以 $i_1$ 一定不比 $i_2$ 劣.

所以可能更新答案的谷点, 一定满足 $H$ 值随下标的增加而单调不增.

而这些谷点所对应的右端点是单调递增的, 所以可以双指针扫描整个数组, 总复杂度 $O(n)$.

```cpp
int Pre[1000005], Last(0x3f3f3f3f);
unsigned m, n(1), Sum[1000005], Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char a[1000005];
int main() {
  fread(a + 2, 1, 1000001, stdin);
  for (; a[n + 1] >= 'A'; ++n) a[n] -= 'A';
  a[n] -= 'A';
  if(n == 1) {
    if(a[1] == 0) Ans = 1;
    printf("%u\n", Ans);
    return 0;
  }
  Pre[0] = 0x3f3f3f3f, Pre[1] = 1, Sum[0] = 0;
  for (register unsigned i(2); i <= n; ++i) {
    Sum[i] = Sum[i - 1];
    Pre[i] = Pre[i - 1];
    if(!a[i]) ++Sum[i];
    else {
      if(a[i] ^ 1) ++Pre[i];
      else --Pre[i];
    }
  }
  for (register unsigned i(1), j; i <= n; ++i) {
    if((Pre[i] < Pre[i - 1]) && (Pre[i] <= Pre[i + 1])) {
      if(Pre[i] <= Last) {
        Last = Pre[i];
        for (j = i; (j < n) && (Pre[j] >= Pre[i]); ++j);
        Ans = max(Ans, Sum[j] - Sum[i - 1]);
        if(j > i) i = j - 1;
        else i = j;
      }
    }
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

仍然有一种想法, 扫描的时候开一个 $Pre$ 数组记录最后一次前缀和出现这个值的位置

### C

讨论题.

首先可以发现, 一个点是前三名, 所有可到达这个点的点一定需要小于 $3$, 否则一定不合法. 所以所有入度大于等于 $3$ 的点都是废点, 不会被答案统计到, 并且所有它到达的点都是废点.

然后建分层图, 发现分层图中有用的节点最多只有 $3$ 层.

分析可能前三的点组成的性质:

- 每层节点内部没有连边

- 第一层节点入度为 $0$

- 第二层节点入度为 $1$ 或 $2$

- 第二层的点入度为 $2$ 的情况下不能有出边

- 第三层节点的入度要么为 $1$, 要么入度为 $2$ 的情况下满足两条入边起点中间也有连边, 深度分别是 $1$, $2$, 也就是 `a>b, b>c, a>c` 三个约束同时出现, 这时可以直接删除 `a>c` 这条边. 所以可以认为最后分层图中第三层的点合法入度为 $1$.

然后对于每种情况分析答案数量:

- `1, 2, 3`

这种情况是指指定一个第三层的点作为第三名, 由于它只有一个入度, 来自一个第二层的点, 于是选中这个点作为第二名, 因为有出度的第二层的点只有一个入度, 所以最后一个作为第一名的点也确定了. 所以每个第三层的点对应一个 `1, 2, 3` 方案. 剩下的情况都不含第三层的点.

- `1, 2, 2`

这种情况选定了一个第一层的点做第一名, 然后任选两个入度为 $1$ 的第二层点做第二和第三. 假设一个第一层的点出边连向 $x$ 个入度为 $1$ 的第二层的点, 那么这个点对 `1, 2, 2` 方案贡献的答案就是 $A_2^x$, 也就是 $x(x - 1)$.

- `1, 1, 2`

这是针对入度为 $2$ 的第二层的点的, 选定一个入度为二的第二层的点做第三名, 它的两条入边对应的两个第一层的点分别做第一和第二, 每个入度为 $2$ 的第二层的点对应 $2$ 中方案.

- `1, 2 + 1`

这种方案选择了一个第一层的点, 一个它出边对应的入度为 $1$ 的第二层的点, 然后任选另外一个第一层的点, 分别作第一, 第二, 第三. 一开始选定的两个点按顺序做剩下的两名. 假设第一层有 $y$ 个点, 那么每个入度为 $1$ 的第二层的点都会对答案做出 $3(y - 1)$ 个贡献.

- `1 + 1 + 1`

三个入度为零的点任意组合, 假设有 $y$ 个入度为 $0$ 的点, 则对答案贡献为 $A^y_3[y \geq 3]$.

考场上得了 $20'$, 原因是将第三层的入度大于 $1$ 的点一棍子打死了, 没有考虑 `a>b, b>c, a>c` 也是可行的, 漏掉了 `a` 第一, `b` 第二, `c`第三的答案.

改了一下午变成 $30'$, 原因是将所有第三层入度为 $2$ 的点, 只要满足两个入度对应的点有约束关系就放走了, 以至于将 `a>b, b>c, a>c, d>b` 数据中的 `c` 放走了, 需要判断每个点的入度再讨论是否放走.

实现方面, 一开始从所有入度为 $0$ 的点多源 BFS, 一边分层一边删除点. 然后在所有打 `Ava` 标记的可行点组成的分层图上以每个点为跑 DFS, 然后统计五种答案.

复杂度也很简单, 一开始排序去重 $O(m \log m)$, BFS 时每个点都会入队一次, 遍历所有的边, $O(n + m)$, DFS 的时候, 一个第三层的点只会被一个第一层的点搜到, 而一个第二层的点最多被搜到两次, 所以复杂度 $O(n)$. 总复杂度 $O(m \log m + n)$.

```cpp
struct EdIn {
  unsigned Fr, To;
  inline const char operator < (const EdIn &x) const {
    return (this->Fr ^ x.Fr) ? (this->Fr < x.Fr) : (this->To < x.To);
  }
  inline const char operator == (const EdIn &x) const {
    return (this->Fr == x.Fr) && (this->To == x.To);
  }
}EI[200005];
struct Edge;
struct Node {
  Node *In1, *In2;
  char Ava;
  unsigned Dep, ID, OD;
  Edge *Fst;
}N[100005], *Q[100005];
inline void Print(Node *x) {
  printf("Node %u ID %u OD %u Ava %u Dep %u\n", x - N, x->ID, x->OD, x->Ava, x->Dep);
  printf("In1 %u In2 %u\n", x->In1 - N, x->In2 - N);
}
struct Edge {
  Node *To;
  Edge *Nxt;
}E[200005];
unsigned m, n, Hd, Tl;
unsigned long long Cnt(0), Cnt0(0), Ans(0);
void DFS (Node *x) {
  register Edge *Sid(x->Fst);
  register unsigned TA(0);
  while (Sid) {
    if(Sid->To->Ava) {
      ++(x->OD);
      if((Sid->To->Dep == 2) && (Sid->To->ID == 1)) DFS(Sid->To);
      if(x->Dep == 1) {
        if(Sid->To->ID == 2) ++Ans;// 1, 1, 2
        else {
          Ans += Sid->To->OD;// 1, 2, 3
          Ans += 3 * (Cnt0 - 1); // 1, 2 + 1
          ++TA; // 1, 2, 2
        }
      }
    }
    Sid = Sid->Nxt;
  }
  Ans += ((unsigned long long)TA * (TA - 1));
}
int main() {
  n = RD(), m = RD();
  for (register unsigned i(1); i <= m; ++i) {
    EI[i].Fr = RD(), EI[i].To = RD();
  }
  sort(EI + 1, EI + m + 1);
  m = unique(EI + 1, EI + m + 1) - EI - 1;
  for (register unsigned i(1); i <= m; ++i) {
    ++N[EI[i].To].ID;
    E[i].Nxt = N[EI[i].Fr].Fst;
    N[EI[i].Fr].Fst = E + i;
    E[i].To = N + EI[i].To;
    if(N[EI[i].To].In1) N[EI[i].To].In2 = EI[i].Fr + N;
    else N[EI[i].To].In1 = EI[i].Fr + N;
  }
  Hd = Tl = 0;
  for (register unsigned i(1); i <= n; ++i) if(!(N[i].ID)) {
    ++Cnt0, N[i].Dep = 1, Q[++Tl] = N + i, N[i].Ava = 1;
    continue;
  }
  if(Cnt0 >= 3) Ans = (unsigned long long)Cnt0 * (Cnt0 - 1) * (Cnt0 - 2);
  register Node *Now;
  register Edge *Sid;
  while (Hd < Tl) {
    Now = Q[++Hd], Sid = Now->Fst;
    while (Sid) {
      if(!(Sid->To->Dep)) {
        Sid->To->Dep = Now->Dep + 1;
        Q[++Tl] = Sid->To;
        if(Now->Dep == 1) {
          if(Sid->To->ID <= 2) {
            Sid->To->Ava = 1, Sid = Sid->Nxt;
            continue;
          }
        } else {
          if((Sid->To->ID == 1) && (Now->Dep == 2)) { // Available
            Sid->To->Ava = 1, Sid = Sid->Nxt;
            continue;
          }
        }
      } else {// Visited
      	Sid->To->Dep = Now->Dep + 1;
      	if(Sid->To->Dep > 3) {
      	  Sid->To->Ava = 0;
          Sid = Sid->Nxt;
          continue;
        }
      	if(Sid->To->Dep == 3) {
      	  if((Now->ID == 1) && (Sid->To->ID == 2)) { // Available
            if(Sid->To->In1 == Now) {
              if((Sid->To->In2 == Now->In1) || (Sid->To->In2 == Now->In2)) {
                Sid->To->Ava = 1, --(Now->OD), Sid = Sid->Nxt;
                continue;
              }
            } else {
              if((Sid->To->In1 == Now->In1) || (Sid->To->In1 == Now->In2)) {
                Sid->To->Ava = 1, --(Now->OD), Sid = Sid->Nxt;
                continue;
              }
            }
          }
          Sid->To->Ava = 0;
        }
      }
      Sid = Sid->Nxt;
    }
  }
  for (register unsigned i(1); i <= n; ++i) if(!(N[i].ID)) DFS(N + i);
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```


### 