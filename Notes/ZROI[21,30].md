[TOC]

# ZROI

## Day21: 状压 DP

### 状态压缩

状态是一个 $k$ 进制数, 将每个元素的状态用每个 $k$ 进制位的值表示.

### [USACO 06 Nov](https://www.luogu.com.cn/problem/P1879) 

一个矩形, 分成 $n * m$ 个格子, 有的格子能选, 有的不能选, 要求选择的格子两两不相邻, 求合法的选取方式数对 $10^8$ 取模的余数.

设计状态 $f_{i, j}$, 表示从上到第 $i$ 行, 第 $i$ 行的状态是 $j$ 的二进制表示的.

我们可以先预处理出合法的行状态, $List_i$ 表示第 $i$ 个没有两个格子相邻的行状态.

$$
f_{i, j} = \sum_k^{k \in List, k \And j = k \And a_i = 0}(f_{i - 1, k})
$$

注: $a_i$ 是棋盘第 $i$ 行状态.

但是因为一直以来想写 $O(n^2(2^n))$ 的做法, 所以趁机练习一下传说中的轮廓线 DP, 所以重新设计状态, 设 $f_{i, j, k}$ 表示决策了 $i - 1$ 行, 第 $i$ 行决策到了第 $j$ 列的合法方案数, 其中第 $i$ 行的 $[0, j]$ 列和第 $i + 1$ 行的 $[j + 1, m)$ 列拼起来的状态为 $i$.

状态数 $O(n^2(2^n))$ 转移可以做到 $O(1)$, 复杂度 $O$, 本题 $n = 12$, 代入是 $589824$.

但是因为原来的做法复杂度和合法状态数 $Cnt$ 有关, 所以原来 $n(4^n)$ 的做法其实是 $O(nCnt^2)$ 貌似也没有很劣, $n = 12$ 时状态数是 $377$, 所以代入是 $1705548$, 因为原做法可以大量位运算优化, 并且没有那么多边界条件, 实际效率甚至比轮廓线优.

接下来放轮廓线代码:

```cpp
const unsigned long long Mod(100000000);
unsigned long long f[15][15][4500], Ans;
unsigned a[15], m, n, n2, Cnt(0), A, B, C, D, t, Tmp(0);
int main() {
  n = RD(), m = RD(), n2 = (1 << m); 
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned j(1); j <= m; ++j) {
      a[i] <<= 1, a[i] += RD();
    }
  }
  f[0][m - 1][0] = 1;
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned k(0); k < n2; ++k) {
      if(!(k & 1)) {f[i][0][k] = f[i - 1][m - 1][k ^ 1] + f[i - 1][m - 1][k]; if(f[i][0][k] >= Mod) f[i][0][k] -= Mod;}
      if(a[i] & k & 1) f[i][0][k] = f[i - 1][m - 1][k ^ 1];
    }
    for (register unsigned j(1); j < m; ++j) {
      for (register unsigned k(0); k < n2; ++k) {
        if((k & (1 << j)) && (k & (1 << (j - 1)))) continue;
        if(a[i] & k & (1 << j)) f[i][j][k] = f[i][j - 1][k ^ (1 << j)];
        if(!(k & (1 << j))) {f[i][j][k] = f[i][j - 1][k ^ (1 << j)] + f[i][j - 1][k]; if(f[i][j][k] >= Mod) f[i][j][k] -= Mod;}
      }
    }
  }
  for (unsigned i(0); i < n2; ++i) Ans += f[n][m - 1][i];
  printf("%llu\n", Ans % Mod);
  return Wild_Donkey;
}
```

### [NOI2001](https://www.luogu.com.cn/problem/P2704)

仍然先预处理出合法状态集合 $List$, 然后设计状态 $f_{i, j, k}$ 表示算到第 $i$ 行, 第 $i$ 行状态为 $j$, 第 $i - 1$ 行状态为 $k$ 的情况.

$$
f_{i, j, k} = \sum_{l}^{l \in List, l \And j = l \And k = l \And a_{i - 2} = 0} f_{i - 1, k, l}
$$

早年诡异码风改了改, 细节不多不少, 枚举两排状态确实很神奇, 看起来非常慢, 实际上可行状态不多跑得飞快.

```cpp
unsigned int a[105], f[105][65][65], List[65], m, n, N, Cnt(0), A, B, C, D, Ans(0);
bool b[10005];
char s;
inline unsigned int Gtnm(unsigned int x) {
  unsigned int tmp(0); 
  while (x) {
    if(x & 1) ++tmp;
    x = x >> 1;
  }
  return tmp;
}
inline bool Judge (unsigned int x) {
  unsigned int tmp(0x3f);
  while (x) {
    if(x & 1) {
      if(tmp < 2) return 0;
      tmp = 0;
    }
    else ++tmp;
    x = x >> 1;
  }
  return 1;
}
int main() {
  n = RD(), m = RD(), N = (1 << m) - 1;
  for (register int i(0); i <= N; ++i) if (Judge(i)) List[++List[0]] = i;
  for (register int i(1); i <= n; ++i) {
    for (register int j(1); j <= m; ++j) {//init
      while (s != 'H' && s != 'P') s = getchar();
      a[i] = a[i] << 1;
      if (s == 'H') ++a[i];
      s = '0';
    }
  }
  for (register unsigned int i(1); i <= List[0]; ++i) {//1st line
    if (List[i] & a[1]) continue;//land
    Cnt = Gtnm(List[i]);
    f[1][i][1] = Cnt;
  }
  for (register unsigned int i(2); i <= n; ++i) {
    for (register unsigned int j(1); j <= List[0]; ++j) {//this line
      if (List[j] & a[i]) continue;//land
      Cnt = Gtnm(List[j]);
      for (register unsigned int k(1); k <= List[0]; ++k) {//last line
        if(List[j] & List[k] || List[k] & a[i - 1]) continue;//Gun
        for (register unsigned int l(1); l <= List[0]; ++l) {//last of last 
          if(List[j] & List[l] || List[k] & List[l] || List[l] & a[i - 2]) continue;
          f[i][j][k] = max(f[i - 1][k][l] + Cnt, f[i][j][k]); 
        }
      }
    }
  }
  for (register unsigned int i(1); i <= List[0]; ++i)
    for (register unsigned int j(1); j <= List[0]; ++j)
      Ans = max(f[n][i][j], Ans);
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### [SDOI2009](https://www.luogu.com.cn/problem/P2157)

设计状态 $f_{i, j, 0/1, k}$ 表示 $i$ 前面都拿到饭, $i$ 没拿到饭, $j$ 集合的人已经拿到饭, 最后拿到饭的人是 $i ± k$ 的最少时间. 

$$
f_{i, j, 0, k} = min(f_{i - k, (j << k) | (1 << (k - 1) - 1), 0, l} + (T_{i - k - l} \oplus T_{i - k}),\\
f_{i - k, (j << k) | (1 << (k - 1) - 1), 1, l} + (T_{i - k + l} \oplus T_{i - k}))\\
f_{i, j, 1, k} = min(f_{i, j - (1 << (k - 1)), 0, l} + (T_{i + k - l} \oplus T_{i + k}),\\
f_{i, j - (1 << (k - 1)), 1, l} + (T_{i + k + l} \oplus T_{i + k}))
$$

注意这个题 $i$ 拿的时候可能上一个拿的是 $i - 8$, 所以需要考虑 $8$ 个位置.

```cpp
unsigned m, n;
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
unsigned Like[1015], Anger[1015], f[1015][150][2][10];
unsigned Cant[10];
inline void Clr() {
  memset(f, 0x3f, sizeof(f));
  memset(Like, 0x3f, sizeof(Like));
  n = RD(), Ans = 0x3f3f3f3f;
}
signed main() {
  t = RD();
  Anger[0] = 0x3f3f3f3f;
  Cant[0] = -1;
  for (unsigned i(1); i <= 8; ++i) Cant[i] = Cant[i - 1] << 1;
  for (unsigned T(1); T <= t; ++T) {
    Clr();
    for (unsigned i(1); i <= n; ++i) Like[i] = RD(), Anger[i] = RD();
    f[2][0][0][1] = 0, Anger[n + 1] = 0;
    for (unsigned i(2), Now(0x3f3f3f3f); i <= 8; ++i) {
      Now = min(Now, Anger[i - 1] + i - 1);
      if (i > Now) break;
      f[1][1 << (i - 2)][1][i - 1] = 0;
    }
    for (unsigned i(1); i <= n + 1; ++i) {
      unsigned Mxj(1 << Anger[i]);
      for (unsigned j(0); j < Mxj; ++j) {
        unsigned Now(Cant[Anger[i]]);
        for (unsigned No(1); No <= 8; ++No)
          if (!((1 << (No - 1)) & j)) Now |= Cant[Anger[i + No]] << No;
        if (j & Now) continue;
        Now = i - 1;
        for (unsigned k(0); k < 8; ++k) if (j & (1 << k)) Now = i + k + 1;
        for (unsigned k(1); k <= 8; ++k) {
          if (i < k) break;
          if (Anger[i - k] < Now - i + k) continue;
          unsigned Des(j << k);
          Des |= (1 << (k - 1)) - 1;
          for (unsigned l(1); l <= 8; ++l) {
            if (i - k < l) break;
            f[i][j][0][k] = min(f[i][j][0][k], f[i - k][Des][0][l] + (Like[i - k - l] ^ Like[i - k]));
          }
          for (unsigned l(1); l <= 8; ++l) {
            //            if(k == l) continue;
            f[i][j][0][k] = min(f[i][j][0][k], f[i - k][Des][1][l] + (Like[i - k + l] ^ Like[i - k]));
          }
        }
        for (unsigned k(1); k <= 8; ++k) {
          if (!((1 << (k - 1)) & j)) continue;
          if (Anger[i + k] < Now - i - k) continue;
          unsigned Des(j ^ (1 << (k - 1)));
          for (unsigned l(1); l <= 8; ++l) {
            if (i < l) break;
            f[i][j][1][k] = min(f[i][j][1][k], f[i][Des][0][l] + (Like[i - l] ^ Like[i + k]));
          }
          for (unsigned l(1); l <= 8; ++l) {
            if (!((1 << (l - 1)) & Des)) continue;
            f[i][j][1][k] = min(f[i][j][1][k], f[i][Des][1][l] + (Like[i + l] ^ Like[i + k]));
          }
        }
      }
    }
    for (unsigned i(1); i <= 7; ++i) Ans = min(Ans, f[n + 1][0][0][i]);
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

### [AHOI2009](https://www.luogu.com.cn/problem/P2051)

在棋盘上放置中国象棋中的炮, 使得没有炮能互相攻击, 求方案数.

问题转化为往棋盘上放点, 使得不存在三个点在一行或一列中.

状态 $f_{i, j, k}$ 表示到第 $i$ 行, 有 $j$ 列有 $1$ 个炮, $k$ 列有 $2$ 个炮.

$$
\begin{aligned}
f_{i, j, k} = &f_{i - 1, j, k} +\\
&(n - k - j + 1)f_{i - 1, j - 1, k} +\\
&(j + 1)f_{i - 1, j + 1, k - 1} +\\
&\binom{n - k - j + 2}{2}f_{i - 1, j - 2, k} +\\
&\binom{j + 2}{2}f_{i - 1, j + 2, k - 2} +\\
&j(n - k - j + 1)f_{i - 1, j, k - 1}
\end{aligned}
$$

代码使用滚动数组, 所以枚举顺序比较神奇, 轻松冲到最优解前几名.

```cpp
const unsigned long long Mod(9999973);
unsigned long long Ans(0), f[105][105], C2[105];
unsigned m, n;
signed main() {
  n = RD(), m = RD();
  C2[0] = 0, f[0][0] = 1;
  for (unsigned i(1); i <= n; ++i) C2[i] = (i * (i - 1)) >> 1;
  for (unsigned i(1); i <= m; ++i) for (unsigned k(n); ~k; --k) for (unsigned j(n - k); ~j; --j) {
    unsigned long long Tmp(0);
    if(j) {
      Tmp += f[j - 1][k] * (n - k - j + 1);
      if(j > 1) Tmp += f[j - 2][k] * C2[n - k - j + 2];
    }
    if(k) {
      Tmp += f[j][k - 1] * j * (n - k - j + 1) + f[j + 1][k - 1] * (j + 1);
      if(k > 1) Tmp += f[j + 2][k - 2] * C2[j + 2];
    }
    f[j][k] = (f[j][k] + Tmp) % Mod;
  }
  for (unsigned i(0); i <= n; ++i) for (unsigned j(0); j + i <= n; ++j) Ans += f[i][j];
  printf("%llu\n", Ans % Mod);
  return Wild_Donkey;
}
```

### [P5005](https://www.luogu.com.cn/problem/P5005)

在棋盘上放置中国象棋中的马, 使得没有马能互相攻击或单向攻击, 求方案数.

仍然状压两位, $f_{i, j, k}$ 表示到第 $i$ 行, 第 $i$ 行状态为 $j$, 第 $i - 1$ 行状态为 $k$ 的状态.

$$
f_{i, j, k} = \sum_{l} f_{i, k, l}\\
(j << 1 \And l) | (j \And l >> 1) | k = k,\\
(j >> 1 \And l) | (j \And l << 1) | k = k,\\
((j << 2 \And k) >> 1) | k = k,\\
((j << 2 \And k) >> 1) | j = j,\\
((j >> 2 \And k) << 1) | k = k,\\
((j >> 2 \And k) << 1) | j = j,\\
$$

### [TJOI2015](https://www.luogu.com.cn/problem/P3977)

每个点的范围是 $3 * p$, 仍然求放点使其不能攻击的方案数.

因为转移规则是一个矩阵, 所以不方便使用位运算判断, 用转移矩阵对状态进行转移.

新建一个 $2^n * 2^n$ 的矩阵, 用矩阵快速幂加速转移.

### [NOIP2017](https://www.luogu.com.cn/problem/P3959)

给一个无向图, 求一个生成树使得代价最小, 一个生成树的代价是边的代价之和, 每条边的代价是边的权值和边下端点深度的积. $n \leq 12$.

这个题 Prim 被 Hack 了, 详情见 RQY 的[数据](https://paste.ubuntu.com/25953020/).

设计状态 $f_{i}$ 表示选择了 $i$ 状态的点, $O(2^n)$. 定义数组 $g_{i, j}$ 表示状态 $i$ 中, $j$ 点的深度. 转移是枚举加入哪个点, 然后对于每个加入的点, 枚举它的父亲, 转移 $O(n^2)$. 总复杂度 $O(2^nn^2)$, 所以这个题 $n$ 开到 $15$ 也不是不能做.

### [P3943](https://www.luogu.com.cn/problem/P3943)

一个长为 $n$ 的 `0/1` 串, 有 $k$ 个 $0$, 每次允许取反特定长度的区间, $m$ 种区间长度. 求最少取反几次得到 $n$ 个 $1$.

### [SCOI2005](https://www.luogu.com.cn/problem/P1896)

往棋盘上放国际象棋国王, 使其不能互相攻击, 求方案数.

仍然是状态 $f_{i, j}$ 表示到第 $i$ 行, 第 $i$ 行状态为 $j$ 时的方案数.

$$
f_{i, j} = \sum_k^{(k | (k << 1) | (k >> 1)) \And j = 0}f_{i - 1, k}
$$

### 轮廓线 DP

上一道题如果不是一行一起转移, 而是每个位置讨论放或者不放, 将讨论的状态变成这个位置及以上的一个轮廓线的状态, 这样可以优化时间复杂度, 从 $O(2^nn)$ 状态, $O(2^n)$ 转移优化到 $O(2^nn^2)$ 状态, $O(1)$ 转移.

### 例题

给一个有障碍物的棋盘, 放 $k$ 对人, 每队人不能和自己对应的人相邻, 求方案数.

设计状态 $f_{i, j, k, l}$ 表示讨论到 $(i, j)$, 轮廓线状态为 $k$, 已经填完了 $l$ 对点的方案数.

需要统计 $Em_{i, j}$ 表示扫描到 $(i, j)$ 的时候的空位个数.

最后乘一个排列数即可.

### [NOI2015](https://www.luogu.com.cn/problem/P2150)

给正整数 $[2, n]$, 选两个不交子集, 使得两个子集中任意两个数互质. 求方案数.

分析性质, 发现对于每个质数 $p$, 两个数集中只有一个数集存在整除 $p$ 的元素. 所以状态就是两个集合分别包含的质因数集合即可, 必须要求两个集合 $\And$ 后是 $0$.

设 $n$ 以内有 $m$ 个质数, 则复杂度是 $O(2^{2m}n)$.

为了优化, 我们可以枚举质数, 将所有以这个质数为最大质因数的数都考虑一遍, 这样就可以减少状态的记录, 并且加速了转移. 

但是因为仍要记录两个交为 $0$ 的集合, 所以有结论说明这样的集合有 $O(3^n)$ 对.

根号分治可以将其优化到 $O(n3^{\sqrt n})$

### [THU2012](https://www.luogu.com.cn/problem/P5933)

有 $n$ 个本质不同的点, 用若干条颜色不同的边将他们连成连通图, 求方案数. 每种颜色有 $c_i$ 条边备选. 不允许出现重边, 自环.

### [AT2390](https://ww w.luogu.com.cn/problem/AT2390)

博弈论 + DP?

貌似博弈论和 DAG 往往同时出现...

### [P4363](https://www.luogu.com.cn/problem/P4363)

一个棋盘, 每个格子有两个值 $a_{i, j}$ 和 $b_{i, j}$, 每个格子 $(i, j)$ 选当且仅当除了它以外, $x \in [1, i]$, $y \in [1, j]$ 的所有 $(x, y)$ 都已经选了.

求最后双方最小的差值.

先手选一个格子 $(i, j)$ 获得收益 $a_{i, j}$, 后手选 $(i, j)$ 获得 $b_{i, j}$.

这时要维护一个单调不减的折线, 折线左上方都选了, 左下都没选, 而折线向左上凸出的位置的顶点处可以选. 这种折线有 $\binom {n + m}n$ 种.
。一
将 $[1, \binom {n + m}n]$ 的数作为状态值, 然后对它进行转移.

## Day22: 模拟赛

### A

给一个数 $S$, 和一个序列 $a$, 每次可以选择一个数, 使得 $S$ 变成 $S + a_i$ 或 $Sa_i$, 每个数用一次, 求操作后 $S$ 最大值.

升序排序, 贪心, 一定有一个界, 使得在此之前都选 $S + a_i$, 之后都选 $Sa_i$. 而这个界限可以贪心地判断考虑到每个数字时 $S + a_i$ 和 $Sa_i$ 的大小.

由于 $S$ 和给出序列的长度两个范围看反了, 所以数组开小了, 而且没开 `long double`, 所以直接爆炸.

```cpp
unsigned m, n, Cnt(0), A, B, C, D, t;
long double Ans, a[100005];
inline void Clr() {}
int main() {
  scanf("%LF", &Ans), n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    scanf("%LF", &a[i]);
  }
  sort(a + 1, a + n + 1);
  for (register unsigned i(1); i <= n; ++i) {
    if(a[i] <= 1) {
      Ans += a[i]; 
      continue; 
    }
    if(a[i] * Ans > a[i] + Ans) {
      Ans *= a[i];
    } else {
      Ans += a[i]; 
    }
  }
  printf("%.9LF\n", Ans);
  return Wild_Donkey;
}
```

### B

题假了, 爆零人站起来了.

### C

先考虑只有两个值的情况, 容易想到贪心, 按 $a_i - b_i$ 升序排序, 前 $B$ 个都选 $b$, 后 $A$ 个都选 $a$.

首先想到了 DP, 状态 $f_{i, j, k}$ 表示前 $i$ 个物品, 已经选了 $j$ 个 $a$, $k$ 个 $b$, $i - j - k$ 个 $c$ 的最大收益.

$$
f_{i, j, k} = max(f_{i - 1, j - 1, k} + a_{i}, f_{i - 1, j, k - 1} + b_{i}, f_{i - 1, j, k} + c_{i})
$$

状态 $O(n^3)$, 转移 $O(1)$, 时间复杂度 $O(n^3)$, 滚动数组后空间复杂度 $O(n^2)$. 可以得到 $60'$.

```cpp
unsigned long long a[3][300005], f[5005][5005];
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
inline void Clr() {}
int main() {
  n = RD(), A = RD(), B = RD();// C = RD();
  for (register unsigned i(1); i <= n; ++i) {
    a[0][i] = RD(), a[1][i] = RD(), a[2][i] = RD();
  }
  for (register unsigned i(1); i <= n; ++i) {
    for (register unsigned j(i - 1); j; --j) {
      f[j][i - j] = max(f[j - 1][i - j] + a[0][i], f[j][i - j - 1] + a[1][i]);
    }
    f[i][0] = f[i - 1][0] + a[0][i];
    f[0][i] = f[0][i - 1] + a[1][i];
    for (register unsigned j(i - 1); j; --j) {
      for (register unsigned k(i - j - 1); k; --k) {
        f[j][k] = max(max(f[j - 1][k] + a[0][i], f[j][k - 1] + a[1][i]), f[j][k] + a[2][i]);
      }
    }
    for (register unsigned j(i - 1); j; --j) {
      f[j][0] = max(f[j - 1][0] + a[0][i], f[j][0] + a[2][i]);
      f[0][j] = max(f[0][j - 1] + a[1][i], f[0][j] + a[2][i]);
    }
    f[0][0] = f[0][0] + a[2][i];
  }
  printf("%llu\n", f[A][B]);
  return Wild_Donkey;
}
```

能得 $60'$ 的算法还有费用流, 开三个点分别连向汇点免费的, 容量为 $A$, $B$, $C$ 的边. 然后从源点向每个物品连免费的容量为 $1$ 的边, 然后每个物品分别向 $A$, $B$, $C$ 点连接容量为 $1$, 费用分别是 $a_i$, $b_i$, $c_i$ 的边, 跑最大费用最大流即可.

接下来是正解:

如果有三个值, 仍先按 $a_i - b_i$ 升序排序, 假设已经把选 $c$ 的 $C$ 个物品删掉了, 这时剩下的 $A + B$ 个物品仍应该是前 $B$ 个选 $b$, 后 $A$ 个选 $a$. 因此在排好序的 $n$ 个物品的序列中, 一定存在一个分界线, 它左边除了 $b$ 就是 $c$, 它右边除了 $a$ 就是 $c$.

假设我们已经知道, 分界线是 $x$, 也就是说 $[1, x]$ 中, 有 $B$ 个选 $b$, $x - B$ 个选 $C$.

我们已经知道了只有两种选择的时候如何贪心, 直接选择 $x$ 个数中的前 $B$ 大的 $b_i - c_i$ 的物品选 $b$ 即可.

但是如果对于每个分界点都这样判断, 无疑是非常慢的, 定义两个数组, $f_i$ 和 $g_i$, 分别代表 $[1, i]$ 中前 $B$ 大的 $b_i - c_i$ 值之和, 和 $[i, n]$ 中前 $A$ 大的 $a_i - c_i$ 值之和. 到时候只要取 $f_{i} + g_{i + 1} + SumC$ 的最大值即可.

如何求 $f$ 和 $g$, $f$ 的下标范围是 $[B, n]$, 而 $f_{B}$ 显然是 $\displaystyle{\sum_{i = 1}^{i \leq B} b_i - c_i}$, 接下来的每个 $f_i$, 都是在上一个版本的基础上加入当前位置的 $b_i - c_i$. 然后删去最小值得到的总和, 每次弹出最小值可以用堆维护, $g$ 同理. 这样就可以 $O(n \log n)$ 求出 $f$ 和 $g$. 最后 $O(n)$ 扫描统计答案即可.

```cpp
struct Gift {
  unsigned V1, V2;
  inline const char operator<(const Gift &x) const{
    return (this->V1 + x.V2) > (x.V1 + this->V2);
  }
}G[300005];
unsigned V3[300005], m, n, Cnt(0), A, B, C, D, t;
unsigned long long Ans(0), f[300005], g[300005], Tmp;
priority_queue<unsigned, vector<unsigned>, greater<unsigned> > Q;
int main() {
  n = RD(), A = RD(), B = RD(); C = n - B;
  for (register unsigned i(1), Min; i <= n; ++i) {
    G[i].V1 = 1000000000 + RD(), G[i].V2 = 1000000000 + RD(), Ans += (V3[i] = RD());
    G[i].V1 -= V3[i], G[i].V2 -= V3[i];
  }
  sort(G + 1, G + n + 1), Ans -= (unsigned long long)1000000000 * (A + B);
  for (register unsigned i(1); i <= A; ++i) {
    Tmp = G[i].V1;
    Q.push(Tmp);
    f[i] = f[i - 1] + Tmp;
  }
  for (register unsigned i(A + 1); i <= n; ++i) {
    Tmp = G[i].V1;
    Q.push(Tmp);
    f[i] = f[i - 1] + Tmp - Q.top();
    Q.pop();
  }
  while (Q.size()) Q.pop();
  for (register unsigned i(n); i > C; --i) {
    Tmp = G[i].V2;
    Q.push(Tmp);
    g[i] = g[i + 1] + Tmp;
  }
  for (register unsigned i(C); i; --i) {
    Tmp = G[i].V2;
    Q.push(Tmp);
    g[i] = g[i + 1] + Tmp - Q.top();
    Q.pop();
  }
  Tmp = 0;
  for (register unsigned i(A); i <= C; ++i) {
    Tmp = max(Tmp, f[i] + g[i + 1]);
  }
  printf("%llu\n", Ans + Tmp);
  return Wild_Donkey;
}
```

### D

据说正解是矩阵乘法或可持久化平衡树, 但是我们不管这么多, 直接踩一下标算.

![1949.png](https://i.loli.net/2021/08/08/SbW3AhXH1gYJfdr.png)

开 $20$ 棵动态开点线段树, 通过交换和共用儿子来操作, 通过节点分裂保证每一行互不干扰, 复杂度 $O(m \log n)$.

```cpp
unsigned m, n, q, Cnt(0), A, P, B, C, D, t, Ans(0), Tmp(0);
const unsigned MOD(998244353);
inline void Clr() {}
struct Node {
  Node *LS, *RS;
  unsigned Val, Tag, Deg;
}*Root[25], N[50000005], *CntN(N);
inline void New(Node *x, Node *y) {
  x->Deg = 1;
  x->Val = y->Val;
  x->Tag = y->Tag;
  x->LS = y->LS;
  x->RS = y->RS;
  if(x->LS) ++(x->LS->Deg);
  if(x->RS) ++(x->RS->Deg);
  --(y->Deg);
}
inline void PsDw(Node *x, const unsigned Len) {
  if(!(x->LS)) x->LS = ++CntN, x->LS->Deg = 1;
  if(!(x->RS)) x->RS = ++CntN, x->RS->Deg = 1;
  if(x->LS->Deg > 1) {
    New(++CntN, x->LS);
    x->LS = CntN;
  }
  if(x->RS->Deg > 1) {
    New(++CntN, x->RS);
    x->RS = CntN;
  }
  if(x->Tag) {
    x->LS->Tag += x->Tag;
    if(x->LS->Tag >= MOD) x->LS->Tag -= MOD;
    x->LS->Val = ((unsigned long long)(x->Tag) * ((Len + 1) >> 1) + x->LS->Val) % MOD;
    x->RS->Tag += x->Tag;
    if(x->RS->Tag >= MOD) x->RS->Tag -= MOD;
    x->RS->Val = ((unsigned long long)(x->Tag) * (Len >> 1) + x->RS->Val) % MOD;
    x->Tag = 0;
  }
  return;
}
void Qry(Node *x, unsigned L, unsigned R) {
  if((B <= L) && (R <= C)) {
    Ans += x->Val;
    if(Ans >= MOD) Ans -= MOD;
    return;
  }
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  if(B <= Mid) {
    Qry(x->LS, L, Mid);
  }
  if(C > Mid) {
    Qry(x->RS, Mid + 1, R);
  }
  return;
}
void Chg(Node *x, unsigned L, unsigned R) {
  if((B <= L) && (R <= C)) {
    x->Tag += D;
    if(x->Tag >= MOD) x->Tag -= MOD;
    x->Val = (((unsigned long long)D * (R - L + 1)) + x->Val) % MOD;
    return;
  }
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  if(B <= Mid) {
    Chg(x->LS, L, Mid);
  }
  if(C > Mid) {
    Chg(x->RS, Mid + 1, R);
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  return;
}
void Swap(Node *x, Node *y, unsigned L, unsigned R) {
  if(L == R) return;
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  PsDw(y, R - L + 1);
  if(C <= Mid) {
    if((C <= L) && (Mid <= D)) {
      swap(x->LS, y->LS);
    } else {
      Swap(x->LS, y->LS, L, Mid);
    }
  }
  if(D > Mid) {
    if((C <= Mid + 1) && (R <= D)) {
      swap(x->RS, y->RS);
    } else {
      Swap(x->RS, y->RS, Mid + 1, R);
    }
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  y->Val = y->LS->Val + y->RS->Val;
  if(y->Val >= MOD) y->Val -= MOD;
  return;
}
void Copy(Node *x, Node *y, unsigned L, unsigned R) {
  if(L == R) return;
  register unsigned Mid((L + R) >> 1);
  PsDw(x, R - L + 1);
  PsDw(y, R - L + 1);
  if(C <= Mid) {
    if((C <= L) && (Mid <= D)) {
      y->LS = x->LS;
      ++(y->LS->Deg);
    } else {
      Copy(x->LS, y->LS, L, Mid);
    }
  }
  if(D > Mid) {
    if((C <= Mid + 1) && (R <= D)) {
      y->RS = x->RS;
      ++(y->RS->Deg);
    } else {
      Copy(x->RS, y->RS, Mid + 1, R);
    }
  }
  x->Val = x->LS->Val + x->RS->Val;
  if(x->Val >= MOD) x->Val -= MOD;
  y->Val = y->LS->Val + y->RS->Val;
  if(y->Val >= MOD) y->Val -= MOD;
  return;
}
int main() {
  n = RD(), m = RD(), q = RD();
  for (register unsigned i(1); i <= n; ++i) {
    Root[i] = ++CntN;
  }
  for (register unsigned i(1); i <= q; ++i) {
    A = RD(), P = RD(), B = RD(), C = RD();
    switch (A) {
      case (0) :{
        Ans = 0, Qry(Root[P], 1, m);
        printf("%u\n", Ans);
        break;
      }
      case (1) :{
        D = RD(), Chg(Root[P], 1, m);
        break;
      }
      case (2) :{
        D = RD();
        if(B == P) break;
        Swap(Root[P], Root[B], 1, m);
        break;
      }
      case (3) :{
        D = RD();
        if(B == P) break;
        Copy(Root[P], Root[B], 1, m);
        break;
      }
    }
  }
  return Wild_Donkey;
}
```

## Day23: 数位 DP

### [SCOI2009](https://www.luogu.com.cn/problem/P2657)

设计状态 $f_{i, j, 0/1}$, 其中 $i$ 表示位置, $j$ 表示当前位的数, 第一个 $0/1$ 表示前 $i$ 位是否顶界.

$$
f_{i, j, 0} = f_{i - 1, a_{i - 1}, 1} * [|a_{i - 1} - j| \geq 2, j < a_{i}] + \sum_k^{|k - j| \geq 2} f_{i - 1, k, 0}\\
f_{i, j, 1} = f_{i - 1, a_{i - 1}, 1} * [|a_{i - 1} - j| \geq 2, j = a_{i}]
$$

### [P4317](https://www.luogu.com.cn/problem/P4317)

设 $Count_i$ 表示 $i$ 二进制表示有多少 $1$, $Num_i$ 表示 $[1, n]$ 中 $Count = i$ 的数的数量, 问题转化为求 $\displaystyle{\prod_i i^{Num_i}}$.

设计状态 $f_{i, j, 0/1}$ 表示到第 $i$ 位, 二进制有 $j$ 个 $1$, 前 $i$ 位是否顶界的数的数量.

$$
f_{i, j, 0} = f_{i - 1, j, 0} + f_{i - 1, j - 1, 0} + f_{i - 1, j, 1} * [a_{i} = 1]\\
f_{i, j, 1} = f_{i - 1, j, 1} * [a_{i} = 0] + f_{i - 1, j - 1, 1} * [a_{i} = 1]\\
Num_i = f_{Len, i, 0} + f_{Len, i, 1}
$$

### [HNOI2002](https://www.luogu.com.cn/problem/P2235)

问题转化为求 $[1, m]$ 中的二进制回文数个数.

先判断 $m$ 是否为二进制回文数.

### [SCOI2013](https://www.luogu.com.cn/problem/P3281)

状态 $f_{i, j, 0/1}$ 表示到第 $i$ 位, 第 $i$ 位为 $j$, 是否顶界.

$$
f_{i, j, 0} = (f_{i - 1, a_{i - 1}, 1} * [j < a_{i}] + \sum_{k = 0}^{k < B}{f_{i - 1, k, 0}}) * B + j * (i)\\
f_{i, j, 1} = f_{i - 1, a_{i - 1}, 1} * [j = a_{i}] * B + j * (i)
$$

### 例题

求

$$
\sum_{i = l}^{r} \binom{a+i}{b}c^i \% p
$$

设 $a + i = A_0 + pA_1 + p^2A_2...$, $b = B_0 + pB_1 + p^2B_2...$

$$
\binom{a + i}{b} \equiv \prod_{j = 0} \binom{A_j}{B_j} \pmod p
$$

设 $i = C_0 + pC_1 + p^2C_2...$

$$
c^i \equiv \prod_{j = 0} c^{C_jp^j} \pmod p
$$

问题转化为:

$$
\sum_{i = l}^{r} (\prod_{j = 0} \binom{A_j}{B_j})(\prod_{j = 0} c^{C_j}) \% p
$$

预处理 $g_i = c^i \% p$.

状态 $f_{i, 0/1, 0/1}$, 表示到 $p$ 进制第 $i$ 位, 是否顶界, 是否. (转移的条件细节已省略)

$$
f_{i, 0/1, 0/1} = \sum_k f_{i - 1}{0/1'}{0/1'} * \binom{k}{B_i} * g_k
$$

### 集合幂级数

用一个幂级数表示一个集合的状态, 每一位存一个元素的状态.

### FMT

假设有一个各维度坐标为 $0/1$ 的高维超立方体, 求它顶点的前缀和.

一位一位地考虑, 每次将第 $j$ 位为 $1$ 的下标的元素加上它这一位异或 $1$ 得到的下标代表的元素.

一共是 $n$ 位, 下标范围 $2^n$, 复杂度 $O(n2^n)$.

这个求高维前缀和的过程称为 `FMT`.

### FWT

对一个多项式 $A$ 需要求 $A'$, 规则为:

$$
A'_i = \sum_{j = 0}^{j < 2^n} (-1)^{|i \cap j|} A_j
$$

类似地, 一位一位地考虑, 假设考虑到第 $i$ 位, $j$ 的第 $i$ 位为 $0$. 这时使得 $A_j$ 变成 $A_j + A_{j \oplus {1 << i}}$, $A_{j \oplus {1 << i}}$ 变成 $A_j - A_{j \oplus {1 << i}}$.

这样就能在同样的 $O(n2^n)$ 计算 FWT 了.

### 异或卷积

计算多项式 $C$ 使得

$$
C_i = \sum_{j, k = 0}^{j, k < 2^n} A_jB_k[j\oplus k = i]
$$



## Day24: 期望和概率 DP

### [NOIP2003](https://www.luogu.com.cn/problem/P1040)

中序遍历的一个区间就是一棵子树, 所以将树上问题转化为区间 DP.

$f_{i, j}$ 表示区间 $[i, j]$ 作为一棵子树的最大加分.

$$
f_{i, j} = \max(f_{i, k - 1} * f_{k + 1, j} + a_k)
$$

### [NOIP2008](https://www.luogu.com.cn/problem/P1006)

两条路径同时走, 状态 $f_{i, j, k}$ 表示走了 $i$ 步, 第一条路经走到 $(j, i + 2 - j)$, 第二条路经走到 $(k, i + 2 - k)$ 的最大总和.

$$
f_{i, j, k} = max(f_{i - 1, j, k}, f_{i - 1, j - 1, k}, f_{i - 1, j, k - 1}, f_{i - 1, j - 1, k - 1})
$$

$O(n^3)$ 状态, $O(1)$ 转移.

(这个题貌似费用流也可)

### [NOIP2010](https://www.luogu.com.cn/problem/P1514)

首先可以证明一个输水站覆盖的城市一定是一个连续的区间, 每个点 $(i, j)$ 维护一个左端点 $f_{i, j}$, 一个右端点 $g_{i, j}$, 表示它能覆盖的城市区间. 求出每个蓄水站的区间后, 贪心求解.

### [ZJOI2006](https://www.luogu.com.cn/problem/P2585)

节点 $i$ 存 $f_{i, 0/1/2}$ 表示当前节点选红/绿/蓝的最多绿色数量, $g_{i, 0/1/2}$ 存最少绿色数量.

对于叶子 $i$.

$$
g_{i, 0} = f_{i, 0} = 0\\
g_{i, 1} = f_{i, 1} = 1\\
g_{i, 2} = f_{i, 2} = 0
$$

对于只有一个儿子的节点 $i$.

$$
f_{i, 0} = max(f_{Son_i, 1}, f_{Son_i, 2})\\
f_{i, 1} = max(f_{Son_i, 0}, f_{Son_i, 2}) + 1\\
f_{i, 2} = max(f_{Son_i, 0}, f_{Son_i, 1})\\
g_{i, 0} = min(f_{Son_i, 1}, f_{Son_i, 2})\\
g_{i, 1} = min(f_{Son_i, 0}, f_{Son_i, 2}) + 1\\
g_{i, 2} = min(f_{Son_i, 0}, f_{Son_i, 1})
$$

对于有两个儿子的 $i$.

$$
f_{i, 0} = max(f_{LS_i, 1} + f_{RS_i, 2}, f_{RS_i, 1} + f_{LS_i, 2})\\
f_{i, 1} = max(f_{LS_i, 0} + f_{RS_i, 2}, f_{RS_i, 0} + f_{LS_i, 2}) + 1\\
f_{i, 2} = max(f_{LS_i, 0} + f_{RS_i, 1}, f_{RS_i, 0} + f_{LS_i, 1})\\
g_{i, 0} = min(f_{LS_i, 1} + f_{RS_i, 2}, f_{RS_i, 1} + f_{LS_i, 2})\\
g_{i, 1} = min(f_{LS_i, 0} + f_{RS_i, 2}, f_{RS_i, 0} + f_{LS_i, 2}) + 1\\
g_{i, 2} = min(f_{LS_i, 0} + f_{RS_i, 1}, f_{RS_i, 0} + f_{LS_i, 1})\\
$$

### [NOIP2016](https://www.luogu.com.cn/problem/P1850)

预处理全源最短路, 设计状态 $f_{i, j, 0/1}$, 表示考虑了 $i$ 节课, 申请了 $j$ 节课, $0/1$ 表示第 $i$ 节是否申请.

$$
f_{i, j, 0} = min(f_{i - 1, j, 0} + Dis_{c_{i - 1}, c_i}, f_{i - 1, j, 1} + (1 - k_{i - 1}) * Dis_{c_{i - 1}, c_i} + k_{i - 1} * Dis_{d_{i - 1}, c_i})\\
f_{i, j, 1} = min(f_{i - 1, j - 1, 0} + (1 - k_i) * Dis_{c_{i - 1}, c_i} + k_i * Dis_{c_{i - 1}, d_i},\\
f_{i - 1, j - 1, 1} + (1 - k_{i - 1})(1 - k_i) * Dis_{c_{i - 1}, c_i} + k_{i - 1}(1 - k_i) * Dis_{d_{i - 1}, c_i} +\\
(1 - k_{i - 1})k_i * Dis_{d_{i - 1}, c_i} + k_{i - 1}k_i * Dis_{d_{i - 1}, d_i})
$$

答案即为 $min(f_{n, m, 0}, f_{n, m, 1})$

### [NOIP2014](https://www.luogu.com.cn/problem/P1941)

设计状态 $f_{i, j}$ 为走到第 $i$ 列, 高度为 $j$ 的最少操作数.

$$
\begin{aligned}
f_{i, j} = min(f_{i - 1, j - kx} + k(k \geq 1, j - kx \in [L_{i - 1}, R_{i - 1}]),\\
f_{i - 1, j + y}(j + y \in [L_{i - 1}, R_{i - 1}]])~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&(j \in [L_i, R_i])\\
f_{i, j} = \infty~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&(j < L_i | j > R_i)
\end{aligned}
$$

$O(nm)$ 状态, $O(m)$ 转移. 时间复杂度 $O(nm^2)$, 空间复杂度 $O(nm)$.

用前缀和优化转移到 $O(1)$, 时间优化到 $O(nm)$ 滚动数组优化空间到 $O(m)$.

### [CSP2019](https://www.luogu.com.cn/problem/P5664)

合法方案数 = 总方案数 - 不合法方案数

如果不考虑 $\lfloor \frac n2 \rfloor$ 的限制, 总方案数很好求:

$$
(\prod_{i, j = 1}^{i \leq n, j \leq m} a_{i, j}) - 1
$$

接下来枚举出现次数 $> \lfloor \frac n2 \rfloor$ 的食材, 求出它的出现次数比 $\lfloor \frac n2 \rfloor$ 大的方案数.

假设现在需要求 $x$ 出现次数比 $\lfloor \frac n2 \rfloor$ 大的方案数, 设 $f_{i, j}$ 表示考虑 $i$ 个方法, 第 $x$ 种食材出现次数比其它的食材出现次数总和多 $j$ 的方案数.

$O(nm)$ 预处理 $g_{i} = \sum a_{i, j}$

f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} * a_{i, x} + f_{i - 1, j + 1} * (g_i - a_{i, x})
$$

注意第二维下标整体增加 $\frac n2$, 否则会出现负数下标.

状态 $O(n^2)$, 转移 $O(1)$, 做 $O(m)$ 次, 时间复杂度 $O(n^2m)$

### [COCI2019](https://www.luogu.com.cn/problem/P5307)

第一眼想到的是搜索, 每个点 $(i, j)$ 存 $f_{i, j, k}$, 表示这个点取 $k$ 为乘积的路径数, 这样需要开 $300*300*10^6$ 的数组, 这显然是开不下的.

发现不光可以正着搜索, 也可以倒着搜索, 从正向累乘变成反向除法, 为了证明这么做的正确性, 需要证明 $\lfloor \frac{ \lfloor \frac{n}{a} \rfloor}{b} \rfloor = \lfloor \frac{n}{ab} \rfloor$.

假设 $n = ak_1 + q_1$, $k_1 = bk_2 + q_2$.

所以 $n = a(bk_2 + q_2) + q_1 = abk_2 + aq_2 + q_1$. 因为 $q_2 < b$, 所以 $aq_2 \leq ab - a$, 又因为 $q_1 < a$, 所以 $aq_2 + q_1 < ab$. 

所以 $\lfloor \frac n{ab} \rfloor = k_2 = \lfloor \frac{ \lfloor \frac{n}{a} \rfloor}{b} \rfloor$

所以我只要连续做除法下取整, 得到 $O(\sqrt n)$ 种商, 就可以进行转移.

$$

### [HNOI2007](https://www.luogu.com.cn/problem/P3188)

将物品按 $b$ 排序, 从小到大考虑, 每次容量最多是 $O(a_in) \approx 1000$, 做 $0/1$ 背包.

每次 $b$ 增加, 将背包容量倍增, 数组下标除以 $2$, 丢弃零头.

因为每次做背包容量为 $1000$, 物品共 $100$ 种, 做 $30$ 次, 所以总复杂度约为 $10^7$.

### [NOI2020](https://www.luogu.com.cn/problem/P6775)

### [THUPC2021](https://loj.ac/p/6767)

### [THUPC2018](https://loj.ac/p/6395) 

## Day25: DP 优化

### [HNOI2008](https://www.luogu.com.cn/problem/P3195)

状态 $f_i$ 表示放前 $i$ 个的最小费用.

$$
f_i = min(f_j + (i - j - 1 + (\sum_{k = j + 1}^{i} C_k) - L)^2)
$$

计算前缀和 $Sum_i = \sum_{j = 1}^{i} C_j$

$$
f_i = min(f_j + (i - j - 1 + Sum_i - Sum_{j} - L)^2)
$$

设 $g_i = i + Sum_i$

$$
f_i = min(f_j + (g_i - g_j - 1 - L)^2)
$$

将方程变成函数:

$$
f_i = f_j + (g_i - g_j - 1 - L)^2\\
= f_j + ({g_i}^2 + {g_j}^2 + 1 + L^2 - 2g_jg_i  - 2g_i - 2g_iL + 2g_j + 2g_jL + 2L)\\
= f_j - 2g_jg_i + {g_i}^2 - 2g_i - 2g_iL + {g_j}^2 + 2g_j + 2g_jL + 1 + L^2 + 2L
$$

以 $g_j$ 为自变量, $f_j + {g_j}^2$ 为因变量, $- 1 - L^2 - 2L + f_i - {g_i}^2 + 2g_i + 2g_i$ 为截距, $2g_i - 2 - 2L$ 为斜率:

$$
f_i = f_j - 2g_jg_i + {g_i}^2 - 2g_i - 2g_iL + {g_j}^2 + 2g_j + 2g_jL + 1 + L^2 + 2L\\
f_j + {g_j}^2 = f_i + 2g_jg_i - {g_i}^2 + 2g_i + 2g_iL - 2g_j - 2g_jL - 1 - L^2 - 2L\\
f_j + {g_j}^2 = g_j(2g_i - 2 - 2L) - 1 - L^2 - 2L + f_i - {g_i}^2 + 2g_i + 2g_iL\\
$$

最小化截距以满足转移要求.

维护每个决策点 $(g_j, f_j + {g_j}^2)$ 的下凸包. 因为对于同一个 $i$, 斜率不变, 所以要想使得截距最小, 必须是凸包的下切线可以满足. 每次决策后尝试将自己 $(g_i, f_i + {g_i}^2)$ 加入凸包中.

### [NOI2007](https://www.luogu.com.cn/problem/P4027)

发现每次只要买入或卖出, 一定是梭哈.

每天只有三种情况: All in, All out 或什么都不做.

$f_i$ 表示第 $i$ 天得到的最大收益, 决策是枚举上一次手中是实体货币的日期.

$$
f_i = max(\frac {f_j}{\frac{1}{1 + Rate_j} * A_j + \frac{Rate_j}{1 + Rate_j} * B_j} * (\frac{1}{1 + Rate_j} * A_i + \frac{Rate_j}{1 + Rate_j} * B_i))\\
f_i = max(\frac {f_j}{\frac{A_j + Rate_j * B_j}{1 + Rate_j}} * \frac{A_i + Rate_j * B_i}{1 + Rate_j})\\
f_i = max(\frac {f_j}{A_j + Rate_j * B_j} * (A_i + Rate_j * B_i))\\
f_i = max(\frac {f_j * (A_i + Rate_j * B_i)}{A_j + Rate_j * B_j})\\
$$

转化为函数

$$
f_i = \frac {f_j * (A_i + Rate_j * B_i)}{A_j + Rate_j * B_j}\\
f_i = \frac {f_jA_i + f_jRate_jB_i}{A_j + Rate_j * B_j}\\
\frac{f_i}{B_i} = \frac {\frac{f_jA_i}{B_i} + f_jRate_j}{A_j + Rate_j * B_j}\\
$$

所以将  $\frac {f_j}{A_j + Rate_j * B_j}$ 作为自变量, $\frac {f_jRate_j}{A_j + Rate_j * B_j}$ 作为因变量, $-\frac{A_i}{B_i}$ 为斜率, $\frac{f_i}{B_i}$ 为截距的函数.

$$
\frac {f_jRate_j}{A_j + Rate_j * B_j} = - \frac {\frac{f_jA_i}{B_i}}{A_j + Rate_j * B_j} + \frac{f_i}{B_i}\\
\frac {f_jRate_j}{A_j + Rate_j * B_j} = - \frac {f_jA_i}{B_i(A_j + Rate_j * B_j)} + \frac{f_i}{B_i}\\
$$

这样只要维护凸包, 可以 $O(1)$ 查询 $j < i$ 的 $f_j$ 最大的 $j$, 每次用和以 $-\frac{A_i}{B_i}$ 为斜率的直线相切的切点做本次决策, 截距乘上 $B_i$ 即为所求 $f_i$, 然后再将 $(\frac {f_j}{A_j + Rate_j * B_j}, \frac {f_jRate_j}{A_j + Rate_j * B_j})$ 插入凸包.

由于需要支持随机插入和动态查询, 我们选择平衡树维护凸包.

### [HDU6800](https://acm.hdu.edu.cn/showproblem.php?pid=6800)

$f_{i, j}$ 表示计算了 $i$ 个点, 和第 $i$ 个点不是一个子序列的最后一个点是 $j$ 的最小距离和.

### 某题

部分确定的一个排列中填入剩余部分, 使得最长上升子序列最长.

仍然定义 $f_i$ 表示第 $i$ 个确定的位置为结尾的最长上升子序列的长度, $Cnt_i$ 表示第 $i$ 个确定的数前面未被确定的位置数量, $UnA_i$ 表示比 $i$ 小的未确定的数.

$$
f_{i} = \max_{j = 0}^{j < i}(f_{j} + min(Cnt_i - Cnt_j), UnA_{a_i} - UnA_{a_j})
$$


### [HAOI2018](https://www.luogu.com.cn/problem/P4491)


### [EPOI2018](https://www.luogu.com.cn/problem/P4383) 

转化为树上选 $k + 1$ 条不相交的链使得总收益最大.

发现可以树形 DP, 

### [IOI2000](https://www.luogu.com.cn/problem/P6246)

[原版](https://www.luogu.com.cn/blog/Wild-Donkey/luogu4767-ioi2000-you-ju)

加强版: 

### []()

求树上每个子树深度相同点对数.

长链剖分 + 启发式合并

### [NOIP2018](https://www.luogu.com.cn/problem/P5021)

### [CF1416E](https://www.luogu.com.cn/problem/CF1416E)

一开始设计 $f_{i, j}$ 表示枚举到 $a_i$, $b_{2i} = j$ 的时候, 合并后 $b$ 的最小长度.

$$
f_{i, j} = f_{i - 1, a_i - j} + 1, f_{i - 1, k})\\
f_{i, j}
$$

## Day26: ACM

### A

费用流, 竟然没看出来.



### B

由于每条路可以从任意位置调头, 所以只要在一条边上反复横跳就可以凑出任何长度, 所以下界形同虚设, 如果一条路径不合法, 任意地方迂回两步就凑够了.

所以只要保证在上界范围内, 走出去能回得来就行了, 所以一条边可以经过当且仅当它的一个端点到 $0$ 点的最短路比上界的一半要小即可.

对于使答案最大, 我们一定每次只探索一条边, 为了达到下界, 我们在起点附近迂回. 所以最后答案就是所有能到达的边数.

跑最短路即可, ACM 可以直接复制板子.

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[10005];
struct Edge;
struct Node {
  unsigned Dis;
  Edge *Fst;
  char InQue; 
}N[100005];
struct Edge {
  unsigned Val;
  Node *To;
  Edge *Nxt;
}E[400005], *CntE(E);
void Link(Node *x, Node *y) {
  (++CntE)->Nxt = x->Fst;
  x->Fst = CntE;
  CntE->To = y;
  CntE->Val = C;
}
struct Pnt{
  Node *P;
  unsigned Dist;
  const inline char operator <(const Pnt &x) const{
    return this->Dist > x.Dist;
  }
}TmpP;
priority_queue<Pnt> Q;
int main() {
  n = RD(), m = RD(), RD(), D = RD();
  for (register unsigned i(1); i <= m; ++i) {
    A = RD(), B = RD(), C = RD();
    Link(N + A, N + B);
    Link(N + B, N + A);
  }
  for (register unsigned i(1); i <= n; ++i) {
    N[i].Dis = 0x3f3f3f3f;
  }
  N[0].Dis = 0, TmpP.P = N, Q.push(TmpP);
  while (Q.size()) {
    register Node *Now((Q.top()).P); Q.pop();
    if(Now->InQue) continue;
    Now->InQue = 1;
    Edge *Sid(Now->Fst);
    while (Sid) {
      if(Sid->To->Dis > Now->Dis + Sid->Val) {
        Sid->To->Dis = Now->Dis + Sid->Val;
        TmpP.Dist = Sid->To->Dis, TmpP.P = Sid->To, Q.push(TmpP);
      }
      Sid = Sid->Nxt;
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if((min((E[i << 1].To)->Dis, (E[(i << 1) - 1].To)->Dis) << 1) < D) {
      ++Ans;
    }
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### C

最签到题, 给 $n$ 种需要的原料分别的需求量和持有量, 求一共能生产多少产品.

我们可以给每个原料持有量除以需求量下取整取最小值. 轻松写意又从容.

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0x3f3f3ff3), Tmp(0);
char b[10005];
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    A = RD(), B = RD();
    Ans = min(Ans, B/A);
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

### D

构造二叉树, 编号满足大根堆性质, 求 $Q$ 为叶子的方案数.

根据容斥, $Q$ 为叶子方案数是总方案数减 $Q$ 不为叶子的方案数.

### E

赛时设计的 $O(n^3)$ 状态 $O(1)$ 转移的奇妙 DP, $f_{i, j, k}$ 表示前 $i$ 个音符, 击打 $j$ 个, 到 $i$ 为止连击 $k$ 次的最大收益.

但是非常遗憾, 它的状态复杂度就注定了没有前途.

而正解则是两维 $f_{i, j}$ 表示了考虑前 $i$ 个音符, 漏掉了 $j$ 个的最大收益. 转移 $O(n)$. 为了方便表示, 我们用 $g_{k, i}$ 预处理 $[k, i]$ 连击的收益.

$$
f_{i, j} = max(f_{k - 2, j - 1} + g_{k, i})
$$

但是很遗憾这还是 $O(n^3)$ 的复杂度.

达标得到这个 DP 满足四边形不等式, 可以决策单调性优化, 所以可以二分转移, 总复杂度 $O(n^2 \log n)$.

### F

给 $n$ 行字符串, 按每行出现的次数和出现顺序排序, 按顺序输出出现次数最大的 $m$ 个本质不同的行, 如果有相同出现次数的, 优先输出出现晚的. 如果本质不同的行不足 $m$ 个, 则按顺序输出全部.

复杂度 $O(wn \log n)$, 大概 $8 * 10^7$, 能过. (不过大水题写那么长确实非常丢脸)

```cpp
struct Str {
  char b[55];
  unsigned Rak;
  inline const char operator < (const Str &x) const {
    register char i(1);
    while ((this->b[i] == x.b[i]) && (this->b[i] > 20)) {
      ++i;
    }
    if(this->b[i] == x.b[i]) {
      return this->Rak < x.Rak;
    }
    return this->b[i] < x.b[i];
  }
  inline const char operator == (const Str &x) const {
    register char i(1);
    while (this->b[i] == x.b[i] && (this->b[i] > 20)) {
      ++i;
    }
    return this->b[i] == x.b[i];
  }
}S[100005];
struct Pos {
  unsigned P;
  inline const operator < (const Pos &x) const{
    return S[this->P].Rak > S[x.P].Rak;
  }
};
vector<Pos> V[100005];
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char Ch(0);
int main() {
  n = RD() * 3, m = RD();
  for (register unsigned i(1), j(0); i <= n; ++i) {
    j = 0;
    do {
      S[i].b[++j] = getchar();
    }while(S[i].b[j] > 20);
    S[i].Rak = i;
  }
  sort(S + 1, S + n + 1);
  Cnt = 1;
  for (register unsigned i(2); i <= n + 1; ++i) {
    register Pos O;
    if(S[i - 1] == S[i]) {
      ++Cnt;
    } else {
      O.P = i - 1;
      V[Cnt].push_back(O);
      Cnt = 1;
    }
  }
  for (register unsigned i(n); i; --i) {
    if(V[i].size()) {
      sort(V[i].begin(), V[i].end());
      if(V[i].size() <= m) {
        for (register unsigned j(0); j < V[i].size(); ++j) {
          printf("%s", (S[V[i][j].P].b) + 1);
        }
        m -= V[i].size();
      } else {
        for (register unsigned j(0); j < m; ++j) {
          printf("%s", (S[V[i][j].P].b) + 1);
        }
        m = 0;
      }
    }
    if(!m) break;
  }
  return Wild_Donkey;
}
```

### G

首先前置欧拉公式

$$
V - E + F = 1 + 连通块个数
$$

因为已经输入了 $V$, $E$, $F$ 所以可以求出连通块个数 $L$.

选择构造 $L - 1$ 个单点, 剩下 $V - L + 1$ 个点, $E$ 条边组成一个平面图.

$n$ 个点的平面图最多有 $3n - 6$ 条边, 需要构造 $V$ 个点, $E$ 条边的平面图.

构造方式是先取 $3$ 个点的平面图, 每次在外面加一个点, 往凸包上三个点连边.

由于 $V \geq 3$ 的边最多的平面图一定是三角形, 所以选一个棋盘内最大的三角形作为轮廓.

### H

这个题很容易想到二分, 但是判定一个二分的半径是否可行成了需要考虑的最大问题.

将两点之间不能走抽象为两点之间连边, 而连边的条件就是两点距离的一半小于等于二分的半径. 其意义不是通路, 而是防止经过的墙壁.

左边界和上边界可以抽象成一个点, 右边界和下边界也可以抽象成一个点. 那么从左上往右下走, 如果存在一条通路, 则这条通路已经将棋盘分割成左下和右上两个部分, 不能互相到达, 所以只要判断按照二分的距离连边, 左上右下两个点是否连通即可.

但是如果是二分 $10^6$ 并且得到 $10^{-5}$ 的精度, 最坏需要二分 $\log_2 10^{11}$ 次, 需要 $36$ 次, 而本题有 $1000$ 个点, 每次判定是 $O(n^2)$, 而 $3.6 * 10^7$ 的浮点数比较会比较悬.

我们发现答案一定是某一对点的距离, 因为如果不是两个点的距离, 那么对答案进行细微的扰动是不会影响任何边的连接情况的, 也就不会改变连通性. 所以我们只要将所有边权离散后二分所有存在的边权即可, 最劣次数是 $\log_2 10^6 = 20$ 次.

而判连通性也没必要提前连边, 我们只要在 DFS 过程中现判断一个点能否到达即可. 这就不至于每次判定会将 $O(n^2)$ 跑满了.

所以优化到带剪枝的 $O(n^2 \log n^2)$ 就可以稍微放心地提交了.

```cpp
float W, H, Pos[1005][2], Dist[1005][1005], Tmp[520005], Frtr;
unsigned a[1005][1005], m, n, Cnt(0), A, B, C, D, t, Ans(0);
char Vis[1005], Flg;
inline float Dis (unsigned x, unsigned y) {
  register float X(Pos[x][0] - Pos[y][0]), Y(Pos[x][1] - Pos[y][1]);
  return sqrt((X * X) + (Y * Y));
}
void DFS(unsigned x) {
  Vis[x] = 1;
  if(x == n + 1) {
    Flg = 1;
    return;
  }
  for (register unsigned i(0); i <= n + 1; ++i) {
    if((!(Vis[i])) && (Dist[x][i] <= Frtr)) {
      DFS(i);
    }
  }
  return;
}
int main() {
  scanf("%f%f", &W, &H);
  n = RD();
  Dist[0][0] = 10000000;
  for (register unsigned i(1); i <= n; ++i) {
    scanf("%f%f", &Pos[i][0], &Pos[i][1]);
    Dist[i][i] = 10000000;
    Dist[0][i] = Dist[i][0] = Tmp[++Cnt] = min(Pos[i][0], H - Pos[i][1]);
    Dist[n + 1][i] = Dist[i][n + 1] = Tmp[++Cnt] = min(Pos[i][1], W - Pos[i][0]);
  }
  Dist[n + 1][0] = Dist[0][n + 1] = 10000000;
  for (register unsigned i(2); i <= n; ++i) {
    for (register unsigned j(1); j < i; ++j) {
      Tmp[++Cnt] = Dist[i][j] = Dist[j][i] = Dis(j, i) / 2;
    }
  }
  sort(Tmp + 1, Tmp + Cnt + 1);
  Cnt = unique(Tmp + 1, Tmp + Cnt + 1) - Tmp - 1;
  register unsigned L(1), R(Cnt), Mid;
  while (L ^ R) {
    Mid = ((L + R) >> 1);
    Flg = 0;
    memset(Vis, 0, sizeof(Vis));
    Frtr = Tmp[Mid];
    DFS(0);
    if(Flg) {
      R = Mid;
    } else {
      L = Mid + 1;
    }
  }
  printf("%.6f\n", Tmp[L]);
  return Wild_Donkey;
}
```

但是我们仍然可以继续优化, 将所有边按连接权值从小到大排序, 利用类似 Kruskal 的方法每次连接最小的边, 然后判 $0$ 到 $n + 1$ 的连通性, 然后使用并查集维护连通性即可. 答案就是连通的时候最后加入的边权. 这样虽然时间仍然是 $O(n^2 \log n^2)$, 但是对于随机数据, `sort` 的期望复杂度往往更接近线性.

### I

是 Nim 游戏的板子, 每个横着的格子中间的空地可以看成是石子, 每个横着的格子看作一堆石子. (貌似可以证明, 但是我不会, 之后应该会有专门的博客来证吧)

这样就可以将所有长度 $-2$ 之后的值异或起来. 结果为 $0$ 则先手必败, 否则必胜, 因为先手总能将局面变成异或起来为 $0$ 的局面, 使得对手变成必败态.

令人难受的是, 场上推了 $2H$ 的式子和结论, 甚至打了好几把这个游戏, 如果最后不知道是 Nim 博弈, 我们都准备将这个游戏作为茶余饭后的消遣小游戏了...

```cpp
unsigned a[10005], m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[10005];
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    Ans ^= RD() - 2;
  }
  scanf("%s", b + 1);
  if(Ans) Ans = 1;
  if(b[1] == 'W') {
    ++Ans;
  }
  printf((Ans & 1) ? "Blackking\n" : "Whiteking\n");
  return Wild_Donkey;
}
```

### J



### K

给两个矩阵, 按要求取反点, 使得第二个矩阵和第一个相同.

每个矩阵保证:

- 边界的一圈同色

- 联通的定义是四连通, 不存在 $\frac {*|.}{.|*}$ 或 $\frac {.|*}{*|.}$ 的情况

- 保证每个连通块最多只相邻两个连通块, 对于边界连通块, 仅相邻一个连通块

要求翻转过程中, 不出现连通块数量和相邻关系改变的情况, 任何时刻的矩阵都要满足输入的三个条件.

发现符合要求的局面一定是一个连通块套另一个连通块...以此类推.

所以可以使用 BFS 找出连通块和相邻关系, 这样就能很方便地判解的有无, 然后将其抽象为一个一圈一圈的图. 每圈代表一个连通块.

因为一个点可以反转多次, 所以不妨先将两个矩阵变换到理想的中间态, 然后将第一个矩阵的变换序列反转, 拼到第二个矩阵的序列后面就是答案.

而变换到中间态也很简单, 只要从外到内, 一格一格扩张到自己该到达的边界即可. (注意只扩展那些不会产生新连通块的格子)

### L

据说是稳定婚姻问题的裸题, 但是很遗憾没有翻译到.

### M

又是构造, 同样没翻译.

## Day27: 模拟赛

### A

给一个 DAG, 要求有序对 $(a, b)$ 使得存在一个 $c$, 既能到达 $a$, 又能到达 $b$. 数据保证点的编号就是拓扑序.

首先想到的是将所有入度为 $0$ 的点作为 $c$, 因为如果对于点对 $(a, b)$ 的 $c$, 能连向它的点一定也能做这个 $c$. 所以合法答案中所有点对的 $c$ 都可以是一个入度为 $0$ 的点.

将从某个 $c$ 出发能到达的所有点存到一个数组中, 然后 $O(n^2)$ 得到所有点对, 将对应的二维数组的位置置为 $1$.

$O(n)$ 个源点, 每个源点 $O(n^2)$ 扫描, 复杂度 $O(n^3)$.

`70'.cpp`

```cpp
unsigned List[3005], Hd(0), Tl(0), m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b[3005][3005];
struct Edge;
struct Node {
  Edge *Fst;
  unsigned Deg, Topo, Vis, Size, Tms;
}N[3005];
struct Edge {
  Node *To;
  Edge *Nxt;
}E[3005];
unsigned DFS1 (Node *x) {
  List[++Cnt] = x - N;
  register Edge *Sid(x->Fst);
  if(!Sid) {
    return 1;
  }
  register unsigned TmSz(1);
  while (Sid) {
    if(!(Sid->To->Vis)) {
      Sid->To->Vis = 1;
      TmSz += DFS1(Sid->To);
    }
    Sid = Sid->Nxt;
  }
}
inline void Clr() {
  memset(b, 0, sizeof(b));
  memset(N, 0, sizeof(N));
  memset(E, 0, sizeof(E));
  Ans = 0;
}
int main() {
  t = RD();
  for (register unsigned T(1); T <= t; ++T){
    Clr();
    n = RD(), m = RD();
    for (register unsigned i(1); i <= m; ++i) {
      A = RD(), B = RD();
      E[i].Nxt = N[A].Fst;
      N[A].Fst = E + i;
      ++(N[B].Deg);
      E[i].To = N + B;
    }
    for (register unsigned i(1); i <= n; ++i) {
      if(!(N[i].Deg)) {
        Cnt = 0;
        DFS1(N + i);
        for (register unsigned j(1); j <= n; ++j) {
          N[j].Vis = 0;
        }
        for (register unsigned j(1); j <= Cnt; ++j) {
          b[List[j]][List[j]] = 1;
          for (register unsigned k(j + 1); k <= Cnt; ++k) {
            b[List[j]][List[k]] = b[List[k]][List[j]] = 1;
          }
        }
      }
    }
    for (register unsigned i(1); i <= n; ++i) {
      for (register unsigned j(1); j <= n; ++j) {
        Ans += b[i][j];
      }
    }
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

正解考虑 DP, 发现有一个条件还没使用, 就是点的拓扑序是编号. 设布尔变量 $f_{i, j}$ 表示 $(i, j)$ 点对合法.

接下来枚举 $i$, $j$ 转移即可, 因为只要 $(i, j)$ 合法, 那么对于任何 $i$ 能到达的 $i'$, $j$ 能到达的 $j'$, 都有 $(i', j')$ 合法.

所以按拓扑序转移即可. 复杂度 $O(n(n + m))$.

```cpp
unsigned m, n, Cnt(0), A, B, C, D, t, Ans(0);
char f[3005][3005];
struct Edge {
  unsigned To;
  Edge *Nxt;
}E[3005], *Fst[3005];
inline void Clr() {
  memset(f, 0, sizeof(f));
  memset(Fst, 0, sizeof(Fst));
  Ans = 0;
}
int main() {
  t = RD();
  for (register unsigned T(1); T <= t; ++T){
    Clr();
    n = RD(), m = RD();
    for (register unsigned i(1); i <= m; ++i) {
      A = RD(), B = RD();
      E[i].Nxt = Fst[A];
      Fst[A] = E + i;
      E[i].To = B;
    }
    for (register unsigned i(1); i <= n; ++i) {
      f[i][i] = 1;
      for (register unsigned j(1); j <= n; ++j) {
        if(f[i][j]) {
          ++Ans;
          register Edge *Sid(Fst[j]);
          register unsigned Son;
          while (Sid) {
            Son = Sid->To;
            f[i][Son] = f[Son][i] = f[j][Son] = f[Son][j] = 1; 
            Sid = Sid->Nxt;
          }
        }
      }
    }
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

### B

每个物品可以放到 $a_i$ 筐中, 也能放到 $b_i$ 筐中. 求如何使得筐中有奇数物品的筐最小.

每个筐看作一个点, 每个物品当作一条边, 连接 $a_i$, $b_i$. 对于一个连通块, 我们尝试将有端点相同的节点配对然后同时删除, 意义是将两个物品同时放入一个筐中, 发现存在策略使得连通块最后只剩 $0$ 或 $1$ 条边.

删边策略是: 以任意点为根生成一棵 DFS 树, 这棵树存在三种边, 树边, 自环边, 回边 (树边如果有重边, 则除了第一次经过的树边, 其余算作回边), 从叶子开始考虑. 对于一个叶子, 如果它的自环边和回边数量是偶数, 就直接将自环边和回边删除, 否则删除的同时还要带上连接父亲的边. 考虑完叶子回溯到它的父亲 $x$, 这时 $x$ 可能连着 $4$ 种边, 连接 $x$ 的父亲的树边, 连接 $x$ 的儿子的树边, 回边, 自环边. 因为这时如果还有儿子边, 儿子就只剩一个单点了, 讨论后三种边的数量, 如果是偶数就直接删除, 如果是奇数就带上连接父亲的树边. 这样每次讨论一个点就必定删除偶数条边, 到了根, 如果出现了需要带上连接父亲边的情况, 这时删除偶数条边后, 会剩下一条. 

这种只剩一条边的情况出现, 唯一的条件是连通块的总边数是奇数. 所以我们只要统计每个连通块的边数 $\And 1$ 的总和即可.

```cpp
unsigned m, n, Cnt(0), A, B, Ans(0);
struct Edge;
struct Node {
  Edge *Fst;
  char Vis; 
}N[200005];
struct Edge {
  Node *To;
  Edge *Nxt;
}E[400005], *CntE(E);
void Link(Node *x, Node *y) {
  (++CntE)->Nxt = x->Fst;
  x->Fst = CntE;
  CntE->To = y;
}
void DFS(Node *x) {
  x->Vis = 1;
  register Edge *Sid(x->Fst);
  while (Sid) {
    ++Cnt;
    if(!(Sid->To->Vis)) {
      DFS(Sid->To);
    }
    Sid = Sid->Nxt;
  }
}
int main() {
  n = RD(), m = RD();
  for (register unsigned i(1); i <= n; ++i) {
    A = RD(), B = RD();
    Link(N + A, N + B);
    Link(N + B, N + A);
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!N[i].Vis) {
      Cnt = 0;
      DFS(N + i);
      Ans += ((Cnt >> 1) & 1);
    }
  }
  printf("%u\n", Ans);
}
```

与此同时, 不建图, 仅用并查集维护连通块, 貌似可以得到更优的常数.

### C

$f_{a_1, a_2, a_3, a_4}$ 代表已经选了 $a_1$ 个 $2$, $a_2$ 个 $3$, $a_3$ 个 $4$, $a_4$ 个 $5$ 的最少纸币.

我们知道对于 $f_{a_1, a_2, a_3, a_4}$ 的答案中, 前 $a_1 + a_2 + a_3 + a_4$ 种纸币凑出了 $n \% (2^{a_1}3^{a_2}4^{a_3}5^{a_4})$ 的钱, 剩下的钱用 $\frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4}}$ 张第 $a_1 + a_2 + a_3 + a_4 + 1$ 种纸币凑出.

转移要枚举本次选哪个数, 然后转移即可.

$$
\begin{aligned}
&f_{a_1, a_2, a_3, a_4} = min(\\
&f_{a_1 - 1, a_2, a_3, a_4} - \frac{n}{2^{a_1 - 1}3^{a_2}4^{a_3}5^{a_4}} + \frac{n}{2^{a_1 - 1}3^{a_2}4^{a_3}5^{a_4}} \% 2,\\
&f_{a_1, a_2 - 1, a_3, a_4} - \frac{n}{2^{a_1}3^{a_2 - 1}4^{a_3}5^{a_4}} + \frac{n}{2^{a_1}3^{a_2 - 1}4^{a_3}5^{a_4}} \% 3,\\
&f_{a_1, a_2, a_3 - 1, a_4} - \frac{n}{2^{a_1}3^{a_2}4^{a_3 - 1}5^{a_4}} + \frac{n}{2^{a_1}3^{a_2}4^{a_3 - 1}5^{a_4}} \% 4,\\
&f_{a_1, a_2, a_3, a_4 - 1} - \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4 - 1}} + \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4 - 1}} \% 5\\
&) + \frac{n}{2^{a_1}3^{a_2}4^{a_3}5^{a_4}}
\end{aligned}
$$

但是细节有亿点点多, 所以有了这般地狱绘图:

```cpp
unsigned long long g[70][70][70][70], f[70][70][70][70];
unsigned long long m, Ans(0x3f3f3f3f3f3f3f3f), Tmp;
int main() {
  g[0][0][0][0] = RD(), m = RD() - 1;
  for (register unsigned i(1); i <= m; ++i) {
    g[i][0][0][0] = g[i - 1][0][0][0] / 2;
    g[0][i][0][0] = g[0][i - 1][0][0] / 3;
    g[0][0][i][0] = g[0][0][i - 1][0] / 4;
    g[0][0][0][i] = g[0][0][0][i - 1] / 5;
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      g[i][j][0][0] = g[i][j - 1][0][0] / 3;
      g[i][0][j][0] = g[i][0][j - 1][0] / 4;
      g[i][0][0][j] = g[i][0][0][j - 1] / 5;
      g[0][i][j][0] = g[0][i][j - 1][0] / 4;
      g[0][i][0][j] = g[0][i][0][j - 1] / 5;
      g[0][0][i][j] = g[0][0][i][j - 1] / 5;
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        g[i][j][k][0] = g[i][j][k - 1][0] / 4;
        g[i][j][0][k] = g[i][j][0][k - 1] / 5;
        g[i][0][j][k] = g[i][0][j][k - 1] / 5;
        g[0][i][j][k] = g[0][i][j][k - 1] / 5;
        if(!g[i][j][k][0]) break;
        for (register unsigned l(1); l + k + j + i <= m; ++l) {
          g[i][j][k][l] = g[i][j][k][l - 1] / 5;
          if(!g[i][j][k][l]) break;
        }
      }
    }
  }
  memset(f, 0x3f, sizeof(f));
  f[0][0][0][0] = g[0][0][0][0];
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    f[i][0][0][0] = min(f[i][0][0][0], f[i - 1][0][0][0] - g[i - 1][0][0][0] + g[i - 1][0][0][0] % 2 + g[i][0][0][0]);
    f[0][i][0][0] = min(f[0][i][0][0], f[0][i - 1][0][0] - g[0][i - 1][0][0] + g[0][i - 1][0][0] % 3 + g[0][i][0][0]);
    f[0][0][i][0] = min(f[0][0][i][0], f[0][0][i - 1][0] - g[0][0][i - 1][0] + g[0][0][i - 1][0] % 4 + g[0][0][i][0]);
    f[0][0][0][i] = min(f[0][0][0][i], f[0][0][0][i - 1] - g[0][0][0][i - 1] + g[0][0][0][i - 1] % 5 + g[0][0][0][i]);
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      f[i][j][0][0] = min(f[i][j][0][0], f[i][j - 1][0][0] - g[i][j - 1][0][0] + g[i][j - 1][0][0] % 3 + g[i][j][0][0]);
      f[i][j][0][0] = min(f[i][j][0][0], f[i - 1][j][0][0] - g[i - 1][j][0][0] + g[i - 1][j][0][0] % 2 + g[i][j][0][0]);
      f[i][0][j][0] = min(f[i][0][j][0], f[i][0][j - 1][0] - g[i][0][j - 1][0] + g[i][0][j - 1][0] % 4 + g[i][0][j][0]);
      f[i][0][j][0] = min(f[i][0][j][0], f[i - 1][0][j][0] - g[i - 1][0][j][0] + g[i - 1][0][j][0] % 2 + g[i][0][j][0]);
      f[i][0][0][j] = min(f[i][0][0][j], f[i][0][0][j - 1] - g[i][0][0][j - 1] + g[i][0][0][j - 1] % 5 + g[i][0][0][j]);
      f[i][0][0][j] = min(f[i][0][0][j], f[i - 1][0][0][j] - g[i - 1][0][0][j] + g[i - 1][0][0][j] % 2 + g[i][0][0][j]);
      f[0][i][j][0] = min(f[0][i][j][0], f[0][i][j - 1][0] - g[0][i][j - 1][0] + g[0][i][j - 1][0] % 4 + g[0][i][j][0]);
      f[0][i][j][0] = min(f[0][i][j][0], f[0][i - 1][j][0] - g[0][i - 1][j][0] + g[0][i - 1][j][0] % 3 + g[0][i][j][0]);
      f[0][i][0][j] = min(f[0][i][0][j], f[0][i][0][j - 1] - g[0][i][0][j - 1] + g[0][i][0][j - 1] % 5 + g[0][i][0][j]);
      f[0][i][0][j] = min(f[0][i][0][j], f[0][i - 1][0][j] - g[0][i - 1][0][j] + g[0][i - 1][0][j] % 3 + g[0][i][0][j]);
      f[0][0][i][j] = min(f[0][0][i][j], f[0][0][i][j - 1] - g[0][0][i][j - 1] + g[0][0][i][j - 1] % 5 + g[0][0][i][j]);
      f[0][0][i][j] = min(f[0][0][i][j], f[0][0][i - 1][j] - g[0][0][i - 1][j] + g[0][0][i - 1][j] % 4 + g[0][0][i][j]);
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        f[i][j][k][0] = min(f[i][j][k][0], f[i][j][k - 1][0] - g[i][j][k - 1][0] + g[i][j][k - 1][0] % 4 + g[i][j][k][0]);
        f[i][j][k][0] = min(f[i][j][k][0], f[i][j - 1][k][0] - g[i][j - 1][k][0] + g[i][j - 1][k][0] % 3 + g[i][j][k][0]);
        f[i][j][k][0] = min(f[i][j][k][0], f[i - 1][j][k][0] - g[i - 1][j][k][0] + g[i - 1][j][k][0] % 2 + g[i][j][k][0]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i][j][0][k - 1] - g[i][j][0][k - 1] + g[i][j][0][k - 1] % 5 + g[i][j][0][k]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i][j - 1][0][k] - g[i][j - 1][0][k] + g[i][j - 1][0][k] % 3 + g[i][j][0][k]);
        f[i][j][0][k] = min(f[i][j][0][k], f[i - 1][j][0][k] - g[i - 1][j][0][k] + g[i - 1][j][0][k] % 2 + g[i][j][0][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i][0][j][k - 1] - g[i][0][j][k - 1] + g[i][0][j][k - 1] % 5 + g[i][0][j][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i][0][j - 1][k] - g[i][0][j - 1][k] + g[i][0][j - 1][k] % 4 + g[i][0][j][k]);
        f[i][0][j][k] = min(f[i][0][j][k], f[i - 1][0][j][k] - g[i - 1][0][j][k] + g[i - 1][0][j][k] % 2 + g[i][0][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i][j][k - 1] - g[0][i][j][k - 1] + g[0][i][j][k - 1] % 5 + g[0][i][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i][j - 1][k] - g[0][i][j - 1][k] + g[0][i][j - 1][k] % 4 + g[0][i][j][k]);
        f[0][i][j][k] = min(f[0][i][j][k], f[0][i - 1][j][k] - g[0][i - 1][j][k] + g[0][i - 1][j][k] % 3 + g[0][i][j][k]);
      }
    }
  }
  for (register unsigned i(1); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(1); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(1); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        for (register unsigned l(1); l + k + j + i <= m; ++l) {
          if(!g[i][j][k][l]) break;
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j][k][l - 1] - g[i][j][k][l - 1] + g[i][j][k][l - 1] % 5 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j][k - 1][l] - g[i][j][k - 1][l] + g[i][j][k - 1][l] % 4 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i][j - 1][k][l] - g[i][j - 1][k][l] + g[i][j - 1][k][l] % 3 + g[i][j][k][l]);
          f[i][j][k][l] = min(f[i][j][k][l], f[i - 1][j][k][l] - g[i - 1][j][k][l] + g[i - 1][j][k][l] % 2 + g[i][j][k][l]);
        }
      }
    }
  }
  for (register unsigned i(0); i <= m; ++i) {
    if(!g[i][0][0][0]) break;
    for (register unsigned j(0); j + i <= m; ++j) {
      if(!g[i][j][0][0]) break;
      for (register unsigned k(0); k + j + i <= m; ++k) {
        if(!g[i][j][k][0]) break;
        for (register unsigned l(0); l + k + j + i <= m; ++l) {
          if(!g[i][j][k][l]) break;
          Ans = min(Ans, f[i][j][k][l]);
        }
      }
    }
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

但是因为不满冗长的预处理和奇妙的转移, 改变转移的顺序, 让代码变成这副模样, 成功将常数压缩 $6$ 倍.

```cpp
unsigned long long f[70][40][35][30], m, n, Ans(0x3f3f3f3f3f3f3f3f);
int main() {
  n = RD(), m = RD() - 1;
  memset(f, 0x3f, sizeof(f));
  f[0][0][0][0] = n;
  for (register unsigned long long i(0), Gi(n); (i <= m) && (Gi); ++i) {
    for (register unsigned long long j(0), Gj(Gi); (j + i <= m) && (Gj); ++j) {
      for (register unsigned long long k(0), Gk(Gj); (k + j + i <= m) && (Gk); ++k) {
        for (register unsigned long long l(0), Gl(Gk); (l + k + j + i <= m) && (Gl); ++l) {
          Ans = min(Ans, f[i][j][k][l]);
          f[i + 1][j][k][l] = min(f[i + 1][j][k][l], f[i][j][k][l] - (Gl >> 1));
          f[i][j + 1][k][l] = min(f[i][j + 1][k][l], f[i][j][k][l] - ((Gl / 3) << 1));
          f[i][j][k + 1][l] = min(f[i][j][k + 1][l], f[i][j][k][l] - (Gl >> 2) * 3);
          f[i][j][k][l + 1] = min(f[i][j][k][l + 1], f[i][j][k][l] - ((Gl / 5) << 2));
          Gl /= 5;
        }
        Gk >>= 2;
      }
      Gj /= 3;
    }
    Gi >>= 1;
  }
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

### D

场上写的是 $O({n^2}^{n^2})$ 的巨大爆搜, 

## Day28: 基础数论

### 欧拉函数

设 $p_i$ 为一个质数, $\displaystyle{x = \prod_{i}^{a_i > 0} {p_i}^{a_i}}$, 则欧拉函数可以表示为:

$$
\phi(x) = \frac{x}{\displaystyle{\prod_{i}^{a_i > 0}(p_i - 1)}}
$$

$\phi$ 是积性函数, 因为对于互质的 $x$ 和 $y$, 它们没有公共质因数, 所以有:

$$
\begin{aligned}
&~~~~~~\phi(x)\phi(y)\\
& = \frac{x}{\displaystyle{\prod_{i}^{a_i > 0}(p_i - 1)}} \times \frac{y}{\displaystyle{\prod_{i}^{b_i > 0}(p_i - 1)}}\\
& = \frac{xy}{\displaystyle{\prod_{i}^{a_i > 0 \lor b_i > 0}(p_i - 1)}}\\
& = \phi(xy)
\end{aligned}
$$

### 欧拉定理

对于互质的 $a$, $p$, 有:

$$
a^{\phi(p)} \% p = 1
$$

所以就有:

$$
a^{b} \% p = a^{b \% \phi(p)} % p
$$

### 扩展欧拉定理

对于 $a$, $p$ 不互质的情况:

$$
\begin{aligned}
a^b \% p = a^{b \% \phi(p)} \% p~~~~~&(gcd_{a, p} = 1)\\
a^b \% p = a^b \% p~~~~~&(gcd_{a, p} \neq 1, b < \phi(p))\\
a^b \% p = a^{b \% \phi(p) + \phi(p)}\% p~~~~~&(gcd_{a, p} \neq 1, b \geq \phi(p))
\end{aligned}
$$

### 埃氏筛

扫描正整数, 一个数没有被筛过, 则它是质数, 对于每一个质数, 筛出它的所有倍数. 时间复杂度 $O(n\log(\log n))$.

### 欧拉筛

仍然扫描, 但是一个质数 $p$ 筛别的数的时候, 如果 $p$ 不是待筛的数的最大质因子, 则停止. 这样可以保证一个数仅被筛掉一次, 也就是被它的最大质因数筛掉.

为了在 $p$ 不是最大质因数的时候跳出, 当和 $p$ 相乘的因数能被 $p$ 整除的时候跳出即可.

### 求 $\binom {n}{m}$ 中 $p$ 的幂次

分别求 $n!$, $m!$ 和 $(n - m)!$ 中 $p$ 的幂次, 然后做减法即可.

如何求阶乘的幂次, 用 $n$ 不断除以 $p$, 则 $n!$ 中 $p$ 的幂次可以表示为:

$$
\sum_{i \geq 1} \lfloor \frac {n}{p^i} \rfloor
$$

所以答案就是

$$
\sum_{i \geq 1} (\lfloor \frac {n}{p^i} \rfloor - \lfloor \frac {m}{p^i} \rfloor - \lfloor \frac {n - m}{p^i} \rfloor)
$$

尝试发现 $p$ 的幂次的新意义.


$$
\begin{aligned}
m &= a_1p^i + r_1~(r_1 < p^i)\\
n - m &= a_2p^i + r_2~(r_2 < p^i)\\
n &= (a_1 + a_2)p^i + r_1 + r_2\\
n &= a_3p^i + r_3\\
r_3 &= (r_1 + r_2) \% p^i\\
a_3 &= a_1 + a_2 + \lfloor \frac {r_1 + r_2}{p^i} \rfloor
\end{aligned}
$$

发现这就是 $m$ 和 $n - m$ 在 $p$ 进制加法中的进位次数.

### BSGS

求满足 $a^x \equiv b \pmod p$ 的最小自然数 $x$.

首先将 $b$ 变成 $b \% p$.

先假设 $a$ 和 $p$ 互质.

设 $Sq = \lceil \sqrt p \rceil$, 将 $a$ 分解成 $kSq + r$.

因为 $a^x \equiv a^{x \% \phi(p)}$,  所以 $x < p$, 所以 $k, r \leq Sq$.

原来的式子变成:

$$
\begin{aligned}
a^x &\equiv b \pmod p\\
a^{kSq + r} &\equiv b \pmod p\\
a^{kSq} &\equiv bInv_{a^{r}} \pmod p\
\end{aligned}
$$

处理出对于所有 $r \leq Sq$ 的 $BInv_{a^{r}}$, 存入 `map`, 然后枚举 $k$, 在 `map` 中查询 $a^{kSq}$, 如果存在, 那么就找到一个特解 $x$.

接下来将解最小化.

这时只要将 $x$ 变成 $x \% \phi(p)$ 即可.

然后考虑 $a$, $p$ 不互质的情况, 因为这时可能不存在 $Inv_{a^r}$. 记 $\gcd(a, p) = g$.

首先判有解, 有解当且仅当 $g|b$. 将方程转化为 $\frac {a}{g} a^{x - 1} \equiv \frac {b}{g} \pmod {\frac {p}{g}}$

如果这时 $a$ 和 $\frac{p}{g}$ 仍不互质, 仍然同时除以 gcd. 直到 $a$ 和 $p$ 互质位置这时方程会变成:

$$
\frac {a^{x}}{\displaystyle{\prod_{i}g_i}} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
\frac {a^{k}}{\displaystyle{\prod_{i}g_i}} a^{x - k} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
a^{x - k} \equiv \frac {b}{\displaystyle{\prod_{i}g_i}} Inv_{\frac {a^{k}}{\displaystyle{\prod_{i}g_i}}} \pmod {\frac {p}{\displaystyle{\prod_{i}g_i}}}\\
$$

这时 $a$ 和 $\frac {p}{\displaystyle{\prod_{i}g_i}}$ 互质, 则将 $\frac {b}{\displaystyle{\prod_{i}g_i}} Inv_{\frac {a^{k}}{\displaystyle{\prod_{i}g_i}}}$ 作为新的 $b$, $\frac {p}{\displaystyle{\prod_{i}g_i}}$ 作为新的 $p$, 做一次正常 BSGS 即可. 答案就是正常 BSGS 答案 $+ k$ 即可.

### 原根

一个数 $p$ 的原根 $x$ 需要满足 $x^0 \% p$, $x^1 \% p$, $x^2 \% p$, ..., $x^{p - 1} \% p$ 遍历了 $[0, p)$ 的所有整数.

一个数可以有多个原根.

### 莫比乌斯函数

仍设 $x = \prod_i p_i^{a_i}$

$$
\mu(x) =
\begin{cases} 
-1^{\sum a_i},  & (\forall a_i \leq 1)\\
0, & (\exists a_i \geq 2)
\end{cases}
$$

### 迪利克雷卷积

$$
f(i) = \sum_{j|i} a_jb_{\frac ij}
$$

假设将每一项都是 $1$ 的函数记为 $1$, 有结论 $1 * \mu = \epsilon$. $\epsilon$ 是迪利克雷卷积的单位元, 也就是说什么东西卷 $\epsilon$ 都是它本身. $\epsilon(1) = 1, \epsilon (i > 1) = 0$

迪利克雷卷积满足乘法交换律, 结合律, 分配律.

尝试构造 $f(x)$ 的迪利克雷卷积逆元 $g(x)$.

$$
g(x) = \frac{\epsilon(x) - \displaystyle{\sum_{d|x, d \neq 1} f(d)g(\frac xd)}}{f(1)}
$$

这时对于 $h = f * g$, 有:

$$
\begin{aligned}
h(1) &= g(1)f(1)\\
&= \epsilon(1) - \displaystyle{\sum_{d|1, d \neq 1} f(d)g(\frac 1d)}\\
&= \epsilon(1)\\
&= 1\\
\end{aligned}
$$

$$
\begin{aligned}
h(x) &= \sum_{i|x} g(i)f(\frac{x}{i})\\
&= \sum_{i|x} \frac{\epsilon(i) - \displaystyle{\sum_{d|i, d \neq 1} f(d)g(\frac id)}}{f(1)} \times f(\frac{x}{i})\\
\end{aligned}
$$

### 莫比乌斯反演

常用来判断 $[x = 1]$, 因为对于 $\sum_{d|x} \mu (d)$

$$
\begin{aligned}
f_n &= \sum_{d|n} \mu (d)\\
\end{aligned}
$$

### [P1516](https://www.luogu.com.cn/problem/P1516)

对 $n$, $m$, 求满足 $a + xn \equiv b + xm \pmod {p}$ 的最小的 $x$.

$$
\begin{aligned}
a + xn &\equiv b + xm \pmod {p}\\
x(n - m) &\equiv b - a \pmod {p}\\
x(n - m) &= b - a + kp\\
x(n - m) - k  p &= b - a
\end{aligned}
$$

用 Exgcd 求出 $x$ 即可.

### [NOI2010](https://www.luogu.com.cn/problem/P1447)

将问题转化为求下式的值:

$$
\sum_{i = 1}^{i \leq n}\sum_{j = 1}^{j \leq m} (2\gcd(i, j) - 1) 
$$

然后转化为枚举 $gcd$:

$$
\begin{aligned}
&\sum_{d = 1}\sum_{i = 1}^{i \leq n}\sum_{j = 1}^{j \leq m} (2d - 1)[\gcd(i, j) = d]\\
=&\sum_{d = 1}\sum_{i = 1}^{i \leq \frac{n}{d}}\sum_{j = 1}^{j \leq \frac{m}{d}} (2d - 1)[gcd(i, j) = 1]\\
=&2(\sum_{d = 1}\sum_{i = 1}^{i \leq \frac{n}{d}}\sum_{j = 1}^{j \leq \frac{m}{d}} d[gcd(i, j) = 1]) - 1\\
\end{aligned}
$$

### [POI2007](https://www.luogu.com.cn/problem/P3455)

将 $a$, $b$ 同时除以 $d$, 转化为求 $a$, $b$ 以内所有互质的数的个数, 对于每个数求 $\phi$

### [P1829](https://www.luogu.com.cn/problem/P1829)

### [SDOI2015](https://www.luogu.com.cn/problem/P3327)

定义 $d(x)$ 表示 $x$ 的约数个数, 给定 $n$, $m$, 求:

$$
\sum_{i = 1}^{n} \sum_{j = 1}^{m} d(ij)
$$

### 生成函数

???

## Day29: 线性代数

### 向量

对于 $(x_0, y_0)$ 和 $(x_1, y_1)$, 其点乘结果为 $x_0x_1 + y_0y_1$, 叉乘结果为 $x_0y_1 - x_1y_0$, 其绝对值是两个向量决定的平行四边形面积.

任意 $n$ 维向量 $(a_0, a_1, a_2,...,a_{n - 1})$, $(b_0, b_1, b_2,...,b_{n - 1})$, 其点乘定义为 $\prod_{i = 0}^{n - 1} a_i + \prod_{i = 0}^{n - 1} b_i$.

对于三维向量 $(x_0, y_0, z_0)$, $(x_1, y_1, z_1)$, 其叉乘定义为两个向量所在平面的法向量. 即为 $(y_0z_1 - z_0y_1, z_0x_1 - x_0z_1, x_0y_1 - x_1y_0)$

### 矩阵乘法

矩阵乘法的单位矩阵 $I_n$ 是一个 $n * n$ 的矩阵, 其左上右下对角线为 $1$, 其余部分为 $0$.

### 秩

两个向量 $(a_1, a_2, a_3,..., a_3)$ 线性相关, 定义为存在不全为 $0$ 的实数 $(c_1, c_2, c_3,..., c_n)$.

一个矩阵的秩代表最多取出多少行向量线性不相关.

一个矩阵的秩等于它转置矩阵的秩.

### 矩阵树定理

求无向图的生成树个数:

构造一个矩阵, 对角线上 $(i, i)$ 是第 $i$ 个点的度, 两个点 $i$, $j$ 之间连边就将 $(i, j)$ 和 $(j, i)$ 设为 $-1$, 钦定一个点为根, 则删掉这个点对应的行和列, 矩阵的行列式就是需要求的答案.

对于有向图, $(i, i)$ 记录出度, 每条有向边 $(i, j)$ 将 $(i, j)$ 置为 $-1$. 需要枚举每个点作为根, 然后求和.

### 特征多项式

$$
\begin{bmatrix}
1 1 1\\
1 1 a\\
1 1 1
\end{bmatrix}
$$

### 杜教筛

求积性函数前缀和.



## Day30: 欢乐模拟赛

### A

没读题亏死, "非空" 子段, 所以需要在最大子段和的程序上略加修改, 使得枚举的元素必选, 避免空选.

幸亏只挂了 $10'$.

```cpp
unsigned n;
long long a[1000005], K, B, Cnt(0), A, Ans(-0x3f3f3f3f3f3f3f3f), Tmp(0);
inline void Clr() {}
int main() {
  n = RD(), K = RDsg(), B = RDsg();
  for (register unsigned i(1); i <= n; ++i) {
    a[i] = RDsg() * K;
  }
  Ans = Tmp = a[1];
  for (register unsigned i(2); i <= n; ++i) {
    Tmp += a[i];
    if(Tmp < a[i]) Tmp = a[i];
    Ans = max(Ans, Tmp);
  }
  printf("%lld\n", Ans + B);
//  }
  return Wild_Donkey;
}
```

### B

貌似可以 $O(n)$, 但是场上想的 $O(n \log n)$, 所以就写了, 而且飞快.

因为有两个值, 生命和收益, 给两个值做前缀和, 记为 $H$, $W$. 因为收益单调不减, 所以固定左端点, 不死亡的前提下尽可能多走一定不会更劣. 

而左端点 $i$ 选在 $H$ 连续下降的末尾一定是极优的, 因为 $H_i < H_{i - 1}$, 所以选 $i - 1$ 相当于上来就直接去世. 而 $H_i \leq H_{i + 1}$, 所以选 $i$ 相当于比 $i + 1$ 多回了一次血或者多收益了一个单位.

接下来需要求固定左端点 $i$ 的不死亡最远点 $j$, 也就是右端点, 而这个左端点对应的答案就是 $W_j - W_{i - 1}$.

枚举左端点, 如果左端点为 $i$, 则右端点 $j$ 是 $j > i$ 的第一个 $H_j < H_i$ 的位置 $-1$.

使用 ST 查询 $H_i$ 的区间最小值, 然后二分右端点 $j$, 判断 $[i, j]$ 的最小值是否是 $H_i$, 如果是, 说明 $j$ 合法, 否则 $j$ 取大了.

ST 预处理 $O(n \log n)$, 枚举左端点 $O(n)$, 二分右端点 $O(\log n)$, 单次判断 $O(1)$, 总复杂度 $O(n \log n)$.

```cpp
int Pre[1000005][21];
unsigned m, n(1), Sum[1000005], Log[1000005], Bin[25], Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char a[1000005];
int Find(unsigned L, unsigned R) {
  register unsigned TmpF(Log[R - L + 1]);
  return min(Pre[L][TmpF], Pre[R - Bin[TmpF] + 1][TmpF]);
}
int main() {
  fread(a + 2, 1, 1000001, stdin);
  for (; a[n + 1] >= 'A'; ++n) a[n] -= 'A';
  a[n] -= 'A';
  if(n == 1) {
    if(a[1] == 0) Ans = 1;
    printf("%u\n", Ans);
    return 0;
  }
  for (register unsigned i(1), j(0); i <= n; ++j, i <<= 1) {
    Log[i] = j, Bin[j] = i;
  }
  for (register unsigned i(1); i <= n; ++i) {
    Log[i] = max(Log[i], Log[i - 1]);
  }
  Pre[0][0] = 0x3f3f3f3f, Pre[1][0] = 1, Sum[0] = 0;
  for (register unsigned i(2); i <= n; ++i) {
    Sum[i] = Sum[i - 1];
    Pre[i][0] = Pre[i - 1][0];
    if(!a[i]) ++Sum[i];
    else {
      if(a[i] ^ 1) ++Pre[i][0];
      else --Pre[i][0];
    }
  }
  for (register unsigned i(1), j(0); i < n; i <<= 1, ++j) {
    for (register unsigned k(1); k + i <= n; ++k) {
      Pre[k][j + 1] = min(Pre[k][j], Pre[k + i][j]);
    }
  }
  for (register unsigned i(1); i + 2 <= n; ++i) {
    if((Pre[i][0] < Pre[i - 1][0]) && (Pre[i][0] <= Pre[i + 1][0])) {
      register unsigned L(i + 2), R(n), Mid;
      while (L < R) {
        Mid = ((L + R + 1) >> 1);
        if(Pre[i][0] > Find(i, Mid)) {
          R = Mid - 1;
        } else {
          L = Mid;
        }
      }
      Ans = max(Ans, Sum[L] - Sum[i - 1]);
    }
  }
  if(Sum[n - 1] - Sum[n - 2]) Ans = max(Ans, (unsigned)1);
  if(Sum[n] - Sum[n - 1]) {
    Ans = max(Ans, (unsigned)1);
    if(Sum[n - 1] - Sum[n - 2]) Ans = max(Ans, (unsigned)2);
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

接下来是线性算法, 我们将之前枚举的极优左端点称为 "谷点", 考虑谷点的优劣关系, 如果一个谷点 $i_1 < i_2$, 且 $H_{i_1} < H_{i_2}$, 这时 $[i_2, j_2] \subset [i_1, j_1]$, 所以 $i_1$ 一定不比 $i_2$ 劣.

所以可能更新答案的谷点, 一定满足 $H$ 值随下标的增加而单调不增.

而这些谷点所对应的右端点是单调递增的, 所以可以双指针扫描整个数组, 总复杂度 $O(n)$.

```cpp
int Pre[1000005], Last(0x3f3f3f3f);
unsigned m, n(1), Sum[1000005], Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char a[1000005];
int main() {
  fread(a + 2, 1, 1000001, stdin);
  for (; a[n + 1] >= 'A'; ++n) a[n] -= 'A';
  a[n] -= 'A';
  if(n == 1) {
    if(a[1] == 0) Ans = 1;
    printf("%u\n", Ans);
    return 0;
  }
  Pre[0] = 0x3f3f3f3f, Pre[1] = 1, Sum[0] = 0;
  for (register unsigned i(2); i <= n; ++i) {
    Sum[i] = Sum[i - 1];
    Pre[i] = Pre[i - 1];
    if(!a[i]) ++Sum[i];
    else {
      if(a[i] ^ 1) ++Pre[i];
      else --Pre[i];
    }
  }
  for (register unsigned i(1), j; i <= n; ++i) {
    if((Pre[i] < Pre[i - 1]) && (Pre[i] <= Pre[i + 1])) {
      if(Pre[i] <= Last) {
        Last = Pre[i];
        for (j = i; (j < n) && (Pre[j] >= Pre[i]); ++j);
        Ans = max(Ans, Sum[j] - Sum[i - 1]);
        if(j > i) i = j - 1;
        else i = j;
      }
    }
  }
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

仍然有一种想法, 扫描的时候开一个 $Pre$ 数组记录最后一次前缀和出现这个值的位置

### C

讨论题.

首先可以发现, 一个点是前三名, 所有可到达这个点的点一定需要小于 $3$, 否则一定不合法. 所以所有入度大于等于 $3$ 的点都是废点, 不会被答案统计到, 并且所有它到达的点都是废点.

然后建分层图, 发现分层图中有用的节点最多只有 $3$ 层.

分析可能前三的点组成的性质:

- 每层节点内部没有连边

- 第一层节点入度为 $0$

- 第二层节点入度为 $1$ 或 $2$

- 第二层的点入度为 $2$ 的情况下不能有出边

- 第三层节点的入度要么为 $1$, 要么入度为 $2$ 的情况下满足两条入边起点中间也有连边, 深度分别是 $1$, $2$, 也就是 `a>b, b>c, a>c` 三个约束同时出现, 这时可以直接删除 `a>c` 这条边. 所以可以认为最后分层图中第三层的点合法入度为 $1$.

然后对于每种情况分析答案数量:

- `1, 2, 3`

这种情况是指指定一个第三层的点作为第三名, 由于它只有一个入度, 来自一个第二层的点, 于是选中这个点作为第二名, 因为有出度的第二层的点只有一个入度, 所以最后一个作为第一名的点也确定了. 所以每个第三层的点对应一个 `1, 2, 3` 方案. 剩下的情况都不含第三层的点.

- `1, 2, 2`

这种情况选定了一个第一层的点做第一名, 然后任选两个入度为 $1$ 的第二层点做第二和第三. 假设一个第一层的点出边连向 $x$ 个入度为 $1$ 的第二层的点, 那么这个点对 `1, 2, 2` 方案贡献的答案就是 $A_2^x$, 也就是 $x(x - 1)$.

- `1, 1, 2`

这是针对入度为 $2$ 的第二层的点的, 选定一个入度为二的第二层的点做第三名, 它的两条入边对应的两个第一层的点分别做第一和第二, 每个入度为 $2$ 的第二层的点对应 $2$ 中方案.

- `1, 2 + 1`

这种方案选择了一个第一层的点, 一个它出边对应的入度为 $1$ 的第二层的点, 然后任选另外一个第一层的点, 分别作第一, 第二, 第三. 一开始选定的两个点按顺序做剩下的两名. 假设第一层有 $y$ 个点, 那么每个入度为 $1$ 的第二层的点都会对答案做出 $3(y - 1)$ 个贡献.

- `1 + 1 + 1`

三个入度为零的点任意组合, 假设有 $y$ 个入度为 $0$ 的点, 则对答案贡献为 $A^y_3[y \geq 3]$.

考场上得了 $20'$, 原因是将第三层的入度大于 $1$ 的点一棍子打死了, 没有考虑 `a>b, b>c, a>c` 也是可行的, 漏掉了 `a` 第一, `b` 第二, `c`第三的答案.

改了一下午变成 $30'$, 原因是将所有第三层入度为 $2$ 的点, 只要满足两个入度对应的点有约束关系就放走了, 以至于将 `a>b, b>c, a>c, d>b` 数据中的 `c` 放走了, 需要判断每个点的入度再讨论是否放走.

实现方面, 一开始从所有入度为 $0$ 的点多源 BFS, 一边分层一边删除点. 然后在所有打 `Ava` 标记的可行点组成的分层图上以每个点为跑 DFS, 然后统计五种答案.

复杂度也很简单, 一开始排序去重 $O(m \log m)$, BFS 时每个点都会入队一次, 遍历所有的边, $O(n + m)$, DFS 的时候, 一个第三层的点只会被一个第一层的点搜到, 而一个第二层的点最多被搜到两次, 所以复杂度 $O(n)$. 总复杂度 $O(m \log m + n)$.

```cpp
struct EdIn {
  unsigned Fr, To;
  inline const char operator < (const EdIn &x) const {
    return (this->Fr ^ x.Fr) ? (this->Fr < x.Fr) : (this->To < x.To);
  }
  inline const char operator == (const EdIn &x) const {
    return (this->Fr == x.Fr) && (this->To == x.To);
  }
}EI[200005];
struct Edge;
struct Node {
  Node *In1, *In2;
  char Ava;
  unsigned Dep, ID, OD;
  Edge *Fst;
}N[100005], *Q[100005];
inline void Print(Node *x) {
  printf("Node %u ID %u OD %u Ava %u Dep %u\n", x - N, x->ID, x->OD, x->Ava, x->Dep);
  printf("In1 %u In2 %u\n", x->In1 - N, x->In2 - N);
}
struct Edge {
  Node *To;
  Edge *Nxt;
}E[200005];
unsigned m, n, Hd, Tl;
unsigned long long Cnt(0), Cnt0(0), Ans(0);
void DFS (Node *x) {
  register Edge *Sid(x->Fst);
  register unsigned TA(0);
  while (Sid) {
    if(Sid->To->Ava) {
      ++(x->OD);
      if((Sid->To->Dep == 2) && (Sid->To->ID == 1)) DFS(Sid->To);
      if(x->Dep == 1) {
        if(Sid->To->ID == 2) ++Ans;// 1, 1, 2
        else {
          Ans += Sid->To->OD;// 1, 2, 3
          Ans += 3 * (Cnt0 - 1); // 1, 2 + 1
          ++TA; // 1, 2, 2
        }
      }
    }
    Sid = Sid->Nxt;
  }
  Ans += ((unsigned long long)TA * (TA - 1));
}
int main() {
  n = RD(), m = RD();
  for (register unsigned i(1); i <= m; ++i) {
    EI[i].Fr = RD(), EI[i].To = RD();
  }
  sort(EI + 1, EI + m + 1);
  m = unique(EI + 1, EI + m + 1) - EI - 1;
  for (register unsigned i(1); i <= m; ++i) {
    ++N[EI[i].To].ID;
    E[i].Nxt = N[EI[i].Fr].Fst;
    N[EI[i].Fr].Fst = E + i;
    E[i].To = N + EI[i].To;
    if(N[EI[i].To].In1) N[EI[i].To].In2 = EI[i].Fr + N;
    else N[EI[i].To].In1 = EI[i].Fr + N;
  }
  Hd = Tl = 0;
  for (register unsigned i(1); i <= n; ++i) if(!(N[i].ID)) {
    ++Cnt0, N[i].Dep = 1, Q[++Tl] = N + i, N[i].Ava = 1;
    continue;
  }
  if(Cnt0 >= 3) Ans = (unsigned long long)Cnt0 * (Cnt0 - 1) * (Cnt0 - 2);
  register Node *Now;
  register Edge *Sid;
  while (Hd < Tl) {
    Now = Q[++Hd], Sid = Now->Fst;
    while (Sid) {
      if(!(Sid->To->Dep)) {
        Sid->To->Dep = Now->Dep + 1;
        Q[++Tl] = Sid->To;
        if(Now->Dep == 1) {
          if(Sid->To->ID <= 2) {
            Sid->To->Ava = 1, Sid = Sid->Nxt;
            continue;
          }
        } else {
          if((Sid->To->ID == 1) && (Now->Dep == 2)) { // Available
            Sid->To->Ava = 1, Sid = Sid->Nxt;
            continue;
          }
        }
      } else {// Visited
      	Sid->To->Dep = Now->Dep + 1;
      	if(Sid->To->Dep > 3) {
      	  Sid->To->Ava = 0;
          Sid = Sid->Nxt;
          continue;
        }
      	if(Sid->To->Dep == 3) {
      	  if((Now->ID == 1) && (Sid->To->ID == 2)) { // Available
            if(Sid->To->In1 == Now) {
              if((Sid->To->In2 == Now->In1) || (Sid->To->In2 == Now->In2)) {
                Sid->To->Ava = 1, --(Now->OD), Sid = Sid->Nxt;
                continue;
              }
            } else {
              if((Sid->To->In1 == Now->In1) || (Sid->To->In1 == Now->In2)) {
                Sid->To->Ava = 1, --(Now->OD), Sid = Sid->Nxt;
                continue;
              }
            }
          }
          Sid->To->Ava = 0;
        }
      }
      Sid = Sid->Nxt;
    }
  }
  for (register unsigned i(1); i <= n; ++i) if(!(N[i].ID)) DFS(N + i);
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```


### 