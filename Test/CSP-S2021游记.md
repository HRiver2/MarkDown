# CSP-S2021

[前传: CSP-S2020爆零记](https://www.luogu.com.cn/blog/Wild-Donkey/csp2020-s-2-bao-ling-ri-ji)

## Day $-4$

因为早上 $8:00$ 线上模拟赛和升旗冲突和班主任起了矛盾, 结果九牛二虎之力提前来机房后, 尴尬地迎接 $7:40$ 升完旗来机房的同学.

模拟赛打得不错, 但是身体有点吃不住了, 前一阵子 SD 来了寒潮, 衣服不够的我显然是受凉了, 气管一直不舒服, 半个多星期不见好, 害怕影响考试, 加上颈椎难受的一批, 所以当天晚上决定回家.

拍了片子发现是气管有问题, 肺没事, 吃点感冒药就可以, 查的血发现一个箭头都没有, 比正常人还健康.

晚上回家颓大废, 颈椎也没有受到晚自习的伤害.

## Day $-2$

教练用我去年的亲身经历教导兄弟们要注意文件操作, 防止爆零.

## Day $-1$

教练把前一天的注意事项原封不动又发了一遍.

群里有个头铁的老哥发了一个[信息学](https://g.eqxiu.com/s/LdbGFBFX?eqrcode=1&share_level=2&from_user=20211004b21ae00f&from_id=9abbe8f9-7&share_time=1634798804210)的链接就被踢了, 具体原因懂的都懂.

机房里的哥们被要求想一个口号, 在集合拍照的时候要喊, 不知道是谁为了致敬去年的我创造的经典, 搞出一个充满恶意 (bushi) 的口号:

$$
人生在勤\ 志达天下\\
亮剑精神\ 信息之光\\
脚踏实地\ 勇争第一
$$

最离谱的是, 他们自己也要喊, 我仿佛看见到那一天直接集体社死...

## Day $0$

学长纷纷用自己的经历现身说法, 更是有[扶苏](https://www.luogu.com.cn/user/65363)引经据典 (当然又是我), 告诉后人注意文件操作和一些别的事项.

同学都在中午离校了, 有些自驾去日照的哥们已经出发了. 我仍然在

## Day $1$

哥们通知 $8:00$ 火车站集合, 因为当天晚上回来, 如果坐地铁就回不了家了, 火车站又不方便停车, 于是我妈决定骑摩托车送我.

我计算上午 $7:30$ 出门完全没有问题, 但是我没有算到从出门到骑上车还有 $10min$ 的损耗, 以至于我妈一路危险驾驶, 闯了一万个红灯, 我在后座叫得和傻逼一样, 因为实在是太惊悚了.

不知是路上的汽车都吓坏了, 还是摩托车太牛逼了, 一路上只有别人给我妈让路, 没有我妈给别人让路的.

最后竟然只用了 $20min$ 就到了. 事后我妈深刻觉得这种不要本子的开法比较离谱.

到了以后见了同学又是一番你假我, 我假你. 我不胜其烦便去给学弟吹牛逼 (指去年的爆零经验).

真是个 OIer 听了都落泪的好故事, 所以非常令人满意, 我们学校今年没有因为文件操作丢分的人.

检票的时候, 我想到[这篇博客(过长慎点)](https://www.luogu.com.cn/blog/Wild-Donkey/zroi-day11-day20-bi-ji)还有一道题没做完, 自己可是立下 Flag 要在 CSP 之前写完这篇博客的啊.

听别人说[这题](https://www.luogu.com.cn/problem/P6478)很难, 不建议我做, 还提醒我说需要二项式反演, 但是我觉得在车上没事干, 所以还是开题了.

上车后用热点开题, 因为知道了二项式反演, 所以自以为貌似想出了正解, 看题解果然想的没错, 然后把这个题写了.

交了一发 TLE, 下载数据发现自己的程序可以被一条链卡到 $O(n^3)$, 但是我之前这样写的树形背包都能过, 还有人证明了树上背包复杂度是 $O(n^2)$ (没错就是我, 在前面链接的那篇超长博客里面有).

但是眼看已经快到了, 没时间纠结了, 一发启发式合并上去就过了, 虽然可能是 $O(n^2\log n)$, 但是好在没卡 $\log$.

事后才发现, 我之前是枚举总共选 $i$ 个, 特定子树选 $j$ 个, 这样在子树大小很大的时候, $i$ 和 $j$ 都是 $O(n)$, 单次转移 $O(n^2)$ 不可均摊. 正宗的树形背包是枚举除特定子树以外选 $i$ 个, 特定子树选 $j$ 个, 这样复杂度就对了.

随后在火车上怒发博客.

发完以后没事干, 便去读自己去年的又一[经典著作](https://www.luogu.com.cn/blog/Wild-Donkey/wd-di-csp-s-2020-zhun-bei), 虽然字里行间的都是菜, 但是确实有那么一点用.

接下来听说老师家长不让进校园, 大伙欣喜若狂, 这样那个羞耻的口号喊不喊就无所谓了.

在校门口大家气氛愉快地乳了一遍去年我的爆零就进场了.

## 场上

进场前我寻找二号考场, 准考证上写的是在一楼, 我们从大门进来之后直接就是二楼, 找楼梯发现都是往上的, 还好有个好心的小姐姐告诉我要先上楼再下楼, 路上我在心中默默为设计师的奇妙思路击节叫好.

在场外放手机, 在窗台上放怕掉了, 发现走廊边上的瓷砖是黑的, 因为手机正反面都黢黑, 所以可能别人一脚就给送走了, 好不容易找到一个哥们带了白手机, 把他的手机扣在我手机上面才放心, 这样干碎我手机少说也要两脚.

往考场偷瞄发现这次的键盘貌似比上次的强一些, 至少键程不会和上次一样像笔记本键盘那么短了, 而且貌似排列上比上次合理了一些, 没有那么容易误触了, 上了场才发现合理个鸡巴, 原来的绝对值那个符号, 应该在主键盘最右边, `Enter` 上方, 结果他给整了个 `L` 形的回车, 然后 `|` 被挤到了左边, 然后我每次写 `\n` 都会换个行, 然后打一个 `n`.

### 试机

先调编译选项, 首先问候山东组委会, CCF 官方开 `C++14`, 你本地的破编译器连个 `C++14` 都开不了, 还在 C 盘放了个更古老的 `MinGW`, 索性开了 `C++11`, 凑合用吧, 结果又来个当头一棒没法开栈, 我一度怀疑我 `--stack=512000000` 是拼错了, 结果出来才发现是都没法开, 只能默默祈祷这次没有大递归.

感觉去年试机的时间极短, 对拍器没写完就发文件了, 所以今天我特意嘱咐学弟要节省时间, 试机时间非常短, 结果今年有哥们试机的时候实在没事干线段树都调完了.

我则是岁月静好, 把所有的缺省源都写了, 甚至像我一直用的缺省源一样, `int`, `unsigned` 分别写了快读. 然后用 `scanf()` 拍我的快读.

据说 (心酸的 "据说") 去年 NOIp 的时候试机结束要求互删文件, 但是你如果把代码放到缺省源的设置里, 就可以合法保存.

然后发现电脑的表不准, 还好带了手表, 并且, 还好电脑的表快, 如果表慢可能就会出问题.

## 开题

输了密码后, 打开文件, 沉浸在没法开栈的疑惑中, 正尝试使用 C 盘的离谱编译器, 这时候才发现自己不会使, 对嘲笑在机房卷题用命令行编译的老哥[一Iris一](https://www.luogu.com.cn/user/307042)道个歉, 是我大意了.

先是看了半天题面前面的东西:

> 嗯不错 $512MB$ 很慷慨

> $1s$ $1s$ $1s$ $3s$ 还算正常

> 果然是 $-O2$ 赶紧看看我本题开了没有

> 草, 我还是不甘心啊, 为什么开不了栈啊啊啊啊

> 不错, 少爷机也不是太拉

然后怀着去年被 `julian` 杀的忐忑心情开了 A 题.

## Airport

首先思考了一下对于只考虑国内, 是否满足飞机数量随廊桥增加而增加.

然后在求证的过程中发现一个性质, 就是无论廊桥数量如何, 对于有 $i$ 个廊桥的时候, 被满足的飞机停靠的廊桥编号在有更多廊桥时不会编号.

换个说法, 就是如果在某种情况下, 某飞机停到 $i$ 号廊桥上, 那么无论廊桥如何增加, 它仍然会停到 $i$ 号廊桥上.

那么我们就先考虑国内, 假设一开始廊桥无限, 给每个飞机标号, 记录它们停靠的廊桥编号.

很容易得到, 有 $i$ 个廊桥时, 国内飞机被满足的数量就是标号 $\leq i$ 的飞机数量.

如果求出国内选 $i$ 个的满足数量, 还有国外选 $i$ 个的满足数量, 那么 $O(n)$ 枚举方案就可以得到答案了.

不是吧, 才开几分钟, 笔都没捂热乎, 就切掉了 T1 吗? 我赶紧读题, 又思考了实现的细节, 发现果然没什么问题, 于是开始打代码.

那么如何求呢? 很显然, 只要模拟题目的贪心过程即可.

我们一开始将国内飞机按到达时间从小到大排序, 把所有廊桥都插入一个小根堆 (只要廊桥数量不小于飞机, 就可以认为廊桥无限). 然后按飞机顺序, 每次取堆顶把飞机停进去, 弹出堆顶即可.

接下来考虑模拟飞机离开, 我们把飞机时间表离散化, 用一万个 `vector` 维护每个时间离开的飞机, 这样每次枚举时间, 模拟时间推移, 然后将这个时候来的飞机标号赋值, 将这次插入的飞机的结束时间对应的 `vecotor` 插入这个飞机的编号, 然后把这个时候离开的飞机对应的廊桥重新插入堆里, 相当于释放了这个廊桥的位置.

分别用两个数组存两种飞机在不同数量廊桥的情况下的满足数量, 然后枚举 $i$ 个廊桥给国内, $n - i$ 个给国外, 求满足数量之和的最大值即可.

然后测了样例, 从小测到大畅通无阻, 一看表 (我当时已经忘了监考员提醒电脑的表快了) 才用了 $45min$ 就过了大样例了 (实际应该是 $30min$, 包括一开始开栈和读表格的时间). 心想, 这个题反正我也没有暴力, 懒得拍了, 我看这个大样例挺强的, 我趁着又劲先开题吧, 于是没有管它, 直接开题去了.

接下来是考场代码:

```cpp
#include<cstdio>
#include<cstring>
#include<set>
#include<algorithm>
#include<string>
#include<map>
#include<bitset>
#include<vector>
#include<queue>
#include<iostream>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while ((Rch < '0') || (Rch > '9')) Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while (((Rch < '0') || (Rch > '9')) && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
inline unsigned Rand(unsigned L, unsigned R) {
  return L + (rand() * rand() % (R - L + 1));
}
struct Bri {
  unsigned Fr, To, Bel;
  inline const char operator< (const Bri &x) const {return Fr < x.Fr;}
}P[100005];
priority_queue<unsigned> Br;
vector<unsigned> Dec[200005];
unsigned a[200005], n, m1, m2;
unsigned A, B, C, D;
unsigned Sum1[100005], Sum2[100005];
unsigned Cnt(0), Ans(0), Tmp(0);
inline void Calc(unsigned m, unsigned *Sum) {
  Cnt = 0;
  for (unsigned i(1); i <= m; ++i) {
    P[i].Fr = a[++Cnt] = RD();
    P[i].To = a[++Cnt] = RD();
  }
  sort(a + 1, a + Cnt + 1);
  sort(P + 1, P + m + 1);
  Cnt = unique(a + 1, a + Cnt + 1) - a;
  for (unsigned i(1); i <= m; ++i) {
    P[i].Fr = lower_bound(a + 1, a + Cnt, P[i].Fr) - a;
    P[i].To = lower_bound(a + 1, a + Cnt, P[i].To) - a;
  }
//  for (unsigned i(1); i <= m; ++i) printf("%u [%u, %u]\n", i, P[i].Fr, P[i].To);
  for (unsigned i(1); i <= m; ++i) Br.push(m + 1 - i);
  for (unsigned i(1), j(1); i <= Cnt; ++i) {
    while(P[j].Fr == i) {
      P[j].Bel = m - Br.top() + 1;
      Dec[P[j].To].push_back(Br.top());
      Br.pop(), ++j;
    }
    for (auto k:Dec[i]) {
      Br.push(k);
    }
  }
//  for (unsigned i(1); i <= m1; ++i) {
//    printf("%u Bel %u\n", i, P[i].Bel);
//  }
  for (unsigned i(1); i <= m; ++i) ++Sum[P[i].Bel];
  for (unsigned i(1); i <= n; ++i) Sum[i] += Sum[i - 1];
  memset(P, 0, (m + 2) * sizeof(Bri));
  for (unsigned i(1); i <= Cnt; ++i) Dec[i].clear();
  while(Br.size()) Br.pop();
}
signed main() {
  freopen("airport.in", "r", stdin);
  freopen("airport.out", "w", stdout);
  n = RD(), m1 = RD(), m2 = RD();
  Calc(m1, Sum1);
  Calc(m2, Sum2);
  for (unsigned i(0); i <= n; ++i) {
    Ans = max(Ans, Sum1[i] + Sum2[n - i]);
  }
  printf("%u\n", Ans);
	return 0;
}
/*
3 5 4
1 5
3 8
6 10
9 14
13 18
2 11
4 15
7 17
12 16

7

2 4 6
20 30
40 50
21 22
41 42
1 19
2 18
3 4
5 6
7 8
9 10

4
*/
```
## Bracket

这个时候我洋洋得意, 便来看 T2, 看完小 w 遇到的问题, 大骂出题人这次题怎么这么水, 正要写代码, 发现原来小 w 觉得这个题水了, 心中一个 "危" 字, 然后就看见小 w 迫害小 c 的全过程, 真是小 w 一笑, 生死难料啊.

仔细想想这个题貌似也不难, 在小 w 遇到的问题上加一维状态就好了, 一看数据, $O(n^3)$ 能过. 得! 写代码!

这个可怜的孩子还没发现他读错题了.

设计状态 $f_{i, j, k}$ 表示前 $i$ 位, 左括号减右括号数量为 $j$, 末尾有 $k$ 个 `*` 的方案数.

下面的方程中, $m$ 表示最多连续的 `*` 数量:

$$
\begin{aligned}
f_{i, j, k} &= f_{i - 1, j, k - 1} (a[i] = '*')\\
f_{i, j, k} &= 0 (a[i] = '(' or ')'), (k > 1)\\
f_{i, j, 0} &= \sum_{k = 0}^{m} f_{i - 1, j - 1, k} (a[i] = '(')\\
f_{i, j, 0} &= \sum_{k = 0}^{m} f_{i - 1, j + 1, k} (a[i] = ')')\\
f_{i, j, k} &= f_{i - 1, j, k - 1} (a[i] = '?'), (k > 1)\\
f_{i, j, 0} &= \sum_{k = 0}^{m} f_{i - 1, j - 1, k} + f_{i - 1, j + 1, k} (a[i] = '?')\\
\end{aligned}
$$

然后大概花了十几分钟把转移方程在纸上写出来, 然后花了十几分钟写出来, 发现死活过不了小样例, 输出了整个 DP 数组都没发现哪里有问题, 然后手玩了样例发现自己的答案是 $6$, 甚至用组合数学证明了答案就是 $6$.

看了样例解释后发现手玩的情况有一种不在解释里, 心想, 坏了读错题了, 然后就是当头一棒, 发现我不光读错题了, 而且读对之后的题我不会.

我之前的 DP 会把形如 `(*()*)` 的序列统计进去, 所以导致答案错误.

这个时候我想了好久, 先是考虑在原先的答案中去除不合法的, 但是显然这更加困难, 然后又想在转移上下功夫, 但是事实证明这也是不可行的.

于是推倒重来, 因为我发现了合法序列的可合并性, 所以把区间合并起来的做法自然就是区间 DP.

设计状态 $f_{Len, i}$ 表示区间 $[i, i + Len - 1]$ 是合法序列的情况.

发现合法序列左端是 `(`, 右端是 `)`

对于 $a[i]$ 不可能是 `(` 或 $a[i + Len - 1]$ 不可能是 `)` 的情况, $f_{Len, i} = 0$.

然后转移是 $$.

然后接下来的做法和历程就和我写的[题解](https://www.luogu.com.cn/blog/Wild-Donkey/csp-s-2021-kuo-hao-xu-lie)差不多了.

```cpp
#include<cstdio>
#include<cstring>
#include<set>
#include<algorithm>
#include<string>
#include<map>
#include<bitset>
#include<vector>
#include<queue>
#include<iostream>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while ((Rch < '0') || (Rch > '9')) Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while (((Rch < '0') || (Rch > '9')) && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
unsigned long long Mod(1000000007);
unsigned long long f[505][505], g[505][505][2];
unsigned n, m;
unsigned A, B, C, D;
unsigned Cnt(0), Ans(0), Tmp(0);
char a[505];
signed main() {
  freopen("bracket.in", "r", stdin);
  freopen("bracket.out", "w", stdout);
  n = RD(), m = RD();
  scanf("%s", a + 1);
  for (unsigned i(n); i; --i) g[0][i][0] = f[0][i] = 1;
  for (unsigned Len(2); Len <= n; ++Len) {
    for (unsigned i(n - Len + 1); i; --i) {
      for (unsigned len(1); len < Len && len <= m; ++len) {
        if((a[i + Len - len] == '(') || (a[i + Len - len] == ')')) break;
        g[Len][i][1] += g[Len - len][i][0];
        if(g[Len][i][1] >= Mod) g[Len][i][1] -= Mod;
      }
      if((a[i] == '*') || (a[i] == ')') || (a[i + Len - 1] == '*') || (a[i + Len - 1] == '(')) {
        continue;
      }
      unsigned Tol(min(Len - 2, m));
      f[Len][i] = g[Len - 2][i + 1][0] + g[Len - 2][i + 1][1];
      if(f[Len][i] >= Mod) f[Len][i] -= Mod; 
      for (unsigned len(1); len <= m && len + 2 <= Len; ++len) {
        if((a[i + len] == '(') || (a[i + len] == ')')) break;
        f[Len][i] += g[Len - 2 - len][i + len + 1][0]; 
        if(f[Len][i] >= Mod) f[Len][i] -= Mod; 
      }
      g[Len][i][0] = f[Len][i];
      for (unsigned len(2); len + 2 <= Len; ++len) {
        g[Len][i][0] = (g[Len][i][0] + g[len][i][1] * f[Len - len][i + len]) % Mod;
      }
      for (unsigned len(2); len + 2 <= Len; ++len) {
        g[Len][i][0] = (g[Len][i][0] + g[len][i][0] * f[Len - len][i + len]) % Mod;
      }
//      printf("[%u, %u] %llu %llu %llu\n", i, i + Len - 1, f[Len][i], g[Len][i][0], g[Len][i][1]);
    }
  }
  printf("%llu\n", g[n][1][0]);
	return 0;
}
/*
546949722

4 2 
????
 
7 3
(*??*??

5

10 2
???(*??(?)
*/
```

## Palin

```cpp
#include<cstdio>
#include<cstring>
#include<set>
#include<algorithm>
#include<string>
#include<map>
#include<bitset>
#include<vector>
#include<queue>
#include<iostream>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while ((Rch < '0') || (Rch > '9')) Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while (((Rch < '0') || (Rch > '9')) && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while ((Rch >= '0') && (Rch <= '9')) Rtmp = (Rtmp << 3) + (Rtmp << 1) + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
unsigned n, m, a[20005], T;
unsigned Ans[20005], Now[20005];
unsigned Pos[10005];
unsigned L, R;
char Way[20005], AW[20005], Nope(0);
inline void Clr() {
  memset(Ans, 0x3f, sizeof(Ans));
  memset(Pos, 0,sizeof(Pos));
  memset(Now, 0,sizeof(Now));
  memset(AW, 0x3f,sizeof(AW));
  memset(Way, 0,sizeof(Way));
  Nope = 0, L = 1;
  R = m = ((n = RD()) << 1);
}
inline void DFS(unsigned Dep) {
//  if((Way[1] && (!(Way[2] | Way[3] | Way[4] | Way[5]))) && (Way[6] && (!(Way[7] | Way[8] | Way[9] | Way[10])))) {
//    printf("DFS %u\n", Dep);
//    for (unsigned i(1); i < Dep; ++i) printf("%u ", Now[i]);
//    putchar(0x0A);
//    for (unsigned i(1); i < Dep; ++i) printf("%u ", Way[i]);
//    putchar(0x0A);
//  }
  if(Dep > m) {
    Nope = 1;
    char Flg(0);
    for (unsigned i(1); i <= n; ++i) {
      if(AW[i] < Way[i]) break;
      if(AW[i] > Way[i]) {Flg = 1; break;}
    }
    if(Flg) {
      memcpy(Ans, Now, (m + 1) << 2);
      memcpy(AW, Way, m + 1);
    }
    return;
  }
  if(Dep > n) {
    if(m - Dep == Pos[a[L]] - 1) {
      Now[Dep] = a[L], Way[Dep] = 0, ++L;
      DFS(Dep + 1);
      --L;
    }
    if(m - Dep == Pos[a[R]] - 1) {
      Now[Dep] = a[R], Way[Dep] = 1, --R;
      DFS(Dep + 1);
      ++R;
    }
  } else {
    if(!Pos[a[L]]) {
      Now[Dep] = a[L], Way[Dep] = 0, Pos[a[L]] = Dep, ++L;
      DFS(Dep + 1);
      Pos[a[--L]] = 0;
    }
    if(!Pos[a[R]]) {
      Now[Dep] = a[R], Way[Dep] = 1, Pos[a[R]] = Dep, --R;
      DFS(Dep + 1);
      Pos[a[++R]] = 0;
    }
  }
}
signed main() {
  freopen("palin.in", "r", stdin);
  freopen("palin.out", "w", stdout);
  T = RD();
  for (unsigned t(1); t <= T; ++t) {
    Clr();
    for (unsigned i(1); i <= m; ++i) a[i] = RD();
    DFS(1);
    if(Nope) {
      for (unsigned i(1); i <= m; ++i) putchar(AW[i] ? 'R' : 'L');
      putchar(0x0A);
    } else {
      printf("-1\n");
    }
  }
	return 0;
}
/*
RLLLLRLLLLRLLLLLLLLLLRLRLLRRRLLRRLLLLLLL
2
20
10 16 7 13 18 19 14 15 20 9 2 12 17 4 8 1 11 11 8 17 12 5 15 18 3 13 7 16 10 6 19 14 20 9 2 4 1 5 3 6
5
4 1 2 4 5 3 1 2 3 5
3
3 2 1 2 1 3
*/
```