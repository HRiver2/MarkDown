# 后缀自动机 (Suffix Automaton)

## 定义

一个字符串的后缀自动机是一个 DAG (Directed Acyclic Graph), 边带权, 权值是一个字符, 除了起始节点 $O$, 节点分为两种, 一种是中间节点, 只是为了连边而新建的节点, 一种是结束节点, 表示从 $O$ 到它的路径上边的字符连起来是字符串的一个后缀. 最容易被忽视的, 每个节点一种边只能有一条, 也就是说, 从某个节点向外连接两条字符为 $b$ 的边是不被允许的. 在所有合法的 DAG 中, 后缀自动机是规模最小的一个.

后缀自动机从 $O$ 点出发, 任何一条到达某结束节点的路径上, 边的字符组成的字符串都是原字符串的一个不重复的后缀.

这样就可以推得后缀自动机的一个性质. 因为一个字符串的任意字串都能表示成它的某个后缀的前缀, 而且从 $O$ 出发到任意节点的路径都是从 $O$ 点到某个结束节点路径的一部分. 即任意从 $O$ 出发的路径都表示原字符串的一个子串.

**举例**

这是字符串 `sdflk` 的后缀自动机

![如果看到这个那么图片炸了](https://cdn.luogu.com.cn/upload/image_hosting/f7vjnjow.png)

其中, 节点 $①$ 是结束节点, 点 $O$ 是起始节点.

## $\mathbf{Endpos}$

引入一个概念, 一个字符串的子串 $[l, r]$ 的 $Endpos$ 就是它每次在字符串中出现时的末尾字符位置的集合. 

对于 $Endpos$ 有几种定理显而易见

1. 对于两个子串 $a$, $b$, 假设 $len_a < len_b$. 若有 $Endpos_a = Endpos_b$, 则 $a$ 是 $b$ 的后缀.

2. 对于两个子串 $a$, $b$, 假设 $len_a < len_b$. 如果 $a$ 是 $b$ 的后缀, 则 $Endpos_b \sube Endpos_a$; 否则 $Endpos_a \cap Endpos_b = \varnothing$

引入一个等价类的概念, 所有 $Endpos_i = Endpos$ 的字串 $i$ 组成一个 $Endpos$ 的等价类.

推广第一个定理, 易知一个等价类中的字符串, 短的是长的的后缀.

$Endpos$ 等价类有很多实用的性质, 可以通过反证法推得等价类中的子串长度是连续的区间, 且不存在长度相等的两个字符串.

## $\mathbf{Endpos}$ 等价类树

由于一个 $Endpos$ 等价类中的字符串是由最短的字符串在前面一个一个加字符得到的. 当在一个等价类最长的字符串 $a$ 前面加一个字符, 如果得到了一个原字符串的子串 $b$, 那么 $Endpos_b$ 一定是 $Endpos_a$ 的子集, $b$ 成为新的等价类的最短的字符串.

在原字符串 $s$ 中出现的所有的 $a$ 前面加一个字符得到的不全是同一个字符串, 否则 $a$ 就不是等价类中最长的字符串了.

在这些 $a$ 出现的位置中, 只要前面有字符, 就能组成一个以 $a$ 为后缀, 长度比 $a$ 大 $1$ 的字符串, 根据前面得到的结论, 所有这些字符串所在的等价类都是 $Endpos_a$ 的真子集.

根据前面的引理得, 所有的这些字符串的 $Endpos$ 交集为空. 所以对于 $s$ 的子串的所有的 $Endpos$ 等价类根据包含关系组成一个树形结构. 这个树以空串的 $Endpos$ 为根, 以不同的等价类为节点.

## $\mathbf{Link}$

后缀链接, 指从一个等价类中的最长字符串对应的节点 $a$ 连向这个等价类最短字符串 $b$ 去掉它的左端字符得到的字符串 $c$ 所在节点的指针. 易知 $c$ 是等价类 $Endpos_c$ 中最长的字符串. 这里的 $Endpos_a$ 是 $Endpos_c$ 的子集, 因为 $c$ 是 $a$ 的后缀, 所以 $a$ 出现时, $c$ 必然出现, $c$ 出现时, $a$ 可以不出现.

严格来说, $Endpos_a$ 是 $Endpos_c$ 的真子集, 如果 $Endpos_a = Endpos_c$, $b$ 就不是等价类中的最短字符串了, 因为 $c$ 也在这个等价类中, 且 $c$ 比 $b$ 更短.

由于 $c$ 是 $a$ 的后缀, 所以称为后缀链接.

容易发现, 后缀链接由下到上组成一个树形结构, 而这棵树恰恰就是 $Endpos$ 等价类组成的树形结构. 

后缀链接树的节点表示的是一个 $Endpos$ 等价类的最长字符串. 也就是说后缀链接树的节点和 $Endpos$ 等价类一一对应. 每一条边都是在一个等价类 $A$ 和满足 $Endpos_B \subsetneq Endpos_A$ 的等价类 $B$ 之间连接的.

## 构造

如果把规模大小限制去掉, 仅构造一个无大小限制的 SAM, 可以很容易想到, 枚举所有后缀, 插入一个 Trie, 每个后缀的尾字符是一个终止节点, 根是 $O$ 点, 把节点上的字符放到它和父亲之间的边上. 这样, 只要从根走到一个结束节点, 就能表示一个后缀.

考虑优化规模, 发现对于 `ababab` 这种字符串, Tire 有两条链, 但是如果构造一条链

$$
O \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 4 \xrightarrow{a} 5 \xrightarrow{b} 6
$$

其中 $2$, $4$, $6$ 是终止节点, 再从 $O$ 到 $2$ 连一条 $b$ 的边, 那么这就是一个 `ababab` 的后缀自动机了.

接下来尝试利用后缀链接树来构造 SAM.

SAM 中 $O$ 点到某个节点的路径表示的字符串中, 短的是长的的后缀. 所以一个节点的入边必然是同一个字符, 否则这个节点表示的字符串就不具有公共后缀了. 这就说明每个节点会有一个公共后缀, 而这个后缀是它所在 $Endpos$ 等价类中最短的字符串, 恰恰就和 $Endpos$ 等价类树上的节点一一对应, 也和后缀链接树上的节点一一对应.

以后缀链接树的节点为 SAM 的节点, 后缀链接树的节点表示的字符串作为 SAM 中 $O$ 走到这个节点的路径表示的所有字符串的最长字符串, SAM 节点的 $len$ 是这个节点表示的最长字符串的 $len$. 以后缀链接树中所有 $Endpos$ 中有元素 $len_s$ 的节点为 SAM 的结束节点, 因为这些节点的等价类中的字符串都是 $s$ 的后缀. 后缀链接树的根是空串, 也是 SAM 的起点 $O$.

考虑给 SAM 连边.

从边界情况开始, 空串的后缀自动机是一个起始节点, 后缀链接树只有一个根. 接下来尝试在空串后面一个一个加字符, 同时一边构造后缀自动机, 一边维护后缀链接树, 因为后缀链接树在后面的构造中会用到.

设新的字符是 $c$, 加入字符 $c$ 之前的字符串是 $s$, 代表 $s$ 等价类的节点设为 $last$. 一个字符加入时, 整个字符串长度增加, 新字符串 $s + c$ 的节点只能从 $last$ 通过一条边 $c$ 转移过来. $s + c$ 等价类中 $Endpos$ 的元素只有 $len_s + 1$.

希望找到 $s + c$ 对应的节点后缀链接连的点, 这个点的字符串是 $s + c$ 的后缀, 且在所有这些点中满足 $len$ 是最长的一个. 满足是 $s + c$ 后缀的节点, 必然是由一个 $s$ 的后缀节点通过出边 $c$ 连过来的. $s$ 的后缀节点都是后缀链接树中 $last$ 的祖先, 而前面已经把 $last$ 的后缀链接连好了, 所以只要顺着后缀链接往上走就能找到了.

一个字符的加入后, 对于所有后缀链接树中 $last$ 的祖先 $A$ (其等价类包含的字符串都是 $s$ 的后缀), 有两种情况.

* $A$ 有出边 $c$

  设 $A$ 表示的字符串是 $x$. 再次分类讨论
  
  * $len_A + 1 = len_{A \rightarrow c}$
  
    这时 $A \rightarrow c$ (指 $A$ 点通过出边 $c$ 转移到的节点) 的字符串是 $x + c$, $A$ 是所有转移到 $A \rightarrow c$ 中的节点中 $len$ 最长的, $A \rightarrow c$ 等价类中最长字符串去掉最后的 $c$ 后得到的字符串在等价类 $A$ 中. 因为等价类中所有字符串都是这个等价类最长的字符串的后缀, 所以 $A \rightarrow c$ 中其它的字符串都是 $x + c$ 的后缀, 更是 $s + c$ 的后缀.
    
    从 $s$ 的节点往上跳, $A$ 是目前找到的 $last$ 后缀链接树上的最近的满足 $A \rightarrow c$ 的等价类中所有字符串都是 $s + c$ 的后缀的祖先. 这时找到的 $x + c$ 是最长的, 因为再往上找, $A$ 的长度越来越小, $x + c$ 的长度也越来越小.

    这时 $A \rightarrow c$ 是后缀链接树上 $s + c$ 节点的父亲.

  * $len_A + 1 < len_{A \rightarrow c}$
    在众多有出边 $c$ 连向 $A \rightarrow c$ 的节点中, $A$ 的 $len$ 不是最长的, 设 $len$ 最长的点是 $C$, 其对应字符串是 $y$, $A \rightarrow c$ 的字符串是 $y + c$, $len_y > len_x$, $x$ 是 $y$ 的后缀.
    
    后缀链接树中, 一个节点的 $len$ 一定比它的祖先长, 所以 $C$ 不是 $A$ 的祖先. 又因为 $C$在后缀链接树中不是 $left$ 的比 $A$ 小的祖先, 所以 $C$ 不是 $left$ 的祖先. 也就是说, $y$ 不是 $s$ 的后缀.

    这时要想找 $s + c$ 的后缀, 已知 $x + c$ 是 $s$ 的后缀, 所以 $x + c$ 和 $y + c$ 不是一个等价类的. 原来的 $A \rightarrow c$ 节点分裂成两个, 一个是 $C \rightarrow c$ 节点, 表示比 $x + c$ 长的, 不是 $s + c$ 后缀的字符串的等价类; 另一个是新的 $A \rightarrow c$ 小于等于 $x + c$ 的, 是 $s + c$ 的后缀的字符串的等价类. 因为是从一个等价类分裂出来的, 所以后者 $Endpos$ 之比前者的多一个元素 $len_s + 1$.

    这时的 $A \rightarrow c$ 应当具有 $C \rightarrow c$ 的所有转移, 因为字符串有后缀 $y + c$ 的也一定会有后缀 $x + c$. 因为 $x + c$ 的节点的 $len$ 是目前找到的最长的 $s + c$ 的后缀长度, 所以 $s + c$ 节点的后缀链接树父亲是 $A \rightarrow c$. 又因为 $A \rightarrow c$ 是 $C \rightarrow c$ 的后缀, 所以 $A \rightarrow c$ 又是 $C \rightarrow c$ 后缀链接树上的父亲, $C \rightarrow c$ 原来的父亲变成 $A \rightarrow c$ 的父亲.

    最后, 由于 $A \rightarrow c$ 是复制出来的, 所以对于 $A$ 后缀链接树上的祖先, 它们的转移 $c$ 仍然是 $C \rightarrow c$, 而 $C \rightarrow c$ 的等价类中只剩下长度大于等于 $len_y + 1$ 的字符串了, $A$ 和它的祖先也就不能转移到 $C \rightarrow c$ 了, 所以把 $A$ 和原先转移 $c$ 到 $C \rightarrow c$ 上的祖先的转移 $c$ 连向 $A \rightarrow c$.

* 对应节点没有出边 $c$ 
  说明 $A$ 中所有字符串后面一个 $c$ 都没有, 而新加入的 $c$ 是第一个, 这时如果新建一个全新的点 $B$, $A$ 向这个点连边 $c$. $B$ 的等价类的元素只有 $len_s + 1$, 和 $last \rightarrow c$ 的等价类相同, 所以这个出边直接连向 $last \rightarrow c$, 无需新建节点.

  因为我们要找的是 $s + c$ 的后缀链接, 必须找到一个节点的等价类中的字符串都是 $s + c$ 的后缀, 所以继续在后缀链接树上往上跳. 如果最后都没找到, 说明 $c$ 在 $s$ 中没有出现, 所以没有后缀可寻, 后缀直接连向根.

容易发现, 只要 $s$ 的后缀 $x_1$, $x_2$ 不在同一个等价类, $x_1 + c$, $x_2 + c$ 也不在同一个等价类. 所以对于新节点的建立, 只要找出所有 $s$ 的后缀的等价类.

<!-- SAM 要求 $O$ 到每个点的路径可以和这个点表示的 $Endpos$ 等价类的所有字符串一一对应, 这样才能保证起点 $O$ 到结束节点的路径表示的字符串不重不漏地表示了 $s$ 的后缀, 并且 $O$ 到任意节点的路径和 $s$ 的所有子串一一对应. -->

<!-- 对于 $s$ 的前缀, 易知它们一定是各自等价类的最长的字符串. 所以每个前缀都有一个自己的节点, 而前缀 $i$ 和前缀 $i + 1$ 之间会有连边 $s_{i + 1}$. -->

<!-- 有些前缀 $[1, r]$ 的后缀 $[l, r]$ 和这个前缀在同一个等价类中, 那就在 $O$ 和前缀 $l$ 之间连边 $s_l$. -->

<!-- 接下来处理其它的等价类之间的连边,  -->

<!-- 用数学归纳法, 先证明 $O$ 以一条边直接连接的节点, 即存在单个字符组成的字符串的 $Endpos$ 等价类表示的节点. 所有 $s$ 中出现过的字符一定都会在 $O$ 点有一条边, 因为单个字符组成的子串一定在 $O$ 点走一条边就能走到. 而它们等价类中的其它字符串无非是在这个字符前面加了一个前缀而已, 如果在同一个等价类,  -->

SAM 中的边, 终点的公共后缀是在起点的公共后缀后加了一个字符 (即这条边表示的字符) 得到的字符串的后缀 (因为有多个点连向这个终点, 每个点公共后缀长度不同, 但是一定有一个最短的公共后缀, 它的后面加上连向终点的边表示的字符后得到的字符串即为终点的公共后缀). 所以 SAM 中在两点 $A$, $B$ 间连边, 设它们表示的字符串 (公共后缀) 分别为 $a$, $b$, 且 $len_a < len_b$. 必须满足 $b$ 去掉一个字符后是 $a$ 的后缀.

## 正确性

从 $O$ 点出发, 走到某个节点 $A$, 由于 $A$ 的字符串去掉最后一个字符后是连向 $A$ 的所有边的起点的字符串的后缀, 所以这些边的字符相同.

接下来看起点到结束节点的路径表示的字符串是否不重不漏表示了 $s$ 的后缀.

首先, 所有的结束节点的公共后缀都是 $s$ 的后缀, 这是我们前面已经说明了的. 每个点的字符串去掉最后一个字符又是连到这个点的边的起点的字符串的后缀. 所以 $O$ 到这个点的所有路径表示的字符串都是 $s$ 的后缀.

## 点数复杂度分析

由于每次加入一个字符时必然加入一个节点, 而且有一定概率会添加第二个节点, 所以后缀自动机最多有 $2n$ 个节点. 由于前两个字符加入时只会加入一个节点, 再加上空串的一个节点, 所以可以得到更紧确的上界 $2n - 1$.

## 时间复杂度分析

总的时间复杂度一定是 $O(n) * 每加入一个字符的均摊时间复杂度$, 所以分析每次加入字符的复杂度.

加入一个字符的时间取决于每个节点加入时寻找 $A$ 点 ($Last$ 有转移 $c$ 的最小祖先) 的向上跳的次数, 还有每次新建节点时将 $A$ 的转移 $c$ 连到 $C \rightarrow c$ 上的祖先的 $c$ 连回 $A \rightarrow c$ 上要更换转移的节点数. 其他情况下, 有关字符集的操作都暂时视为常数.

先分析向上跳的次数, 这取决于从 $Last$ 往上有多少没有转移 $c$ 的祖先. 节点数是线性的, 它们的转移只能产生不能消失, 所以一共有线性的节点没有转移 $c$, 所以总共最多添加线性数量的转移 $c$. 又因为字符集视为常数, 所以所有的向上跳的次数为线性.

接下来是修改转移的时候, 设从 $s + c$ 到空串的后缀链接链为 $L_{len_s + 1}$, 其节点 (除了空串节点) 都是由 $A$ 到空串节点的后缀链接链 $L_{len_s}$ 上的点转移来的. 每个节点只有一条转移 $c$, 所以 $L_1$ 上向 $C \rightarrow c$ 转移的节点最多有 $Len_{L_{len_s}} - Len_{len_s + 1} + 1$ 个 (无需连根节点). 也就是说如果 $L_i$ 的 $k$ 个节点被修改转移, 则 $len_{L_i} \leq len_{L_{i + 1}} - k + 1$, 所以总的修改转移的节点数为节点数 + 转移数, 两者都是线性, 所以这一步总复杂的也是线性.

## 模板 ([Luogu3804](https://www.luogu.com.cn/problem/P3804))

给一个字符串, 求这个字符串出现次数大于 $1$ 的子串的长度和出现次数的积的最大值.

$len_s \leq 10^6$

统计出现次数, 可以构造后缀自动机, 跑 DFS, 统计每个点能走到结束点的路径数, 这便是这个节点的等价类的字符串出现的次数.

这样做的原因也很简单, 一个子串必然是一个后缀的前缀, 所以这个子串的出现次数, 就是这个子串作为前缀的后缀的出现次数之和. 这个子串做前缀的后缀必然可以从这个子串转移到.  从某个点搜起, 它搜索树上儿子出现一次, 它也会出现一次, 只要统计搜索树上子树和即可.

还有一种做法是在表示前缀得节点上进行修改

既然知道了一个 $Endpos$ 等价类的出现次数, 统计最大值只要考虑这个等价类中最长字符串即可, 所以用这个等价类出现的次数乘这个节点的 $len$ 即可尝试更新答案.

代码



