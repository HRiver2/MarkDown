# 后缀自动机 (Suffix Automaton)

## 定义

一个字符串的后缀自动机是一个 DAG (Directed Acyclic Graph), 边带权, 权值是一个字符, 除了起始节点 $O$, 节点分为两种, 一种是中间节点, 只是为了连边而新建的节点, 一种是结束节点, 表示从 $O$ 到它的路径上边的字符连起来是字符串的一个后缀, 在所有合法的 DAG 中, 后缀自动机是规模最小的一个.

后缀自动机从 $O$ 点出发, 任何一条到达某结束节点的路径上, 边的字符组成的字符串都是原字符串的一个不重复的后缀.

这样就可以推得后缀自动机的一个性质. 因为一个字符串的任意字串都能表示成它的某个后缀的前缀, 而且从 $O$ 出发到任意节点的路径都是从 $O$ 点到某个结束节点路径的一部分. 即任意从 $O$ 出发的路径都表示原字符串的一个子串.

**举例**

这是字符串 `sdflk` 的后缀自动机

![如果看到这个那么图片炸了](https://cdn.luogu.com.cn/upload/image_hosting/f7vjnjow.png)

其中, 节点 $①$ 是结束节点, 点 $O$ 是起始节点.

```
0 ① k
0 1 l
1 ① k
0 2 f
2 1 l
0 3 d
3 2 f
0 4 s
4 3 d
```

## 构造

如果把规模大小限制去掉, 仅构造一个满足以上性质的 DAG, 可以很容易想到, 枚举所有后缀, 插入一个 Trie, 每个后缀的尾字符是一个终止节点, 根是 $O$ 点, 把节点上的字符放到它和父亲之间的边上. 这样, 只要从根走到一个结束节点, 就能表示一个后缀.

考虑优化规模, 发现对于 `ababab` 这种字符串, Tire 有两条链, 但是如果构造一条链

$$
O \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 4 \xrightarrow{a} 5 \xrightarrow{b} 6
$$

其中 $2$, $4$, $6$ 是终止节点, 再从 $O$ 到 $2$ 连一条 $b$ 的边, 那么这就是一个.

```
O 1 a
1 2 b
2 3 a
3 4 b
4 5 a
5 6 b
O 7 b
7 8 a
8 9 b
9 10 a
10 11 b
```
```
```