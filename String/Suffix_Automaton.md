# 后缀自动机 (Suffix Automaton)

## 定义

一个字符串的后缀自动机是一个 DAG (Directed Acyclic Graph), 边带权, 权值是一个字符, 除了起始节点 $O$, 节点分为两种, 一种是中间节点, 只是为了连边而新建的节点, 一种是结束节点, 表示从 $O$ 到它的路径上边的字符连起来是字符串的一个后缀. 最容易被忽视的, 每个节点一种边只能有一条, 也就是说, 从某个节点向外连接两条字符为 $b$ 的边是不被允许的. 在所有合法的 DAG 中, 后缀自动机是规模最小的一个.

后缀自动机从 $O$ 点出发, 任何一条到达某结束节点的路径上, 边的字符组成的字符串都是原字符串的一个不重复的后缀.

这样就可以推得后缀自动机的一个性质. 因为一个字符串的任意字串都能表示成它的某个后缀的前缀, 而且从 $O$ 出发到任意节点的路径都是从 $O$ 点到某个结束节点路径的一部分. 即任意从 $O$ 出发的路径都表示原字符串的一个子串.

**举例**

这是字符串 `sdflk` 的后缀自动机

![如果看到这个那么图片炸了](https://cdn.luogu.com.cn/upload/image_hosting/f7vjnjow.png)

其中, 节点 $①$ 是结束节点, 点 $O$ 是起始节点.

## $\mathbf{Endpos}$

引入一个概念, 一个字符串的子串 $[l, r]$ 的 $Endpos$ 就是它每次在字符串中出现时的末尾字符位置的集合. 

对于 $Endpos$ 有几种定理显而易见

1. 对于两个子串 $a$, $b$, 假设 $len_a < len_b$. 若有 $Endpos_a = Endpos_b$, 则 $a$ 是 $b$ 的后缀.

2. 对于两个子串 $a$, $b$, 假设 $len_a < len_b$. 如果 $a$ 是 $b$ 的后缀, 则 $Endpos_b \sube Endpos_a$; 否则 $Endpos_a \cap Endpos_b = \varnothing$

引入一个等价类的概念, 所有 $Endpos_i = Endpos$ 的字串 $i$ 组成一个 $Endpos$ 的等价类.

推广第一个定理, 易知一个等价类中的字符串, 短的是长的的后缀.

$Endpos$ 等价类有很多实用的性质, 可以通过反证法推得等价类中的子串长度是连续的区间, 且不存在长度相等的两个字符串.

## $\mathbf{Endpos}$ 等价类树

由于一个 $Endpos$ 等价类中的字符串是由最短的字符串在前面一个一个加字符得到的. 当在一个等价类最长的字符串 $a$ 前面加一个字符, 如果得到了一个原字符串的子串 $b$, 那么 $Endpos_b$ 一定是 $Endpos_a$ 的子集, $b$ 成为新的等价类的最短的字符串.

在原字符串 $s$ 中出现的所有的 $a$ 前面加一个字符得到的不全是同一个字符串, 否则 $a$ 就不是等价类中最长的字符串了.

在这些 $a$ 出现的位置中, 只要前面有字符, 就能组成一个以 $a$ 为后缀, 长度比 $a$ 大 $1$ 的字符串, 根据前面得到的结论, 所有这些字符串所在的等价类都是 $Endpos_a$ 的真子集.

根据前面的引理得, 所有的这些字符串的 $Endpos$ 交集为空. 所以对于 $s$ 的子串的所有的 $Endpos$ 等价类根据包含关系组成一个树形结构. 这个树以空串的 $Endpos$ 为根, 以不同的等价类为节点.

## $\mathbf{Link}$

后缀链接, 指从一个等价类中的最长字符串对应的节点 $a$ 连向这个等价类最短字符串 $b$ 去掉它的左端字符得到的字符串 $c$ 所在节点的指针. 易知 $c$ 是等价类 $Endpos_c$ 中最长的字符串. 这里的 $Endpos_a$ 是 $Endpos_c$ 的子集, 因为 $c$ 是 $a$ 的后缀, 所以 $a$ 出现时, $c$ 必然出现, $c$ 出现时, $a$ 可以不出现.

严格来说, $Endpos_a$ 是 $Endpos_c$ 的真子集, 如果 $Endpos_a = Endpos_c$, $b$ 就不是等价类中的最短字符串了, 因为 $c$ 也在这个等价类中, 且 $c$ 比 $b$ 更短.

由于 $c$ 是 $a$ 的后缀, 所以称为后缀链接.

容易发现, 后缀链接由下到上组成一个树形结构, 而这棵树恰恰就是 $Endpos$ 等价类组成的树形结构. 

后缀链接树的节点表示的是一个 $Endpos$ 等价类的最长字符串. 也就是说后缀链接树的节点和 $Endpos$ 等价类一一对应. 每一条边都是在一个等价类 $A$ 和满足 $Endpos_B \subsetneq Endpos_A$ 的等价类 $B$ 之间连接的.

## 构造

如果把规模大小限制去掉, 仅构造一个无大小限制的 SAM, 可以很容易想到, 枚举所有后缀, 插入一个 Trie, 每个后缀的尾字符是一个终止节点, 根是 $O$ 点, 把节点上的字符放到它和父亲之间的边上. 这样, 只要从根走到一个结束节点, 就能表示一个后缀.

考虑优化规模, 发现对于 `ababab` 这种字符串, Tire 有两条链, 但是如果构造一条链

$$
O \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 4 \xrightarrow{a} 5 \xrightarrow{b} 6
$$

其中 $2$, $4$, $6$ 是终止节点, 再从 $O$ 到 $2$ 连一条 $b$ 的边, 那么这就是一个 `ababab` 的后缀自动机了.

接下来尝试利用后缀链接树来构造 SAM.

SAM 中 $O$ 点到某个节点的路径表示的字符串中, 短的是长的的后缀. 所以一个节点的入边必然是同一个字符, 否则这个节点表示的字符串就不具有公共后缀了. 这就说明每个节点会有一个公共后缀, 而这个后缀是它所在 $Endpos$ 等价类中最短的字符串, 恰恰就和 $Endpos$ 等价类树上的节点一一对应, 也和后缀链接树上的节点一一对应.

以后缀链接树的节点为 SAM 的节点, 后缀链接树的节点表示的字符串作为 SAM 中 $O$ 走到这个节点的路径表示的所有字符串的最长字符串, SAM 节点的 $len$ 是这个节点表示的最长字符串的 $len$. 以后缀链接树中所有 $Endpos$ 中有元素 $len_s$ 的节点为 SAM 的结束节点, 因为这些节点的等价类中的字符串都是 $s$ 的后缀. 后缀链接树的根是空串, 也是 SAM 的起点 $O$.

考虑给 SAM 连边.

SAM 要求 $O$ 到每个点的路径可以和这个点表示的 $Endpos$ 等价类的所有字符串一一对应, 这样才能保证起点 $O$ 到结束节点的路径表示的字符串不重不漏地表示了 $s$ 的后缀, 并且 $O$ 到任意节点的路径和 $s$ 的所有子串一一对应.

对于 $s$ 的前缀, 易知它们一定是各自等价类的最长的字符串. 所以每个前缀都有一个自己的节点, 而前缀 $i$ 和前缀 $i + 1$ 之间会有连边 $s_{i + 1}$.

有些前缀 $[1, r]$ 的后缀 $[l, r]$ 和这个前缀在同一个等价类中, 那就在 $O$ 和前缀 $l$ 之间连边 $s_l$.

接下来处理其它的等价类之间的连边, 

<!-- 用数学归纳法, 先证明 $O$ 以一条边直接连接的节点, 即存在单个字符组成的字符串的 $Endpos$ 等价类表示的节点. 所有 $s$ 中出现过的字符一定都会在 $O$ 点有一条边, 因为单个字符组成的子串一定在 $O$ 点走一条边就能走到. 而它们等价类中的其它字符串无非是在这个字符前面加了一个前缀而已, 如果在同一个等价类,  -->

SAM 中的边, 终点的公共后缀是在起点的公共后缀后加了一个字符 (即这条边表示的字符) 得到的字符串的后缀 (因为有多个点连向这个终点, 每个点公共后缀长度不同, 但是一定有一个最短的公共后缀, 它的后面加上连向终点的边表示的字符后得到的字符串即为终点的公共后缀). 所以 SAM 中在两点 $A$, $B$ 间连边, 设它们表示的字符串 (公共后缀) 分别为 $a$, $b$, 且 $len_a < len_b$. 必须满足 $b$ 去掉一个字符后是 $a$ 的后缀.

## 正确性

从 $O$ 点出发, 走到某个节点 $A$, 由于 $A$ 的字符串去掉最后一个字符后是连向 $A$ 的所有边的起点的字符串的后缀, 所以这些边的字符相同.

接下来看起点到结束节点的路径表示的字符串是否不重不漏表示了 $s$ 的后缀.

首先, 所有的结束节点的公共后缀都是 $s$ 的后缀, 这是我们前面已经说明了的. 每个点的字符串去掉最后一个字符又是连到这个点的边的起点的字符串的后缀. 所以 $O$ 到这个点的所有路径表示的字符串都是 $s$ 的后缀.

## 点数复杂度分析

由于 SAM 的节点是 $Endpos$ 树的节点, 所以这样构造

## 算法流程

先求 $Endpos$, 

## 正确性
