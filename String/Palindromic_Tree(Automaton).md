# 回文树/自动机 (Palindromic Tree/Automaton)

回文树, 又称回文自动机 (PAM), 用来解决字符串的回文子串问题.

推荐先学 [后缀自动机](https://www.luogu.com.cn/blog/Wild-Donkey/hou-zhui-zi-dong-ji-suffix-automaton), [AC 自动机](https://www.luogu.com.cn/blog/Wild-Donkey/ac-zi-dong-ji-ahocorasickalgorithm), 三者会有很多相似之处, 学起来会更加愉快. 而 [Manacher](https://www.luogu.com.cn/blog/Wild-Donkey/manacher-algorithm) 的内容一点也没有用到, 无需为了学 PAM 特意学习.

## 定义

形态上是两棵树 + $Link$.

每个节点表示一个本质不同的回文子串. 该串长度即为该节点长度.

树边带权, 是自动机的转移边. 权值为一个字符 $c$, 表示起点两端同时加 $c$ 得到的新串存在并且作为另一个回文子串.

因为奇数长度的节点只能转移到奇数长度的节点, 所以存在两个根, 分别作为奇树和偶树的根.

$Link$ 边向长度小的节点转移, 表示该点最大的回文后缀. $Link$ 可以在两树之间连接.

建立一个数组 $Order$, 其中 $Order_i$ 表示原字符串中以第 $i$ 个字符为结尾的最长的回文子串的节点位置. 由于 $Order_i$ 的 $Link$ 是 $Order_i$ 的最长回文后缀. 所以通过 $Order$ 所在的 $Link$ 链可以访问以任意字符为结尾的的回文后缀.

## 构造

一开始是空串, 只有两个根, 偶根 $Link$ 连奇根. 考虑将一个字符 $c$ 加入到已经构建回文自动机的 $s$ 的后面会在哪里出现回文串. 

如果原来 $c$ 的后缀是回文串, 设 $c$ 的后缀中最长的回文串为 $[a, b]$, 则 $b = len_s$. 如果 $s_{a - 1} = c$, 则出现回文串 $[a - 1, b + 1]$, 验证 $[a, b]$ 所在节点是否有转移 $c$, 如果没有, 则转移.

接下来顺着 $[a, b]$ 的 $Link$ 链往上找, $Link$ 链上的节点都以 $b$ 为右界, 只要存在就尝试转移.

但是再审视一下回文后缀的性质, 每次新建的点真的不止一个吗? 如果 $s + c$ 的最长回文后缀是 $[a - 1, b + 1]$, 仍存在一个比 $b - a + 1$ 短的回文后缀 $[c, b + 1]$. 因为 $[a - 1, b + 1]$ 是回文串, 所以 $[a - 1, a - 1 + b - c]$ 也是一个和 $[c, b + 1]$ 本质相同的回文串. 所以不存在第二个新回文子串. 也就是说, 每个字符 $c$ 的加入最多带来一个新节点.

接下来考虑 $Link$ 的连接, $Order_{len_s + 1}$ 指向的 $Link$ 链上的节点是 $s + c$ 的后缀, 掐头去尾后一定是 $s$ 的后缀. 所以考虑寻找 $Order_{len_s}$ 的 $Link$ 链上的节点的转移 $c$ 转移到的节点, 以此求出 $Order_{len_s + 1}$ 的 $Link$ 链.

以上两步操作都是从 $Order_{len_s}$ 的 $Link$ 链上往上跳, 所以可以同时进行, 每次找到一个已经存在的或是新建的节点, 就把上一个 $Link$ 连过来.

以此类推, 便构造了一个回文自动机.

下面对复杂度的证明同样是将字符集规模看作常数.

## 空间复杂度

因为一个节点只有一个树上入边, 一个 $Link$ 出边. 空间复杂度取决于节点数, 每个节点和一个本质不同的回文子串一一对应, 只要分析本质不同的回文子串数量即可. 因为一共有 $n$ 个字符, 之前已经说明, 每个字符的加入最多新出现一个本质不同的回文串, 所以最多有 $n$ 个本质不同的回文串. 空间复杂度为 $O(n)$

## 时间复杂度

除了跳 $Order_{len_s}$ 的 $Link$ 链, 其它部分都是显然的线性复杂度, 所以着重分析跳 $Link$ 的复杂度.

因为转移树上的父亲长度比 $Order_{len_s + 1}$ 长 $2$, 而每个节点 $Link$ 的长度最多是这个点的长度 $-1$. 每次跳完 $Order_{len_s}$ 的 $Link$ 链, $Order_{len_s + 1}$ 最多有 $Order_{len_s}$ 的长度 $+1$ ($Order_{len_s + 1}$ 的 $Link$ 连向 $Order_{len_s + 1}$ 去掉左端的 $c$ 的节点).

## [模板](https://www.luogu.com.cn/problem/P5496)

求一个长度为 $n$ 的字符串的每一个前缀的回文后缀数量. ($n \leq 5 * 10^5$)

前缀 $[1, i]$ 的回文后缀数也就是 $Order_i$ 所在的 $Link$ 链去掉两根的长度. 建立 PAM, 记忆化搜索统计长度即可.

**代码**

```cpp

```